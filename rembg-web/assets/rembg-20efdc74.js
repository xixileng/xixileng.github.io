(function(){"use strict";const bitMethods={getBit(o){return this.data[getSlot(o)]&1<<getShift(o)?1:0},setBit(o){this.data[getSlot(o)]|=1<<getShift(o)},clearBit(o){this.data[getSlot(o)]&=~(1<<getShift(o))},toggleBit(o){this.data[getSlot(o)]^=1<<getShift(o)},getBitXY(o,t){return o>=this.width||t>=this.height?0:this.getBit(t*this.width+o)},setBitXY(o,t){this.setBit(t*this.width+o)},clearBitXY(o,t){this.clearBit(t*this.width+o)},toggleBitXY(o,t){this.toggleBit(t*this.width+o)}};function getSlot(o){return o>>3}function getShift(o){return 7-(o&7)}function setBitMethods(o){for(const t in bitMethods)o.prototype[t]=bitMethods[t]}function checkProcessable(o,t={}){let{bitDepth:e,alpha:n,colorModel:a,components:l,channels:c}=t;if(typeof o!="string"||o.length===0)throw new TypeError("processName must be a string");if(e&&(Array.isArray(e)||(e=[e]),!e.includes(this.bitDepth)))throw new TypeError(`The process: ${o} can only be applied if bit depth is in: ${e}`);if(n&&(Array.isArray(n)||(n=[n]),!n.includes(this.alpha)))throw new TypeError(`The process: ${o} can only be applied if alpha is in: ${n}`);if(a&&(Array.isArray(a)||(a=[a]),!a.includes(this.colorModel)))throw new TypeError(`The process: ${o} can only be applied if color model is in: ${a}`);if(l&&(Array.isArray(l)||(l=[l]),!l.includes(this.components))){let f=`The process: ${o} can only be applied if the number of components is in: ${l}`;throw l.length===1&&l[0]===1?new TypeError(`${f}.\rYou should transform your image using "image.grey()" before applying the algorithm.`):new TypeError(f)}if(c&&(Array.isArray(c)||(c=[c]),!c.includes(this.channels)))throw new TypeError(`The process: ${o} can only be applied if the number of channels is in: ${c}`)}function createBlob(o,t){o=o||[],t=t||{},typeof t=="string"&&(t={type:t});try{return new Blob(o,t)}catch(l){if(l.name!=="TypeError")throw l;for(var e=typeof BlobBuilder<"u"?BlobBuilder:typeof MSBlobBuilder<"u"?MSBlobBuilder:typeof MozBlobBuilder<"u"?MozBlobBuilder:WebKitBlobBuilder,n=new e,a=0;a<o.length;a+=1)n.append(o[a]);return n.getBlob(t.type)}}function dataURLToBlob(o){var t=o.match(/data:([^;]+)/)[1],e=o.replace(/^[^,]+,/,""),n=binaryStringToArrayBuffer(atob(e));return createBlob([n],{type:t})}function canvasToBlob(o,t,e){return typeof o.toBlob=="function"?new Promise(function(n){o.toBlob(n,t,e)}):Promise.resolve(dataURLToBlob(o.toDataURL(t,e)))}function binaryStringToArrayBuffer(o){for(var t=o.length,e=new ArrayBuffer(t),n=new Uint8Array(e),a=-1;++a<t;)n[a]=o.charCodeAt(a);return e}var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getDefaultExportFromCjs(o){return o&&o.__esModule&&Object.prototype.hasOwnProperty.call(o,"default")?o.default:o}function getAugmentedNamespace(o){if(o.__esModule)return o;var t=o.default;if(typeof t=="function"){var e=function n(){if(this instanceof n){var a=[null];a.push.apply(a,arguments);var l=Function.bind.apply(t,a);return new l}return t.apply(this,arguments)};e.prototype=t.prototype}else e={};return Object.defineProperty(e,"__esModule",{value:!0}),Object.keys(o).forEach(function(n){var a=Object.getOwnPropertyDescriptor(o,n);Object.defineProperty(e,n,a.get?a:{enumerable:!0,get:function(){return o[n]}})}),e}(function(o){if(o.TextEncoder&&o.TextDecoder)return!1;function t(n="utf-8"){if(n!=="utf-8")throw new RangeError(`Failed to construct 'TextEncoder': The encoding label provided ('${n}') is invalid.`)}Object.defineProperty(t.prototype,"encoding",{value:"utf-8"}),t.prototype.encode=function(n,a={stream:!1}){if(a.stream)throw new Error("Failed to encode: the 'stream' option is unsupported.");let l=0;const c=n.length;let f=0,g=Math.max(32,c+(c>>1)+7),h=new Uint8Array(g>>3<<3);for(;l<c;){let p=n.charCodeAt(l++);if(p>=55296&&p<=56319){if(l<c){const s=n.charCodeAt(l);(s&64512)===56320&&(++l,p=((p&1023)<<10)+(s&1023)+65536)}if(p>=55296&&p<=56319)continue}if(f+4>h.length){g+=8,g*=1+l/n.length*2,g=g>>3<<3;const s=new Uint8Array(g);s.set(h),h=s}if(p&4294967168)if(!(p&4294965248))h[f++]=p>>6&31|192;else if(!(p&4294901760))h[f++]=p>>12&15|224,h[f++]=p>>6&63|128;else if(!(p&4292870144))h[f++]=p>>18&7|240,h[f++]=p>>12&63|128,h[f++]=p>>6&63|128;else continue;else{h[f++]=p;continue}h[f++]=p&63|128}return h.slice(0,f)};function e(n="utf-8",a={fatal:!1}){if(n!=="utf-8")throw new RangeError(`Failed to construct 'TextDecoder': The encoding label provided ('${n}') is invalid.`);if(a.fatal)throw new Error("Failed to construct 'TextDecoder': the 'fatal' option is unsupported.")}Object.defineProperty(e.prototype,"encoding",{value:"utf-8"}),Object.defineProperty(e.prototype,"fatal",{value:!1}),Object.defineProperty(e.prototype,"ignoreBOM",{value:!1}),e.prototype.decode=function(n,a={stream:!1}){if(a.stream)throw new Error("Failed to decode: the 'stream' option is unsupported.");const l=new Uint8Array(n);let c=0;const f=l.length,g=[];for(;c<f;){const h=l[c++];if(h===0)break;if(!(h&128))g.push(h);else if((h&224)===192){const p=l[c++]&63;g.push((h&31)<<6|p)}else if((h&240)===224){const p=l[c++]&63,s=l[c++]&63;g.push((h&31)<<12|p<<6|s)}else if((h&248)===240){const p=l[c++]&63,s=l[c++]&63,r=l[c++]&63;let u=(h&7)<<18|p<<12|s<<6|r;u>65535&&(u-=65536,g.push(u>>>10&1023|55296),u=56320|u&1023),g.push(u)}}return String.fromCharCode.apply(null,g)},o.TextEncoder=t,o.TextDecoder=e})(typeof window<"u"?window:typeof self<"u"?self:void 0);function decode$5(o,t="utf8"){return new TextDecoder(t).decode(o)}const encoder$1=new TextEncoder;function encode$3(o){return encoder$1.encode(o)}const defaultByteLength$1=1024*8,hostBigEndian=(()=>{const o=new Uint8Array(4),t=new Uint32Array(o.buffer);return!((t[0]=1)&o[0])})(),typedArrays={int8:globalThis.Int8Array,uint8:globalThis.Uint8Array,int16:globalThis.Int16Array,uint16:globalThis.Uint16Array,int32:globalThis.Int32Array,uint32:globalThis.Uint32Array,uint64:globalThis.BigUint64Array,int64:globalThis.BigInt64Array,float32:globalThis.Float32Array,float64:globalThis.Float64Array};let IOBuffer$4=class Be{constructor(t=defaultByteLength$1,e={}){let n=!1;typeof t=="number"?t=new ArrayBuffer(t):(n=!0,this.lastWrittenByte=t.byteLength);const a=e.offset?e.offset>>>0:0,l=t.byteLength-a;let c=a;(ArrayBuffer.isView(t)||t instanceof Be)&&(t.byteLength!==t.buffer.byteLength&&(c=t.byteOffset+a),t=t.buffer),n?this.lastWrittenByte=l:this.lastWrittenByte=0,this.buffer=t,this.length=l,this.byteLength=l,this.byteOffset=c,this.offset=0,this.littleEndian=!0,this._data=new DataView(this.buffer,c,l),this._mark=0,this._marks=[]}available(t=1){return this.offset+t<=this.length}isLittleEndian(){return this.littleEndian}setLittleEndian(){return this.littleEndian=!0,this}isBigEndian(){return!this.littleEndian}setBigEndian(){return this.littleEndian=!1,this}skip(t=1){return this.offset+=t,this}back(t=1){return this.offset-=t,this}seek(t){return this.offset=t,this}mark(){return this._mark=this.offset,this}reset(){return this.offset=this._mark,this}pushMark(){return this._marks.push(this.offset),this}popMark(){const t=this._marks.pop();if(t===void 0)throw new Error("Mark stack empty");return this.seek(t),this}rewind(){return this.offset=0,this}ensureAvailable(t=1){if(!this.available(t)){const n=(this.offset+t)*2,a=new Uint8Array(n);a.set(new Uint8Array(this.buffer)),this.buffer=a.buffer,this.length=this.byteLength=n,this._data=new DataView(this.buffer)}return this}readBoolean(){return this.readUint8()!==0}readInt8(){return this._data.getInt8(this.offset++)}readUint8(){return this._data.getUint8(this.offset++)}readByte(){return this.readUint8()}readBytes(t=1){return this.readArray(t,"uint8")}readArray(t,e){const n=typedArrays[e].BYTES_PER_ELEMENT*t,a=this.byteOffset+this.offset,l=this.buffer.slice(a,a+n);if(this.littleEndian===hostBigEndian&&e!=="uint8"&&e!=="int8"){const f=new Uint8Array(this.buffer.slice(a,a+n));f.reverse();const g=new typedArrays[e](f.buffer);return this.offset+=n,g.reverse(),g}const c=new typedArrays[e](l);return this.offset+=n,c}readInt16(){const t=this._data.getInt16(this.offset,this.littleEndian);return this.offset+=2,t}readUint16(){const t=this._data.getUint16(this.offset,this.littleEndian);return this.offset+=2,t}readInt32(){const t=this._data.getInt32(this.offset,this.littleEndian);return this.offset+=4,t}readUint32(){const t=this._data.getUint32(this.offset,this.littleEndian);return this.offset+=4,t}readFloat32(){const t=this._data.getFloat32(this.offset,this.littleEndian);return this.offset+=4,t}readFloat64(){const t=this._data.getFloat64(this.offset,this.littleEndian);return this.offset+=8,t}readBigInt64(){const t=this._data.getBigInt64(this.offset,this.littleEndian);return this.offset+=8,t}readBigUint64(){const t=this._data.getBigUint64(this.offset,this.littleEndian);return this.offset+=8,t}readChar(){return String.fromCharCode(this.readInt8())}readChars(t=1){let e="";for(let n=0;n<t;n++)e+=this.readChar();return e}readUtf8(t=1){return decode$5(this.readBytes(t))}decodeText(t=1,e="utf-8"){return decode$5(this.readBytes(t),e)}writeBoolean(t){return this.writeUint8(t?255:0),this}writeInt8(t){return this.ensureAvailable(1),this._data.setInt8(this.offset++,t),this._updateLastWrittenByte(),this}writeUint8(t){return this.ensureAvailable(1),this._data.setUint8(this.offset++,t),this._updateLastWrittenByte(),this}writeByte(t){return this.writeUint8(t)}writeBytes(t){this.ensureAvailable(t.length);for(let e=0;e<t.length;e++)this._data.setUint8(this.offset++,t[e]);return this._updateLastWrittenByte(),this}writeInt16(t){return this.ensureAvailable(2),this._data.setInt16(this.offset,t,this.littleEndian),this.offset+=2,this._updateLastWrittenByte(),this}writeUint16(t){return this.ensureAvailable(2),this._data.setUint16(this.offset,t,this.littleEndian),this.offset+=2,this._updateLastWrittenByte(),this}writeInt32(t){return this.ensureAvailable(4),this._data.setInt32(this.offset,t,this.littleEndian),this.offset+=4,this._updateLastWrittenByte(),this}writeUint32(t){return this.ensureAvailable(4),this._data.setUint32(this.offset,t,this.littleEndian),this.offset+=4,this._updateLastWrittenByte(),this}writeFloat32(t){return this.ensureAvailable(4),this._data.setFloat32(this.offset,t,this.littleEndian),this.offset+=4,this._updateLastWrittenByte(),this}writeFloat64(t){return this.ensureAvailable(8),this._data.setFloat64(this.offset,t,this.littleEndian),this.offset+=8,this._updateLastWrittenByte(),this}writeBigInt64(t){return this.ensureAvailable(8),this._data.setBigInt64(this.offset,t,this.littleEndian),this.offset+=8,this._updateLastWrittenByte(),this}writeBigUint64(t){return this.ensureAvailable(8),this._data.setBigUint64(this.offset,t,this.littleEndian),this.offset+=8,this._updateLastWrittenByte(),this}writeChar(t){return this.writeUint8(t.charCodeAt(0))}writeChars(t){for(let e=0;e<t.length;e++)this.writeUint8(t.charCodeAt(e));return this}writeUtf8(t){return this.writeBytes(encode$3(t))}toArray(){return new Uint8Array(this.buffer,this.byteOffset,this.lastWrittenByte)}_updateLastWrittenByte(){this.offset>this.lastWrittenByte&&(this.lastWrittenByte=this.offset)}};var IOBuffer$5=Object.freeze({__proto__:null,IOBuffer:IOBuffer$4}),require$$0$3=getAugmentedNamespace(IOBuffer$5),constants$4={BITMAPV5HEADER:{LogicalColorSpace:{LCS_CALIBRATED_RGB:0,LCS_sRGB:1934772034,LCS_WINDOWS_COLOR_SPACE:1466527264},Compression:{BI_RGB:0,BI_RLE8:1,BI_RLE4:2,BI_BITFIELDS:3,BI_JPEG:4,BI_PNG:5,BI_CMYK:11,BI_CMYKRLE8:12,BI_CMYKRLE4:13},GamutMappingIntent:{LCS_GM_ABS_COLORIMETRIC:8,LCS_GM_BUSINESS:1,LCS_GM_GRAPHICS:2,LCS_GM_IMAGES:4}}};const{IOBuffer:IOBuffer$3}=require$$0$3,constants$3=constants$4,tableLeft=[];for(let o=0;o<=8;o++)tableLeft.push(255<<o);class BMPEncoder extends IOBuffer$3{constructor(t){if(t.bitDepth!==1)throw new Error("Only bitDepth of 1 is supported");if(!t.height||!t.width)throw new Error("ImageData width and height are required");super(t.data),this.width=t.width,this.height=t.height,this.bitDepth=t.bitDepth,this.channels=t.channels,this.components=t.components}encode(){this.encoded=new IOBuffer$3,this.encoded.skip(14),this.writeBitmapV5Header(),this.writeColorTable();const t=this.encoded.offset;return this.writePixelArray(),this.encoded.rewind(),this.writeBitmapFileHeader(t),this.encoded.toArray()}writePixelArray(){let t=this.encoded;const e=Math.floor((this.bitDepth*this.width+31)/32)*4,n=Math.ceil(this.bitDepth*this.width/8),a=e-n,l=this.bitDepth*this.width%8,c=l===0?0:8-l,f=e*this.height;let g,h,p=0,s=0,r=8;t.mark(),h=this.readUint8();for(let u=this.height-1;u>=0;u--){const d=u===0;t.reset(),t.skip(u*e);for(let m=0;m<n;m++){const b=m===n-1;s<=c&&b?(t.writeByte(h<<s),(c===0||c===s)&&!d&&(g=h,h=this.readByte())):s===0?(g=h,h=this.readUint8(),t.writeByte(g)):(g=h,h=this.readUint8(),t.writeByte(g<<s&tableLeft[s]|h>>r)),b&&(p+=l||0,t.skip(a),s=p%8,r=8-s)}}e>n&&(t.reset(),t.skip(f-1),t.writeUint8(0))}writeColorTable(){this.encoded.writeUint32(0).writeUint32(16777215)}writeBitmapFileHeader(t){this.encoded.writeChars("BM").writeInt32(this.encoded.lastWrittenByte).writeUint16(0).writeUint16(0).writeUint32(t)}writeBitmapV5Header(){const e=Math.floor((this.bitDepth*this.width+31)/32)*4*this.height;this.encoded.writeUint32(124).writeInt32(this.width).writeInt32(this.height).writeUint16(1).writeUint16(this.bitDepth).writeUint32(constants$3.BITMAPV5HEADER.Compression.BI_RGB).writeUint32(e).writeInt32(0).writeInt32(0).writeUint32(Math.pow(2,this.bitDepth)).writeUint32(Math.pow(2,this.bitDepth)).writeUint32(4278190080).writeUint32(16711680).writeUint32(65280).writeUint32(255).writeUint32(constants$3.BITMAPV5HEADER.LogicalColorSpace.LCS_sRGB).skip(36).skip(12).writeUint32(constants$3.BITMAPV5HEADER.GamutMappingIntent.LCS_GM_IMAGES).skip(12)}}var BMPEncoder_1=BMPEncoder;const Encoder=BMPEncoder_1;var encode$2=function(t){return new Encoder(t).encode()};/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */const Z_FIXED$1=4,Z_BINARY=0,Z_TEXT=1,Z_UNKNOWN$1=2;function zero$1(o){let t=o.length;for(;--t>=0;)o[t]=0}const STORED_BLOCK=0,STATIC_TREES=1,DYN_TREES=2,MIN_MATCH$1=3,MAX_MATCH$1=258,LENGTH_CODES$1=29,LITERALS$1=256,L_CODES$1=LITERALS$1+1+LENGTH_CODES$1,D_CODES$1=30,BL_CODES$1=19,HEAP_SIZE$1=2*L_CODES$1+1,MAX_BITS$1=15,Buf_size=16,MAX_BL_BITS=7,END_BLOCK=256,REP_3_6=16,REPZ_3_10=17,REPZ_11_138=18,extra_lbits=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),extra_dbits=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),extra_blbits=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),bl_order=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),DIST_CODE_LEN=512,static_ltree=new Array((L_CODES$1+2)*2);zero$1(static_ltree);const static_dtree=new Array(D_CODES$1*2);zero$1(static_dtree);const _dist_code=new Array(DIST_CODE_LEN);zero$1(_dist_code);const _length_code=new Array(MAX_MATCH$1-MIN_MATCH$1+1);zero$1(_length_code);const base_length=new Array(LENGTH_CODES$1);zero$1(base_length);const base_dist=new Array(D_CODES$1);zero$1(base_dist);function StaticTreeDesc(o,t,e,n,a){this.static_tree=o,this.extra_bits=t,this.extra_base=e,this.elems=n,this.max_length=a,this.has_stree=o&&o.length}let static_l_desc,static_d_desc,static_bl_desc;function TreeDesc(o,t){this.dyn_tree=o,this.max_code=0,this.stat_desc=t}const d_code=o=>o<256?_dist_code[o]:_dist_code[256+(o>>>7)],put_short=(o,t)=>{o.pending_buf[o.pending++]=t&255,o.pending_buf[o.pending++]=t>>>8&255},send_bits=(o,t,e)=>{o.bi_valid>Buf_size-e?(o.bi_buf|=t<<o.bi_valid&65535,put_short(o,o.bi_buf),o.bi_buf=t>>Buf_size-o.bi_valid,o.bi_valid+=e-Buf_size):(o.bi_buf|=t<<o.bi_valid&65535,o.bi_valid+=e)},send_code=(o,t,e)=>{send_bits(o,e[t*2],e[t*2+1])},bi_reverse=(o,t)=>{let e=0;do e|=o&1,o>>>=1,e<<=1;while(--t>0);return e>>>1},bi_flush=o=>{o.bi_valid===16?(put_short(o,o.bi_buf),o.bi_buf=0,o.bi_valid=0):o.bi_valid>=8&&(o.pending_buf[o.pending++]=o.bi_buf&255,o.bi_buf>>=8,o.bi_valid-=8)},gen_bitlen=(o,t)=>{const e=t.dyn_tree,n=t.max_code,a=t.stat_desc.static_tree,l=t.stat_desc.has_stree,c=t.stat_desc.extra_bits,f=t.stat_desc.extra_base,g=t.stat_desc.max_length;let h,p,s,r,u,d,m=0;for(r=0;r<=MAX_BITS$1;r++)o.bl_count[r]=0;for(e[o.heap[o.heap_max]*2+1]=0,h=o.heap_max+1;h<HEAP_SIZE$1;h++)p=o.heap[h],r=e[e[p*2+1]*2+1]+1,r>g&&(r=g,m++),e[p*2+1]=r,!(p>n)&&(o.bl_count[r]++,u=0,p>=f&&(u=c[p-f]),d=e[p*2],o.opt_len+=d*(r+u),l&&(o.static_len+=d*(a[p*2+1]+u)));if(m!==0){do{for(r=g-1;o.bl_count[r]===0;)r--;o.bl_count[r]--,o.bl_count[r+1]+=2,o.bl_count[g]--,m-=2}while(m>0);for(r=g;r!==0;r--)for(p=o.bl_count[r];p!==0;)s=o.heap[--h],!(s>n)&&(e[s*2+1]!==r&&(o.opt_len+=(r-e[s*2+1])*e[s*2],e[s*2+1]=r),p--)}},gen_codes=(o,t,e)=>{const n=new Array(MAX_BITS$1+1);let a=0,l,c;for(l=1;l<=MAX_BITS$1;l++)a=a+e[l-1]<<1,n[l]=a;for(c=0;c<=t;c++){let f=o[c*2+1];f!==0&&(o[c*2]=bi_reverse(n[f]++,f))}},tr_static_init=()=>{let o,t,e,n,a;const l=new Array(MAX_BITS$1+1);for(e=0,n=0;n<LENGTH_CODES$1-1;n++)for(base_length[n]=e,o=0;o<1<<extra_lbits[n];o++)_length_code[e++]=n;for(_length_code[e-1]=n,a=0,n=0;n<16;n++)for(base_dist[n]=a,o=0;o<1<<extra_dbits[n];o++)_dist_code[a++]=n;for(a>>=7;n<D_CODES$1;n++)for(base_dist[n]=a<<7,o=0;o<1<<extra_dbits[n]-7;o++)_dist_code[256+a++]=n;for(t=0;t<=MAX_BITS$1;t++)l[t]=0;for(o=0;o<=143;)static_ltree[o*2+1]=8,o++,l[8]++;for(;o<=255;)static_ltree[o*2+1]=9,o++,l[9]++;for(;o<=279;)static_ltree[o*2+1]=7,o++,l[7]++;for(;o<=287;)static_ltree[o*2+1]=8,o++,l[8]++;for(gen_codes(static_ltree,L_CODES$1+1,l),o=0;o<D_CODES$1;o++)static_dtree[o*2+1]=5,static_dtree[o*2]=bi_reverse(o,5);static_l_desc=new StaticTreeDesc(static_ltree,extra_lbits,LITERALS$1+1,L_CODES$1,MAX_BITS$1),static_d_desc=new StaticTreeDesc(static_dtree,extra_dbits,0,D_CODES$1,MAX_BITS$1),static_bl_desc=new StaticTreeDesc(new Array(0),extra_blbits,0,BL_CODES$1,MAX_BL_BITS)},init_block=o=>{let t;for(t=0;t<L_CODES$1;t++)o.dyn_ltree[t*2]=0;for(t=0;t<D_CODES$1;t++)o.dyn_dtree[t*2]=0;for(t=0;t<BL_CODES$1;t++)o.bl_tree[t*2]=0;o.dyn_ltree[END_BLOCK*2]=1,o.opt_len=o.static_len=0,o.sym_next=o.matches=0},bi_windup=o=>{o.bi_valid>8?put_short(o,o.bi_buf):o.bi_valid>0&&(o.pending_buf[o.pending++]=o.bi_buf),o.bi_buf=0,o.bi_valid=0},smaller=(o,t,e,n)=>{const a=t*2,l=e*2;return o[a]<o[l]||o[a]===o[l]&&n[t]<=n[e]},pqdownheap=(o,t,e)=>{const n=o.heap[e];let a=e<<1;for(;a<=o.heap_len&&(a<o.heap_len&&smaller(t,o.heap[a+1],o.heap[a],o.depth)&&a++,!smaller(t,n,o.heap[a],o.depth));)o.heap[e]=o.heap[a],e=a,a<<=1;o.heap[e]=n},compress_block=(o,t,e)=>{let n,a,l=0,c,f;if(o.sym_next!==0)do n=o.pending_buf[o.sym_buf+l++]&255,n+=(o.pending_buf[o.sym_buf+l++]&255)<<8,a=o.pending_buf[o.sym_buf+l++],n===0?send_code(o,a,t):(c=_length_code[a],send_code(o,c+LITERALS$1+1,t),f=extra_lbits[c],f!==0&&(a-=base_length[c],send_bits(o,a,f)),n--,c=d_code(n),send_code(o,c,e),f=extra_dbits[c],f!==0&&(n-=base_dist[c],send_bits(o,n,f)));while(l<o.sym_next);send_code(o,END_BLOCK,t)},build_tree=(o,t)=>{const e=t.dyn_tree,n=t.stat_desc.static_tree,a=t.stat_desc.has_stree,l=t.stat_desc.elems;let c,f,g=-1,h;for(o.heap_len=0,o.heap_max=HEAP_SIZE$1,c=0;c<l;c++)e[c*2]!==0?(o.heap[++o.heap_len]=g=c,o.depth[c]=0):e[c*2+1]=0;for(;o.heap_len<2;)h=o.heap[++o.heap_len]=g<2?++g:0,e[h*2]=1,o.depth[h]=0,o.opt_len--,a&&(o.static_len-=n[h*2+1]);for(t.max_code=g,c=o.heap_len>>1;c>=1;c--)pqdownheap(o,e,c);h=l;do c=o.heap[1],o.heap[1]=o.heap[o.heap_len--],pqdownheap(o,e,1),f=o.heap[1],o.heap[--o.heap_max]=c,o.heap[--o.heap_max]=f,e[h*2]=e[c*2]+e[f*2],o.depth[h]=(o.depth[c]>=o.depth[f]?o.depth[c]:o.depth[f])+1,e[c*2+1]=e[f*2+1]=h,o.heap[1]=h++,pqdownheap(o,e,1);while(o.heap_len>=2);o.heap[--o.heap_max]=o.heap[1],gen_bitlen(o,t),gen_codes(e,g,o.bl_count)},scan_tree=(o,t,e)=>{let n,a=-1,l,c=t[0*2+1],f=0,g=7,h=4;for(c===0&&(g=138,h=3),t[(e+1)*2+1]=65535,n=0;n<=e;n++)l=c,c=t[(n+1)*2+1],!(++f<g&&l===c)&&(f<h?o.bl_tree[l*2]+=f:l!==0?(l!==a&&o.bl_tree[l*2]++,o.bl_tree[REP_3_6*2]++):f<=10?o.bl_tree[REPZ_3_10*2]++:o.bl_tree[REPZ_11_138*2]++,f=0,a=l,c===0?(g=138,h=3):l===c?(g=6,h=3):(g=7,h=4))},send_tree=(o,t,e)=>{let n,a=-1,l,c=t[0*2+1],f=0,g=7,h=4;for(c===0&&(g=138,h=3),n=0;n<=e;n++)if(l=c,c=t[(n+1)*2+1],!(++f<g&&l===c)){if(f<h)do send_code(o,l,o.bl_tree);while(--f!==0);else l!==0?(l!==a&&(send_code(o,l,o.bl_tree),f--),send_code(o,REP_3_6,o.bl_tree),send_bits(o,f-3,2)):f<=10?(send_code(o,REPZ_3_10,o.bl_tree),send_bits(o,f-3,3)):(send_code(o,REPZ_11_138,o.bl_tree),send_bits(o,f-11,7));f=0,a=l,c===0?(g=138,h=3):l===c?(g=6,h=3):(g=7,h=4)}},build_bl_tree=o=>{let t;for(scan_tree(o,o.dyn_ltree,o.l_desc.max_code),scan_tree(o,o.dyn_dtree,o.d_desc.max_code),build_tree(o,o.bl_desc),t=BL_CODES$1-1;t>=3&&o.bl_tree[bl_order[t]*2+1]===0;t--);return o.opt_len+=3*(t+1)+5+5+4,t},send_all_trees=(o,t,e,n)=>{let a;for(send_bits(o,t-257,5),send_bits(o,e-1,5),send_bits(o,n-4,4),a=0;a<n;a++)send_bits(o,o.bl_tree[bl_order[a]*2+1],3);send_tree(o,o.dyn_ltree,t-1),send_tree(o,o.dyn_dtree,e-1)},detect_data_type=o=>{let t=4093624447,e;for(e=0;e<=31;e++,t>>>=1)if(t&1&&o.dyn_ltree[e*2]!==0)return Z_BINARY;if(o.dyn_ltree[9*2]!==0||o.dyn_ltree[10*2]!==0||o.dyn_ltree[13*2]!==0)return Z_TEXT;for(e=32;e<LITERALS$1;e++)if(o.dyn_ltree[e*2]!==0)return Z_TEXT;return Z_BINARY};let static_init_done=!1;const _tr_init$1=o=>{static_init_done||(tr_static_init(),static_init_done=!0),o.l_desc=new TreeDesc(o.dyn_ltree,static_l_desc),o.d_desc=new TreeDesc(o.dyn_dtree,static_d_desc),o.bl_desc=new TreeDesc(o.bl_tree,static_bl_desc),o.bi_buf=0,o.bi_valid=0,init_block(o)},_tr_stored_block$1=(o,t,e,n)=>{send_bits(o,(STORED_BLOCK<<1)+(n?1:0),3),bi_windup(o),put_short(o,e),put_short(o,~e),e&&o.pending_buf.set(o.window.subarray(t,t+e),o.pending),o.pending+=e},_tr_align$1=o=>{send_bits(o,STATIC_TREES<<1,3),send_code(o,END_BLOCK,static_ltree),bi_flush(o)},_tr_flush_block$1=(o,t,e,n)=>{let a,l,c=0;o.level>0?(o.strm.data_type===Z_UNKNOWN$1&&(o.strm.data_type=detect_data_type(o)),build_tree(o,o.l_desc),build_tree(o,o.d_desc),c=build_bl_tree(o),a=o.opt_len+3+7>>>3,l=o.static_len+3+7>>>3,l<=a&&(a=l)):a=l=e+5,e+4<=a&&t!==-1?_tr_stored_block$1(o,t,e,n):o.strategy===Z_FIXED$1||l===a?(send_bits(o,(STATIC_TREES<<1)+(n?1:0),3),compress_block(o,static_ltree,static_dtree)):(send_bits(o,(DYN_TREES<<1)+(n?1:0),3),send_all_trees(o,o.l_desc.max_code+1,o.d_desc.max_code+1,c+1),compress_block(o,o.dyn_ltree,o.dyn_dtree)),init_block(o),n&&bi_windup(o)},_tr_tally$1=(o,t,e)=>(o.pending_buf[o.sym_buf+o.sym_next++]=t,o.pending_buf[o.sym_buf+o.sym_next++]=t>>8,o.pending_buf[o.sym_buf+o.sym_next++]=e,t===0?o.dyn_ltree[e*2]++:(o.matches++,t--,o.dyn_ltree[(_length_code[e]+LITERALS$1+1)*2]++,o.dyn_dtree[d_code(t)*2]++),o.sym_next===o.sym_end);var _tr_init_1=_tr_init$1,_tr_stored_block_1=_tr_stored_block$1,_tr_flush_block_1=_tr_flush_block$1,_tr_tally_1=_tr_tally$1,_tr_align_1=_tr_align$1,trees={_tr_init:_tr_init_1,_tr_stored_block:_tr_stored_block_1,_tr_flush_block:_tr_flush_block_1,_tr_tally:_tr_tally_1,_tr_align:_tr_align_1};const adler32=(o,t,e,n)=>{let a=o&65535|0,l=o>>>16&65535|0,c=0;for(;e!==0;){c=e>2e3?2e3:e,e-=c;do a=a+t[n++]|0,l=l+a|0;while(--c);a%=65521,l%=65521}return a|l<<16|0};var adler32_1=adler32;const makeTable=()=>{let o,t=[];for(var e=0;e<256;e++){o=e;for(var n=0;n<8;n++)o=o&1?3988292384^o>>>1:o>>>1;t[e]=o}return t},crcTable$1=new Uint32Array(makeTable()),crc32=(o,t,e,n)=>{const a=crcTable$1,l=n+e;o^=-1;for(let c=n;c<l;c++)o=o>>>8^a[(o^t[c])&255];return o^-1};var crc32_1=crc32,messages={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},constants$2={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init,_tr_stored_block,_tr_flush_block,_tr_tally,_tr_align}=trees,{Z_NO_FLUSH:Z_NO_FLUSH$2,Z_PARTIAL_FLUSH,Z_FULL_FLUSH:Z_FULL_FLUSH$1,Z_FINISH:Z_FINISH$3,Z_BLOCK:Z_BLOCK$1,Z_OK:Z_OK$3,Z_STREAM_END:Z_STREAM_END$3,Z_STREAM_ERROR:Z_STREAM_ERROR$2,Z_DATA_ERROR:Z_DATA_ERROR$2,Z_BUF_ERROR:Z_BUF_ERROR$1,Z_DEFAULT_COMPRESSION:Z_DEFAULT_COMPRESSION$1,Z_FILTERED,Z_HUFFMAN_ONLY,Z_RLE,Z_FIXED,Z_DEFAULT_STRATEGY:Z_DEFAULT_STRATEGY$1,Z_UNKNOWN,Z_DEFLATED:Z_DEFLATED$2}=constants$2,MAX_MEM_LEVEL=9,MAX_WBITS$1=15,DEF_MEM_LEVEL=8,LENGTH_CODES=29,LITERALS=256,L_CODES=LITERALS+1+LENGTH_CODES,D_CODES=30,BL_CODES=19,HEAP_SIZE=2*L_CODES+1,MAX_BITS=15,MIN_MATCH=3,MAX_MATCH=258,MIN_LOOKAHEAD=MAX_MATCH+MIN_MATCH+1,PRESET_DICT=32,INIT_STATE=42,GZIP_STATE=57,EXTRA_STATE=69,NAME_STATE=73,COMMENT_STATE=91,HCRC_STATE=103,BUSY_STATE=113,FINISH_STATE=666,BS_NEED_MORE=1,BS_BLOCK_DONE=2,BS_FINISH_STARTED=3,BS_FINISH_DONE=4,OS_CODE=3,err=(o,t)=>(o.msg=messages[t],t),rank=o=>o*2-(o>4?9:0),zero=o=>{let t=o.length;for(;--t>=0;)o[t]=0},slide_hash=o=>{let t,e,n,a=o.w_size;t=o.hash_size,n=t;do e=o.head[--n],o.head[n]=e>=a?e-a:0;while(--t);t=a,n=t;do e=o.prev[--n],o.prev[n]=e>=a?e-a:0;while(--t)};let HASH_ZLIB=(o,t,e)=>(t<<o.hash_shift^e)&o.hash_mask,HASH=HASH_ZLIB;const flush_pending=o=>{const t=o.state;let e=t.pending;e>o.avail_out&&(e=o.avail_out),e!==0&&(o.output.set(t.pending_buf.subarray(t.pending_out,t.pending_out+e),o.next_out),o.next_out+=e,t.pending_out+=e,o.total_out+=e,o.avail_out-=e,t.pending-=e,t.pending===0&&(t.pending_out=0))},flush_block_only=(o,t)=>{_tr_flush_block(o,o.block_start>=0?o.block_start:-1,o.strstart-o.block_start,t),o.block_start=o.strstart,flush_pending(o.strm)},put_byte=(o,t)=>{o.pending_buf[o.pending++]=t},putShortMSB=(o,t)=>{o.pending_buf[o.pending++]=t>>>8&255,o.pending_buf[o.pending++]=t&255},read_buf=(o,t,e,n)=>{let a=o.avail_in;return a>n&&(a=n),a===0?0:(o.avail_in-=a,t.set(o.input.subarray(o.next_in,o.next_in+a),e),o.state.wrap===1?o.adler=adler32_1(o.adler,t,a,e):o.state.wrap===2&&(o.adler=crc32_1(o.adler,t,a,e)),o.next_in+=a,o.total_in+=a,a)},longest_match=(o,t)=>{let e=o.max_chain_length,n=o.strstart,a,l,c=o.prev_length,f=o.nice_match;const g=o.strstart>o.w_size-MIN_LOOKAHEAD?o.strstart-(o.w_size-MIN_LOOKAHEAD):0,h=o.window,p=o.w_mask,s=o.prev,r=o.strstart+MAX_MATCH;let u=h[n+c-1],d=h[n+c];o.prev_length>=o.good_match&&(e>>=2),f>o.lookahead&&(f=o.lookahead);do if(a=t,!(h[a+c]!==d||h[a+c-1]!==u||h[a]!==h[n]||h[++a]!==h[n+1])){n+=2,a++;do;while(h[++n]===h[++a]&&h[++n]===h[++a]&&h[++n]===h[++a]&&h[++n]===h[++a]&&h[++n]===h[++a]&&h[++n]===h[++a]&&h[++n]===h[++a]&&h[++n]===h[++a]&&n<r);if(l=MAX_MATCH-(r-n),n=r-MAX_MATCH,l>c){if(o.match_start=t,c=l,l>=f)break;u=h[n+c-1],d=h[n+c]}}while((t=s[t&p])>g&&--e!==0);return c<=o.lookahead?c:o.lookahead},fill_window=o=>{const t=o.w_size;let e,n,a;do{if(n=o.window_size-o.lookahead-o.strstart,o.strstart>=t+(t-MIN_LOOKAHEAD)&&(o.window.set(o.window.subarray(t,t+t-n),0),o.match_start-=t,o.strstart-=t,o.block_start-=t,o.insert>o.strstart&&(o.insert=o.strstart),slide_hash(o),n+=t),o.strm.avail_in===0)break;if(e=read_buf(o.strm,o.window,o.strstart+o.lookahead,n),o.lookahead+=e,o.lookahead+o.insert>=MIN_MATCH)for(a=o.strstart-o.insert,o.ins_h=o.window[a],o.ins_h=HASH(o,o.ins_h,o.window[a+1]);o.insert&&(o.ins_h=HASH(o,o.ins_h,o.window[a+MIN_MATCH-1]),o.prev[a&o.w_mask]=o.head[o.ins_h],o.head[o.ins_h]=a,a++,o.insert--,!(o.lookahead+o.insert<MIN_MATCH)););}while(o.lookahead<MIN_LOOKAHEAD&&o.strm.avail_in!==0)},deflate_stored=(o,t)=>{let e=o.pending_buf_size-5>o.w_size?o.w_size:o.pending_buf_size-5,n,a,l,c=0,f=o.strm.avail_in;do{if(n=65535,l=o.bi_valid+42>>3,o.strm.avail_out<l||(l=o.strm.avail_out-l,a=o.strstart-o.block_start,n>a+o.strm.avail_in&&(n=a+o.strm.avail_in),n>l&&(n=l),n<e&&(n===0&&t!==Z_FINISH$3||t===Z_NO_FLUSH$2||n!==a+o.strm.avail_in)))break;c=t===Z_FINISH$3&&n===a+o.strm.avail_in?1:0,_tr_stored_block(o,0,0,c),o.pending_buf[o.pending-4]=n,o.pending_buf[o.pending-3]=n>>8,o.pending_buf[o.pending-2]=~n,o.pending_buf[o.pending-1]=~n>>8,flush_pending(o.strm),a&&(a>n&&(a=n),o.strm.output.set(o.window.subarray(o.block_start,o.block_start+a),o.strm.next_out),o.strm.next_out+=a,o.strm.avail_out-=a,o.strm.total_out+=a,o.block_start+=a,n-=a),n&&(read_buf(o.strm,o.strm.output,o.strm.next_out,n),o.strm.next_out+=n,o.strm.avail_out-=n,o.strm.total_out+=n)}while(c===0);return f-=o.strm.avail_in,f&&(f>=o.w_size?(o.matches=2,o.window.set(o.strm.input.subarray(o.strm.next_in-o.w_size,o.strm.next_in),0),o.strstart=o.w_size,o.insert=o.strstart):(o.window_size-o.strstart<=f&&(o.strstart-=o.w_size,o.window.set(o.window.subarray(o.w_size,o.w_size+o.strstart),0),o.matches<2&&o.matches++,o.insert>o.strstart&&(o.insert=o.strstart)),o.window.set(o.strm.input.subarray(o.strm.next_in-f,o.strm.next_in),o.strstart),o.strstart+=f,o.insert+=f>o.w_size-o.insert?o.w_size-o.insert:f),o.block_start=o.strstart),o.high_water<o.strstart&&(o.high_water=o.strstart),c?BS_FINISH_DONE:t!==Z_NO_FLUSH$2&&t!==Z_FINISH$3&&o.strm.avail_in===0&&o.strstart===o.block_start?BS_BLOCK_DONE:(l=o.window_size-o.strstart,o.strm.avail_in>l&&o.block_start>=o.w_size&&(o.block_start-=o.w_size,o.strstart-=o.w_size,o.window.set(o.window.subarray(o.w_size,o.w_size+o.strstart),0),o.matches<2&&o.matches++,l+=o.w_size,o.insert>o.strstart&&(o.insert=o.strstart)),l>o.strm.avail_in&&(l=o.strm.avail_in),l&&(read_buf(o.strm,o.window,o.strstart,l),o.strstart+=l,o.insert+=l>o.w_size-o.insert?o.w_size-o.insert:l),o.high_water<o.strstart&&(o.high_water=o.strstart),l=o.bi_valid+42>>3,l=o.pending_buf_size-l>65535?65535:o.pending_buf_size-l,e=l>o.w_size?o.w_size:l,a=o.strstart-o.block_start,(a>=e||(a||t===Z_FINISH$3)&&t!==Z_NO_FLUSH$2&&o.strm.avail_in===0&&a<=l)&&(n=a>l?l:a,c=t===Z_FINISH$3&&o.strm.avail_in===0&&n===a?1:0,_tr_stored_block(o,o.block_start,n,c),o.block_start+=n,flush_pending(o.strm)),c?BS_FINISH_STARTED:BS_NEED_MORE)},deflate_fast=(o,t)=>{let e,n;for(;;){if(o.lookahead<MIN_LOOKAHEAD){if(fill_window(o),o.lookahead<MIN_LOOKAHEAD&&t===Z_NO_FLUSH$2)return BS_NEED_MORE;if(o.lookahead===0)break}if(e=0,o.lookahead>=MIN_MATCH&&(o.ins_h=HASH(o,o.ins_h,o.window[o.strstart+MIN_MATCH-1]),e=o.prev[o.strstart&o.w_mask]=o.head[o.ins_h],o.head[o.ins_h]=o.strstart),e!==0&&o.strstart-e<=o.w_size-MIN_LOOKAHEAD&&(o.match_length=longest_match(o,e)),o.match_length>=MIN_MATCH)if(n=_tr_tally(o,o.strstart-o.match_start,o.match_length-MIN_MATCH),o.lookahead-=o.match_length,o.match_length<=o.max_lazy_match&&o.lookahead>=MIN_MATCH){o.match_length--;do o.strstart++,o.ins_h=HASH(o,o.ins_h,o.window[o.strstart+MIN_MATCH-1]),e=o.prev[o.strstart&o.w_mask]=o.head[o.ins_h],o.head[o.ins_h]=o.strstart;while(--o.match_length!==0);o.strstart++}else o.strstart+=o.match_length,o.match_length=0,o.ins_h=o.window[o.strstart],o.ins_h=HASH(o,o.ins_h,o.window[o.strstart+1]);else n=_tr_tally(o,0,o.window[o.strstart]),o.lookahead--,o.strstart++;if(n&&(flush_block_only(o,!1),o.strm.avail_out===0))return BS_NEED_MORE}return o.insert=o.strstart<MIN_MATCH-1?o.strstart:MIN_MATCH-1,t===Z_FINISH$3?(flush_block_only(o,!0),o.strm.avail_out===0?BS_FINISH_STARTED:BS_FINISH_DONE):o.sym_next&&(flush_block_only(o,!1),o.strm.avail_out===0)?BS_NEED_MORE:BS_BLOCK_DONE},deflate_slow=(o,t)=>{let e,n,a;for(;;){if(o.lookahead<MIN_LOOKAHEAD){if(fill_window(o),o.lookahead<MIN_LOOKAHEAD&&t===Z_NO_FLUSH$2)return BS_NEED_MORE;if(o.lookahead===0)break}if(e=0,o.lookahead>=MIN_MATCH&&(o.ins_h=HASH(o,o.ins_h,o.window[o.strstart+MIN_MATCH-1]),e=o.prev[o.strstart&o.w_mask]=o.head[o.ins_h],o.head[o.ins_h]=o.strstart),o.prev_length=o.match_length,o.prev_match=o.match_start,o.match_length=MIN_MATCH-1,e!==0&&o.prev_length<o.max_lazy_match&&o.strstart-e<=o.w_size-MIN_LOOKAHEAD&&(o.match_length=longest_match(o,e),o.match_length<=5&&(o.strategy===Z_FILTERED||o.match_length===MIN_MATCH&&o.strstart-o.match_start>4096)&&(o.match_length=MIN_MATCH-1)),o.prev_length>=MIN_MATCH&&o.match_length<=o.prev_length){a=o.strstart+o.lookahead-MIN_MATCH,n=_tr_tally(o,o.strstart-1-o.prev_match,o.prev_length-MIN_MATCH),o.lookahead-=o.prev_length-1,o.prev_length-=2;do++o.strstart<=a&&(o.ins_h=HASH(o,o.ins_h,o.window[o.strstart+MIN_MATCH-1]),e=o.prev[o.strstart&o.w_mask]=o.head[o.ins_h],o.head[o.ins_h]=o.strstart);while(--o.prev_length!==0);if(o.match_available=0,o.match_length=MIN_MATCH-1,o.strstart++,n&&(flush_block_only(o,!1),o.strm.avail_out===0))return BS_NEED_MORE}else if(o.match_available){if(n=_tr_tally(o,0,o.window[o.strstart-1]),n&&flush_block_only(o,!1),o.strstart++,o.lookahead--,o.strm.avail_out===0)return BS_NEED_MORE}else o.match_available=1,o.strstart++,o.lookahead--}return o.match_available&&(n=_tr_tally(o,0,o.window[o.strstart-1]),o.match_available=0),o.insert=o.strstart<MIN_MATCH-1?o.strstart:MIN_MATCH-1,t===Z_FINISH$3?(flush_block_only(o,!0),o.strm.avail_out===0?BS_FINISH_STARTED:BS_FINISH_DONE):o.sym_next&&(flush_block_only(o,!1),o.strm.avail_out===0)?BS_NEED_MORE:BS_BLOCK_DONE},deflate_rle=(o,t)=>{let e,n,a,l;const c=o.window;for(;;){if(o.lookahead<=MAX_MATCH){if(fill_window(o),o.lookahead<=MAX_MATCH&&t===Z_NO_FLUSH$2)return BS_NEED_MORE;if(o.lookahead===0)break}if(o.match_length=0,o.lookahead>=MIN_MATCH&&o.strstart>0&&(a=o.strstart-1,n=c[a],n===c[++a]&&n===c[++a]&&n===c[++a])){l=o.strstart+MAX_MATCH;do;while(n===c[++a]&&n===c[++a]&&n===c[++a]&&n===c[++a]&&n===c[++a]&&n===c[++a]&&n===c[++a]&&n===c[++a]&&a<l);o.match_length=MAX_MATCH-(l-a),o.match_length>o.lookahead&&(o.match_length=o.lookahead)}if(o.match_length>=MIN_MATCH?(e=_tr_tally(o,1,o.match_length-MIN_MATCH),o.lookahead-=o.match_length,o.strstart+=o.match_length,o.match_length=0):(e=_tr_tally(o,0,o.window[o.strstart]),o.lookahead--,o.strstart++),e&&(flush_block_only(o,!1),o.strm.avail_out===0))return BS_NEED_MORE}return o.insert=0,t===Z_FINISH$3?(flush_block_only(o,!0),o.strm.avail_out===0?BS_FINISH_STARTED:BS_FINISH_DONE):o.sym_next&&(flush_block_only(o,!1),o.strm.avail_out===0)?BS_NEED_MORE:BS_BLOCK_DONE},deflate_huff=(o,t)=>{let e;for(;;){if(o.lookahead===0&&(fill_window(o),o.lookahead===0)){if(t===Z_NO_FLUSH$2)return BS_NEED_MORE;break}if(o.match_length=0,e=_tr_tally(o,0,o.window[o.strstart]),o.lookahead--,o.strstart++,e&&(flush_block_only(o,!1),o.strm.avail_out===0))return BS_NEED_MORE}return o.insert=0,t===Z_FINISH$3?(flush_block_only(o,!0),o.strm.avail_out===0?BS_FINISH_STARTED:BS_FINISH_DONE):o.sym_next&&(flush_block_only(o,!1),o.strm.avail_out===0)?BS_NEED_MORE:BS_BLOCK_DONE};function Config(o,t,e,n,a){this.good_length=o,this.max_lazy=t,this.nice_length=e,this.max_chain=n,this.func=a}const configuration_table=[new Config(0,0,0,0,deflate_stored),new Config(4,4,8,4,deflate_fast),new Config(4,5,16,8,deflate_fast),new Config(4,6,32,32,deflate_fast),new Config(4,4,16,16,deflate_slow),new Config(8,16,32,32,deflate_slow),new Config(8,16,128,128,deflate_slow),new Config(8,32,128,256,deflate_slow),new Config(32,128,258,1024,deflate_slow),new Config(32,258,258,4096,deflate_slow)],lm_init=o=>{o.window_size=2*o.w_size,zero(o.head),o.max_lazy_match=configuration_table[o.level].max_lazy,o.good_match=configuration_table[o.level].good_length,o.nice_match=configuration_table[o.level].nice_length,o.max_chain_length=configuration_table[o.level].max_chain,o.strstart=0,o.block_start=0,o.lookahead=0,o.insert=0,o.match_length=o.prev_length=MIN_MATCH-1,o.match_available=0,o.ins_h=0};function DeflateState(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Z_DEFLATED$2,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(HEAP_SIZE*2),this.dyn_dtree=new Uint16Array((2*D_CODES+1)*2),this.bl_tree=new Uint16Array((2*BL_CODES+1)*2),zero(this.dyn_ltree),zero(this.dyn_dtree),zero(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(MAX_BITS+1),this.heap=new Uint16Array(2*L_CODES+1),zero(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*L_CODES+1),zero(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const deflateStateCheck=o=>{if(!o)return 1;const t=o.state;return!t||t.strm!==o||t.status!==INIT_STATE&&t.status!==GZIP_STATE&&t.status!==EXTRA_STATE&&t.status!==NAME_STATE&&t.status!==COMMENT_STATE&&t.status!==HCRC_STATE&&t.status!==BUSY_STATE&&t.status!==FINISH_STATE?1:0},deflateResetKeep=o=>{if(deflateStateCheck(o))return err(o,Z_STREAM_ERROR$2);o.total_in=o.total_out=0,o.data_type=Z_UNKNOWN;const t=o.state;return t.pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=t.wrap===2?GZIP_STATE:t.wrap?INIT_STATE:BUSY_STATE,o.adler=t.wrap===2?0:1,t.last_flush=-2,_tr_init(t),Z_OK$3},deflateReset=o=>{const t=deflateResetKeep(o);return t===Z_OK$3&&lm_init(o.state),t},deflateSetHeader=(o,t)=>deflateStateCheck(o)||o.state.wrap!==2?Z_STREAM_ERROR$2:(o.state.gzhead=t,Z_OK$3),deflateInit2=(o,t,e,n,a,l)=>{if(!o)return Z_STREAM_ERROR$2;let c=1;if(t===Z_DEFAULT_COMPRESSION$1&&(t=6),n<0?(c=0,n=-n):n>15&&(c=2,n-=16),a<1||a>MAX_MEM_LEVEL||e!==Z_DEFLATED$2||n<8||n>15||t<0||t>9||l<0||l>Z_FIXED||n===8&&c!==1)return err(o,Z_STREAM_ERROR$2);n===8&&(n=9);const f=new DeflateState;return o.state=f,f.strm=o,f.status=INIT_STATE,f.wrap=c,f.gzhead=null,f.w_bits=n,f.w_size=1<<f.w_bits,f.w_mask=f.w_size-1,f.hash_bits=a+7,f.hash_size=1<<f.hash_bits,f.hash_mask=f.hash_size-1,f.hash_shift=~~((f.hash_bits+MIN_MATCH-1)/MIN_MATCH),f.window=new Uint8Array(f.w_size*2),f.head=new Uint16Array(f.hash_size),f.prev=new Uint16Array(f.w_size),f.lit_bufsize=1<<a+6,f.pending_buf_size=f.lit_bufsize*4,f.pending_buf=new Uint8Array(f.pending_buf_size),f.sym_buf=f.lit_bufsize,f.sym_end=(f.lit_bufsize-1)*3,f.level=t,f.strategy=l,f.method=e,deflateReset(o)},deflateInit=(o,t)=>deflateInit2(o,t,Z_DEFLATED$2,MAX_WBITS$1,DEF_MEM_LEVEL,Z_DEFAULT_STRATEGY$1),deflate$2=(o,t)=>{if(deflateStateCheck(o)||t>Z_BLOCK$1||t<0)return o?err(o,Z_STREAM_ERROR$2):Z_STREAM_ERROR$2;const e=o.state;if(!o.output||o.avail_in!==0&&!o.input||e.status===FINISH_STATE&&t!==Z_FINISH$3)return err(o,o.avail_out===0?Z_BUF_ERROR$1:Z_STREAM_ERROR$2);const n=e.last_flush;if(e.last_flush=t,e.pending!==0){if(flush_pending(o),o.avail_out===0)return e.last_flush=-1,Z_OK$3}else if(o.avail_in===0&&rank(t)<=rank(n)&&t!==Z_FINISH$3)return err(o,Z_BUF_ERROR$1);if(e.status===FINISH_STATE&&o.avail_in!==0)return err(o,Z_BUF_ERROR$1);if(e.status===INIT_STATE&&e.wrap===0&&(e.status=BUSY_STATE),e.status===INIT_STATE){let a=Z_DEFLATED$2+(e.w_bits-8<<4)<<8,l=-1;if(e.strategy>=Z_HUFFMAN_ONLY||e.level<2?l=0:e.level<6?l=1:e.level===6?l=2:l=3,a|=l<<6,e.strstart!==0&&(a|=PRESET_DICT),a+=31-a%31,putShortMSB(e,a),e.strstart!==0&&(putShortMSB(e,o.adler>>>16),putShortMSB(e,o.adler&65535)),o.adler=1,e.status=BUSY_STATE,flush_pending(o),e.pending!==0)return e.last_flush=-1,Z_OK$3}if(e.status===GZIP_STATE){if(o.adler=0,put_byte(e,31),put_byte(e,139),put_byte(e,8),e.gzhead)put_byte(e,(e.gzhead.text?1:0)+(e.gzhead.hcrc?2:0)+(e.gzhead.extra?4:0)+(e.gzhead.name?8:0)+(e.gzhead.comment?16:0)),put_byte(e,e.gzhead.time&255),put_byte(e,e.gzhead.time>>8&255),put_byte(e,e.gzhead.time>>16&255),put_byte(e,e.gzhead.time>>24&255),put_byte(e,e.level===9?2:e.strategy>=Z_HUFFMAN_ONLY||e.level<2?4:0),put_byte(e,e.gzhead.os&255),e.gzhead.extra&&e.gzhead.extra.length&&(put_byte(e,e.gzhead.extra.length&255),put_byte(e,e.gzhead.extra.length>>8&255)),e.gzhead.hcrc&&(o.adler=crc32_1(o.adler,e.pending_buf,e.pending,0)),e.gzindex=0,e.status=EXTRA_STATE;else if(put_byte(e,0),put_byte(e,0),put_byte(e,0),put_byte(e,0),put_byte(e,0),put_byte(e,e.level===9?2:e.strategy>=Z_HUFFMAN_ONLY||e.level<2?4:0),put_byte(e,OS_CODE),e.status=BUSY_STATE,flush_pending(o),e.pending!==0)return e.last_flush=-1,Z_OK$3}if(e.status===EXTRA_STATE){if(e.gzhead.extra){let a=e.pending,l=(e.gzhead.extra.length&65535)-e.gzindex;for(;e.pending+l>e.pending_buf_size;){let f=e.pending_buf_size-e.pending;if(e.pending_buf.set(e.gzhead.extra.subarray(e.gzindex,e.gzindex+f),e.pending),e.pending=e.pending_buf_size,e.gzhead.hcrc&&e.pending>a&&(o.adler=crc32_1(o.adler,e.pending_buf,e.pending-a,a)),e.gzindex+=f,flush_pending(o),e.pending!==0)return e.last_flush=-1,Z_OK$3;a=0,l-=f}let c=new Uint8Array(e.gzhead.extra);e.pending_buf.set(c.subarray(e.gzindex,e.gzindex+l),e.pending),e.pending+=l,e.gzhead.hcrc&&e.pending>a&&(o.adler=crc32_1(o.adler,e.pending_buf,e.pending-a,a)),e.gzindex=0}e.status=NAME_STATE}if(e.status===NAME_STATE){if(e.gzhead.name){let a=e.pending,l;do{if(e.pending===e.pending_buf_size){if(e.gzhead.hcrc&&e.pending>a&&(o.adler=crc32_1(o.adler,e.pending_buf,e.pending-a,a)),flush_pending(o),e.pending!==0)return e.last_flush=-1,Z_OK$3;a=0}e.gzindex<e.gzhead.name.length?l=e.gzhead.name.charCodeAt(e.gzindex++)&255:l=0,put_byte(e,l)}while(l!==0);e.gzhead.hcrc&&e.pending>a&&(o.adler=crc32_1(o.adler,e.pending_buf,e.pending-a,a)),e.gzindex=0}e.status=COMMENT_STATE}if(e.status===COMMENT_STATE){if(e.gzhead.comment){let a=e.pending,l;do{if(e.pending===e.pending_buf_size){if(e.gzhead.hcrc&&e.pending>a&&(o.adler=crc32_1(o.adler,e.pending_buf,e.pending-a,a)),flush_pending(o),e.pending!==0)return e.last_flush=-1,Z_OK$3;a=0}e.gzindex<e.gzhead.comment.length?l=e.gzhead.comment.charCodeAt(e.gzindex++)&255:l=0,put_byte(e,l)}while(l!==0);e.gzhead.hcrc&&e.pending>a&&(o.adler=crc32_1(o.adler,e.pending_buf,e.pending-a,a))}e.status=HCRC_STATE}if(e.status===HCRC_STATE){if(e.gzhead.hcrc){if(e.pending+2>e.pending_buf_size&&(flush_pending(o),e.pending!==0))return e.last_flush=-1,Z_OK$3;put_byte(e,o.adler&255),put_byte(e,o.adler>>8&255),o.adler=0}if(e.status=BUSY_STATE,flush_pending(o),e.pending!==0)return e.last_flush=-1,Z_OK$3}if(o.avail_in!==0||e.lookahead!==0||t!==Z_NO_FLUSH$2&&e.status!==FINISH_STATE){let a=e.level===0?deflate_stored(e,t):e.strategy===Z_HUFFMAN_ONLY?deflate_huff(e,t):e.strategy===Z_RLE?deflate_rle(e,t):configuration_table[e.level].func(e,t);if((a===BS_FINISH_STARTED||a===BS_FINISH_DONE)&&(e.status=FINISH_STATE),a===BS_NEED_MORE||a===BS_FINISH_STARTED)return o.avail_out===0&&(e.last_flush=-1),Z_OK$3;if(a===BS_BLOCK_DONE&&(t===Z_PARTIAL_FLUSH?_tr_align(e):t!==Z_BLOCK$1&&(_tr_stored_block(e,0,0,!1),t===Z_FULL_FLUSH$1&&(zero(e.head),e.lookahead===0&&(e.strstart=0,e.block_start=0,e.insert=0))),flush_pending(o),o.avail_out===0))return e.last_flush=-1,Z_OK$3}return t!==Z_FINISH$3?Z_OK$3:e.wrap<=0?Z_STREAM_END$3:(e.wrap===2?(put_byte(e,o.adler&255),put_byte(e,o.adler>>8&255),put_byte(e,o.adler>>16&255),put_byte(e,o.adler>>24&255),put_byte(e,o.total_in&255),put_byte(e,o.total_in>>8&255),put_byte(e,o.total_in>>16&255),put_byte(e,o.total_in>>24&255)):(putShortMSB(e,o.adler>>>16),putShortMSB(e,o.adler&65535)),flush_pending(o),e.wrap>0&&(e.wrap=-e.wrap),e.pending!==0?Z_OK$3:Z_STREAM_END$3)},deflateEnd=o=>{if(deflateStateCheck(o))return Z_STREAM_ERROR$2;const t=o.state.status;return o.state=null,t===BUSY_STATE?err(o,Z_DATA_ERROR$2):Z_OK$3},deflateSetDictionary=(o,t)=>{let e=t.length;if(deflateStateCheck(o))return Z_STREAM_ERROR$2;const n=o.state,a=n.wrap;if(a===2||a===1&&n.status!==INIT_STATE||n.lookahead)return Z_STREAM_ERROR$2;if(a===1&&(o.adler=adler32_1(o.adler,t,e,0)),n.wrap=0,e>=n.w_size){a===0&&(zero(n.head),n.strstart=0,n.block_start=0,n.insert=0);let g=new Uint8Array(n.w_size);g.set(t.subarray(e-n.w_size,e),0),t=g,e=n.w_size}const l=o.avail_in,c=o.next_in,f=o.input;for(o.avail_in=e,o.next_in=0,o.input=t,fill_window(n);n.lookahead>=MIN_MATCH;){let g=n.strstart,h=n.lookahead-(MIN_MATCH-1);do n.ins_h=HASH(n,n.ins_h,n.window[g+MIN_MATCH-1]),n.prev[g&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=g,g++;while(--h);n.strstart=g,n.lookahead=MIN_MATCH-1,fill_window(n)}return n.strstart+=n.lookahead,n.block_start=n.strstart,n.insert=n.lookahead,n.lookahead=0,n.match_length=n.prev_length=MIN_MATCH-1,n.match_available=0,o.next_in=c,o.input=f,o.avail_in=l,n.wrap=a,Z_OK$3};var deflateInit_1=deflateInit,deflateInit2_1=deflateInit2,deflateReset_1=deflateReset,deflateResetKeep_1=deflateResetKeep,deflateSetHeader_1=deflateSetHeader,deflate_2$1=deflate$2,deflateEnd_1=deflateEnd,deflateSetDictionary_1=deflateSetDictionary,deflateInfo="pako deflate (from Nodeca project)",deflate_1$2={deflateInit:deflateInit_1,deflateInit2:deflateInit2_1,deflateReset:deflateReset_1,deflateResetKeep:deflateResetKeep_1,deflateSetHeader:deflateSetHeader_1,deflate:deflate_2$1,deflateEnd:deflateEnd_1,deflateSetDictionary:deflateSetDictionary_1,deflateInfo};const _has=(o,t)=>Object.prototype.hasOwnProperty.call(o,t);var assign=function(o){const t=Array.prototype.slice.call(arguments,1);for(;t.length;){const e=t.shift();if(e){if(typeof e!="object")throw new TypeError(e+"must be non-object");for(const n in e)_has(e,n)&&(o[n]=e[n])}}return o},flattenChunks=o=>{let t=0;for(let n=0,a=o.length;n<a;n++)t+=o[n].length;const e=new Uint8Array(t);for(let n=0,a=0,l=o.length;n<l;n++){let c=o[n];e.set(c,a),a+=c.length}return e},common={assign,flattenChunks};let STR_APPLY_UIA_OK=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(o){STR_APPLY_UIA_OK=!1}const _utf8len=new Uint8Array(256);for(let o=0;o<256;o++)_utf8len[o]=o>=252?6:o>=248?5:o>=240?4:o>=224?3:o>=192?2:1;_utf8len[254]=_utf8len[254]=1;var string2buf=o=>{if(typeof TextEncoder=="function"&&TextEncoder.prototype.encode)return new TextEncoder().encode(o);let t,e,n,a,l,c=o.length,f=0;for(a=0;a<c;a++)e=o.charCodeAt(a),(e&64512)===55296&&a+1<c&&(n=o.charCodeAt(a+1),(n&64512)===56320&&(e=65536+(e-55296<<10)+(n-56320),a++)),f+=e<128?1:e<2048?2:e<65536?3:4;for(t=new Uint8Array(f),l=0,a=0;l<f;a++)e=o.charCodeAt(a),(e&64512)===55296&&a+1<c&&(n=o.charCodeAt(a+1),(n&64512)===56320&&(e=65536+(e-55296<<10)+(n-56320),a++)),e<128?t[l++]=e:e<2048?(t[l++]=192|e>>>6,t[l++]=128|e&63):e<65536?(t[l++]=224|e>>>12,t[l++]=128|e>>>6&63,t[l++]=128|e&63):(t[l++]=240|e>>>18,t[l++]=128|e>>>12&63,t[l++]=128|e>>>6&63,t[l++]=128|e&63);return t};const buf2binstring=(o,t)=>{if(t<65534&&o.subarray&&STR_APPLY_UIA_OK)return String.fromCharCode.apply(null,o.length===t?o:o.subarray(0,t));let e="";for(let n=0;n<t;n++)e+=String.fromCharCode(o[n]);return e};var buf2string=(o,t)=>{const e=t||o.length;if(typeof TextDecoder=="function"&&TextDecoder.prototype.decode)return new TextDecoder().decode(o.subarray(0,t));let n,a;const l=new Array(e*2);for(a=0,n=0;n<e;){let c=o[n++];if(c<128){l[a++]=c;continue}let f=_utf8len[c];if(f>4){l[a++]=65533,n+=f-1;continue}for(c&=f===2?31:f===3?15:7;f>1&&n<e;)c=c<<6|o[n++]&63,f--;if(f>1){l[a++]=65533;continue}c<65536?l[a++]=c:(c-=65536,l[a++]=55296|c>>10&1023,l[a++]=56320|c&1023)}return buf2binstring(l,a)},utf8border=(o,t)=>{t=t||o.length,t>o.length&&(t=o.length);let e=t-1;for(;e>=0&&(o[e]&192)===128;)e--;return e<0||e===0?t:e+_utf8len[o[e]]>t?e:t},strings={string2buf,buf2string,utf8border};function ZStream(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}var zstream=ZStream;const toString$1$1=Object.prototype.toString,{Z_NO_FLUSH:Z_NO_FLUSH$1,Z_SYNC_FLUSH,Z_FULL_FLUSH,Z_FINISH:Z_FINISH$2,Z_OK:Z_OK$2,Z_STREAM_END:Z_STREAM_END$2,Z_DEFAULT_COMPRESSION,Z_DEFAULT_STRATEGY,Z_DEFLATED:Z_DEFLATED$1}=constants$2;function Deflate$1(o){this.options=common.assign({level:Z_DEFAULT_COMPRESSION,method:Z_DEFLATED$1,chunkSize:16384,windowBits:15,memLevel:8,strategy:Z_DEFAULT_STRATEGY},o||{});let t=this.options;t.raw&&t.windowBits>0?t.windowBits=-t.windowBits:t.gzip&&t.windowBits>0&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new zstream,this.strm.avail_out=0;let e=deflate_1$2.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(e!==Z_OK$2)throw new Error(messages[e]);if(t.header&&deflate_1$2.deflateSetHeader(this.strm,t.header),t.dictionary){let n;if(typeof t.dictionary=="string"?n=strings.string2buf(t.dictionary):toString$1$1.call(t.dictionary)==="[object ArrayBuffer]"?n=new Uint8Array(t.dictionary):n=t.dictionary,e=deflate_1$2.deflateSetDictionary(this.strm,n),e!==Z_OK$2)throw new Error(messages[e]);this._dict_set=!0}}Deflate$1.prototype.push=function(o,t){const e=this.strm,n=this.options.chunkSize;let a,l;if(this.ended)return!1;for(t===~~t?l=t:l=t===!0?Z_FINISH$2:Z_NO_FLUSH$1,typeof o=="string"?e.input=strings.string2buf(o):toString$1$1.call(o)==="[object ArrayBuffer]"?e.input=new Uint8Array(o):e.input=o,e.next_in=0,e.avail_in=e.input.length;;){if(e.avail_out===0&&(e.output=new Uint8Array(n),e.next_out=0,e.avail_out=n),(l===Z_SYNC_FLUSH||l===Z_FULL_FLUSH)&&e.avail_out<=6){this.onData(e.output.subarray(0,e.next_out)),e.avail_out=0;continue}if(a=deflate_1$2.deflate(e,l),a===Z_STREAM_END$2)return e.next_out>0&&this.onData(e.output.subarray(0,e.next_out)),a=deflate_1$2.deflateEnd(this.strm),this.onEnd(a),this.ended=!0,a===Z_OK$2;if(e.avail_out===0){this.onData(e.output);continue}if(l>0&&e.next_out>0){this.onData(e.output.subarray(0,e.next_out)),e.avail_out=0;continue}if(e.avail_in===0)break}return!0},Deflate$1.prototype.onData=function(o){this.chunks.push(o)},Deflate$1.prototype.onEnd=function(o){o===Z_OK$2&&(this.result=common.flattenChunks(this.chunks)),this.chunks=[],this.err=o,this.msg=this.strm.msg};function deflate$1(o,t){const e=new Deflate$1(t);if(e.push(o,!0),e.err)throw e.msg||messages[e.err];return e.result}function deflateRaw$1(o,t){return t=t||{},t.raw=!0,deflate$1(o,t)}function gzip$1(o,t){return t=t||{},t.gzip=!0,deflate$1(o,t)}var Deflate_1$1=Deflate$1,deflate_2=deflate$1,deflateRaw_1$1=deflateRaw$1,gzip_1$1=gzip$1,constants$1=constants$2,deflate_1$1={Deflate:Deflate_1$1,deflate:deflate_2,deflateRaw:deflateRaw_1$1,gzip:gzip_1$1,constants:constants$1};const BAD$1=16209,TYPE$1=16191;var inffast=function(t,e){let n,a,l,c,f,g,h,p,s,r,u,d,m,b,y,w,x,_,v,E,I,S,T,A;const O=t.state;n=t.next_in,T=t.input,a=n+(t.avail_in-5),l=t.next_out,A=t.output,c=l-(e-t.avail_out),f=l+(t.avail_out-257),g=O.dmax,h=O.wsize,p=O.whave,s=O.wnext,r=O.window,u=O.hold,d=O.bits,m=O.lencode,b=O.distcode,y=(1<<O.lenbits)-1,w=(1<<O.distbits)-1;t:do{d<15&&(u+=T[n++]<<d,d+=8,u+=T[n++]<<d,d+=8),x=m[u&y];e:for(;;){if(_=x>>>24,u>>>=_,d-=_,_=x>>>16&255,_===0)A[l++]=x&65535;else if(_&16){v=x&65535,_&=15,_&&(d<_&&(u+=T[n++]<<d,d+=8),v+=u&(1<<_)-1,u>>>=_,d-=_),d<15&&(u+=T[n++]<<d,d+=8,u+=T[n++]<<d,d+=8),x=b[u&w];n:for(;;){if(_=x>>>24,u>>>=_,d-=_,_=x>>>16&255,_&16){if(E=x&65535,_&=15,d<_&&(u+=T[n++]<<d,d+=8,d<_&&(u+=T[n++]<<d,d+=8)),E+=u&(1<<_)-1,E>g){t.msg="invalid distance too far back",O.mode=BAD$1;break t}if(u>>>=_,d-=_,_=l-c,E>_){if(_=E-_,_>p&&O.sane){t.msg="invalid distance too far back",O.mode=BAD$1;break t}if(I=0,S=r,s===0){if(I+=h-_,_<v){v-=_;do A[l++]=r[I++];while(--_);I=l-E,S=A}}else if(s<_){if(I+=h+s-_,_-=s,_<v){v-=_;do A[l++]=r[I++];while(--_);if(I=0,s<v){_=s,v-=_;do A[l++]=r[I++];while(--_);I=l-E,S=A}}}else if(I+=s-_,_<v){v-=_;do A[l++]=r[I++];while(--_);I=l-E,S=A}for(;v>2;)A[l++]=S[I++],A[l++]=S[I++],A[l++]=S[I++],v-=3;v&&(A[l++]=S[I++],v>1&&(A[l++]=S[I++]))}else{I=l-E;do A[l++]=A[I++],A[l++]=A[I++],A[l++]=A[I++],v-=3;while(v>2);v&&(A[l++]=A[I++],v>1&&(A[l++]=A[I++]))}}else if(_&64){t.msg="invalid distance code",O.mode=BAD$1;break t}else{x=b[(x&65535)+(u&(1<<_)-1)];continue n}break}}else if(_&64)if(_&32){O.mode=TYPE$1;break t}else{t.msg="invalid literal/length code",O.mode=BAD$1;break t}else{x=m[(x&65535)+(u&(1<<_)-1)];continue e}break}}while(n<a&&l<f);v=d>>3,n-=v,d-=v<<3,u&=(1<<d)-1,t.next_in=n,t.next_out=l,t.avail_in=n<a?5+(a-n):5-(n-a),t.avail_out=l<f?257+(f-l):257-(l-f),O.hold=u,O.bits=d};const MAXBITS=15,ENOUGH_LENS$1=852,ENOUGH_DISTS$1=592,CODES$1=0,LENS$1=1,DISTS$1=2,lbase=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),lext=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),dbase=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),dext=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),inflate_table=(o,t,e,n,a,l,c,f)=>{const g=f.bits;let h=0,p=0,s=0,r=0,u=0,d=0,m=0,b=0,y=0,w=0,x,_,v,E,I,S=null,T;const A=new Uint16Array(MAXBITS+1),O=new Uint16Array(MAXBITS+1);let $=null,D,M,F;for(h=0;h<=MAXBITS;h++)A[h]=0;for(p=0;p<n;p++)A[t[e+p]]++;for(u=g,r=MAXBITS;r>=1&&A[r]===0;r--);if(u>r&&(u=r),r===0)return a[l++]=1<<24|64<<16|0,a[l++]=1<<24|64<<16|0,f.bits=1,0;for(s=1;s<r&&A[s]===0;s++);for(u<s&&(u=s),b=1,h=1;h<=MAXBITS;h++)if(b<<=1,b-=A[h],b<0)return-1;if(b>0&&(o===CODES$1||r!==1))return-1;for(O[1]=0,h=1;h<MAXBITS;h++)O[h+1]=O[h]+A[h];for(p=0;p<n;p++)t[e+p]!==0&&(c[O[t[e+p]]++]=p);if(o===CODES$1?(S=$=c,T=20):o===LENS$1?(S=lbase,$=lext,T=257):(S=dbase,$=dext,T=0),w=0,p=0,h=s,I=l,d=u,m=0,v=-1,y=1<<u,E=y-1,o===LENS$1&&y>ENOUGH_LENS$1||o===DISTS$1&&y>ENOUGH_DISTS$1)return 1;for(;;){D=h-m,c[p]+1<T?(M=0,F=c[p]):c[p]>=T?(M=$[c[p]-T],F=S[c[p]-T]):(M=32+64,F=0),x=1<<h-m,_=1<<d,s=_;do _-=x,a[I+(w>>m)+_]=D<<24|M<<16|F|0;while(_!==0);for(x=1<<h-1;w&x;)x>>=1;if(x!==0?(w&=x-1,w+=x):w=0,p++,--A[h]===0){if(h===r)break;h=t[e+c[p]]}if(h>u&&(w&E)!==v){for(m===0&&(m=u),I+=s,d=h-m,b=1<<d;d+m<r&&(b-=A[d+m],!(b<=0));)d++,b<<=1;if(y+=1<<d,o===LENS$1&&y>ENOUGH_LENS$1||o===DISTS$1&&y>ENOUGH_DISTS$1)return 1;v=w&E,a[v]=u<<24|d<<16|I-l|0}}return w!==0&&(a[I+w]=h-m<<24|64<<16|0),f.bits=u,0};var inftrees=inflate_table;const CODES=0,LENS=1,DISTS=2,{Z_FINISH:Z_FINISH$1,Z_BLOCK,Z_TREES,Z_OK:Z_OK$1,Z_STREAM_END:Z_STREAM_END$1,Z_NEED_DICT:Z_NEED_DICT$1,Z_STREAM_ERROR:Z_STREAM_ERROR$1,Z_DATA_ERROR:Z_DATA_ERROR$1,Z_MEM_ERROR:Z_MEM_ERROR$1,Z_BUF_ERROR,Z_DEFLATED}=constants$2,HEAD=16180,FLAGS=16181,TIME=16182,OS=16183,EXLEN=16184,EXTRA=16185,NAME=16186,COMMENT=16187,HCRC=16188,DICTID=16189,DICT=16190,TYPE=16191,TYPEDO=16192,STORED=16193,COPY_=16194,COPY=16195,TABLE=16196,LENLENS=16197,CODELENS=16198,LEN_=16199,LEN=16200,LENEXT=16201,DIST=16202,DISTEXT=16203,MATCH=16204,LIT=16205,CHECK=16206,LENGTH=16207,DONE=16208,BAD=16209,MEM=16210,SYNC=16211,ENOUGH_LENS=852,ENOUGH_DISTS=592,MAX_WBITS=15,DEF_WBITS=MAX_WBITS,zswap32=o=>(o>>>24&255)+(o>>>8&65280)+((o&65280)<<8)+((o&255)<<24);function InflateState(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const inflateStateCheck=o=>{if(!o)return 1;const t=o.state;return!t||t.strm!==o||t.mode<HEAD||t.mode>SYNC?1:0},inflateResetKeep=o=>{if(inflateStateCheck(o))return Z_STREAM_ERROR$1;const t=o.state;return o.total_in=o.total_out=t.total=0,o.msg="",t.wrap&&(o.adler=t.wrap&1),t.mode=HEAD,t.last=0,t.havedict=0,t.flags=-1,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new Int32Array(ENOUGH_LENS),t.distcode=t.distdyn=new Int32Array(ENOUGH_DISTS),t.sane=1,t.back=-1,Z_OK$1},inflateReset=o=>{if(inflateStateCheck(o))return Z_STREAM_ERROR$1;const t=o.state;return t.wsize=0,t.whave=0,t.wnext=0,inflateResetKeep(o)},inflateReset2=(o,t)=>{let e;if(inflateStateCheck(o))return Z_STREAM_ERROR$1;const n=o.state;return t<0?(e=0,t=-t):(e=(t>>4)+5,t<48&&(t&=15)),t&&(t<8||t>15)?Z_STREAM_ERROR$1:(n.window!==null&&n.wbits!==t&&(n.window=null),n.wrap=e,n.wbits=t,inflateReset(o))},inflateInit2=(o,t)=>{if(!o)return Z_STREAM_ERROR$1;const e=new InflateState;o.state=e,e.strm=o,e.window=null,e.mode=HEAD;const n=inflateReset2(o,t);return n!==Z_OK$1&&(o.state=null),n},inflateInit=o=>inflateInit2(o,DEF_WBITS);let virgin=!0,lenfix,distfix;const fixedtables=o=>{if(virgin){lenfix=new Int32Array(512),distfix=new Int32Array(32);let t=0;for(;t<144;)o.lens[t++]=8;for(;t<256;)o.lens[t++]=9;for(;t<280;)o.lens[t++]=7;for(;t<288;)o.lens[t++]=8;for(inftrees(LENS,o.lens,0,288,lenfix,0,o.work,{bits:9}),t=0;t<32;)o.lens[t++]=5;inftrees(DISTS,o.lens,0,32,distfix,0,o.work,{bits:5}),virgin=!1}o.lencode=lenfix,o.lenbits=9,o.distcode=distfix,o.distbits=5},updatewindow=(o,t,e,n)=>{let a;const l=o.state;return l.window===null&&(l.wsize=1<<l.wbits,l.wnext=0,l.whave=0,l.window=new Uint8Array(l.wsize)),n>=l.wsize?(l.window.set(t.subarray(e-l.wsize,e),0),l.wnext=0,l.whave=l.wsize):(a=l.wsize-l.wnext,a>n&&(a=n),l.window.set(t.subarray(e-n,e-n+a),l.wnext),n-=a,n?(l.window.set(t.subarray(e-n,e),0),l.wnext=n,l.whave=l.wsize):(l.wnext+=a,l.wnext===l.wsize&&(l.wnext=0),l.whave<l.wsize&&(l.whave+=a))),0},inflate$2=(o,t)=>{let e,n,a,l,c,f,g,h,p,s,r,u,d,m,b=0,y,w,x,_,v,E,I,S;const T=new Uint8Array(4);let A,O;const $=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(inflateStateCheck(o)||!o.output||!o.input&&o.avail_in!==0)return Z_STREAM_ERROR$1;e=o.state,e.mode===TYPE&&(e.mode=TYPEDO),c=o.next_out,a=o.output,g=o.avail_out,l=o.next_in,n=o.input,f=o.avail_in,h=e.hold,p=e.bits,s=f,r=g,S=Z_OK$1;t:for(;;)switch(e.mode){case HEAD:if(e.wrap===0){e.mode=TYPEDO;break}for(;p<16;){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}if(e.wrap&2&&h===35615){e.wbits===0&&(e.wbits=15),e.check=0,T[0]=h&255,T[1]=h>>>8&255,e.check=crc32_1(e.check,T,2,0),h=0,p=0,e.mode=FLAGS;break}if(e.head&&(e.head.done=!1),!(e.wrap&1)||(((h&255)<<8)+(h>>8))%31){o.msg="incorrect header check",e.mode=BAD;break}if((h&15)!==Z_DEFLATED){o.msg="unknown compression method",e.mode=BAD;break}if(h>>>=4,p-=4,I=(h&15)+8,e.wbits===0&&(e.wbits=I),I>15||I>e.wbits){o.msg="invalid window size",e.mode=BAD;break}e.dmax=1<<e.wbits,e.flags=0,o.adler=e.check=1,e.mode=h&512?DICTID:TYPE,h=0,p=0;break;case FLAGS:for(;p<16;){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}if(e.flags=h,(e.flags&255)!==Z_DEFLATED){o.msg="unknown compression method",e.mode=BAD;break}if(e.flags&57344){o.msg="unknown header flags set",e.mode=BAD;break}e.head&&(e.head.text=h>>8&1),e.flags&512&&e.wrap&4&&(T[0]=h&255,T[1]=h>>>8&255,e.check=crc32_1(e.check,T,2,0)),h=0,p=0,e.mode=TIME;case TIME:for(;p<32;){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}e.head&&(e.head.time=h),e.flags&512&&e.wrap&4&&(T[0]=h&255,T[1]=h>>>8&255,T[2]=h>>>16&255,T[3]=h>>>24&255,e.check=crc32_1(e.check,T,4,0)),h=0,p=0,e.mode=OS;case OS:for(;p<16;){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}e.head&&(e.head.xflags=h&255,e.head.os=h>>8),e.flags&512&&e.wrap&4&&(T[0]=h&255,T[1]=h>>>8&255,e.check=crc32_1(e.check,T,2,0)),h=0,p=0,e.mode=EXLEN;case EXLEN:if(e.flags&1024){for(;p<16;){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}e.length=h,e.head&&(e.head.extra_len=h),e.flags&512&&e.wrap&4&&(T[0]=h&255,T[1]=h>>>8&255,e.check=crc32_1(e.check,T,2,0)),h=0,p=0}else e.head&&(e.head.extra=null);e.mode=EXTRA;case EXTRA:if(e.flags&1024&&(u=e.length,u>f&&(u=f),u&&(e.head&&(I=e.head.extra_len-e.length,e.head.extra||(e.head.extra=new Uint8Array(e.head.extra_len)),e.head.extra.set(n.subarray(l,l+u),I)),e.flags&512&&e.wrap&4&&(e.check=crc32_1(e.check,n,u,l)),f-=u,l+=u,e.length-=u),e.length))break t;e.length=0,e.mode=NAME;case NAME:if(e.flags&2048){if(f===0)break t;u=0;do I=n[l+u++],e.head&&I&&e.length<65536&&(e.head.name+=String.fromCharCode(I));while(I&&u<f);if(e.flags&512&&e.wrap&4&&(e.check=crc32_1(e.check,n,u,l)),f-=u,l+=u,I)break t}else e.head&&(e.head.name=null);e.length=0,e.mode=COMMENT;case COMMENT:if(e.flags&4096){if(f===0)break t;u=0;do I=n[l+u++],e.head&&I&&e.length<65536&&(e.head.comment+=String.fromCharCode(I));while(I&&u<f);if(e.flags&512&&e.wrap&4&&(e.check=crc32_1(e.check,n,u,l)),f-=u,l+=u,I)break t}else e.head&&(e.head.comment=null);e.mode=HCRC;case HCRC:if(e.flags&512){for(;p<16;){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}if(e.wrap&4&&h!==(e.check&65535)){o.msg="header crc mismatch",e.mode=BAD;break}h=0,p=0}e.head&&(e.head.hcrc=e.flags>>9&1,e.head.done=!0),o.adler=e.check=0,e.mode=TYPE;break;case DICTID:for(;p<32;){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}o.adler=e.check=zswap32(h),h=0,p=0,e.mode=DICT;case DICT:if(e.havedict===0)return o.next_out=c,o.avail_out=g,o.next_in=l,o.avail_in=f,e.hold=h,e.bits=p,Z_NEED_DICT$1;o.adler=e.check=1,e.mode=TYPE;case TYPE:if(t===Z_BLOCK||t===Z_TREES)break t;case TYPEDO:if(e.last){h>>>=p&7,p-=p&7,e.mode=CHECK;break}for(;p<3;){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}switch(e.last=h&1,h>>>=1,p-=1,h&3){case 0:e.mode=STORED;break;case 1:if(fixedtables(e),e.mode=LEN_,t===Z_TREES){h>>>=2,p-=2;break t}break;case 2:e.mode=TABLE;break;case 3:o.msg="invalid block type",e.mode=BAD}h>>>=2,p-=2;break;case STORED:for(h>>>=p&7,p-=p&7;p<32;){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}if((h&65535)!==(h>>>16^65535)){o.msg="invalid stored block lengths",e.mode=BAD;break}if(e.length=h&65535,h=0,p=0,e.mode=COPY_,t===Z_TREES)break t;case COPY_:e.mode=COPY;case COPY:if(u=e.length,u){if(u>f&&(u=f),u>g&&(u=g),u===0)break t;a.set(n.subarray(l,l+u),c),f-=u,l+=u,g-=u,c+=u,e.length-=u;break}e.mode=TYPE;break;case TABLE:for(;p<14;){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}if(e.nlen=(h&31)+257,h>>>=5,p-=5,e.ndist=(h&31)+1,h>>>=5,p-=5,e.ncode=(h&15)+4,h>>>=4,p-=4,e.nlen>286||e.ndist>30){o.msg="too many length or distance symbols",e.mode=BAD;break}e.have=0,e.mode=LENLENS;case LENLENS:for(;e.have<e.ncode;){for(;p<3;){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}e.lens[$[e.have++]]=h&7,h>>>=3,p-=3}for(;e.have<19;)e.lens[$[e.have++]]=0;if(e.lencode=e.lendyn,e.lenbits=7,A={bits:e.lenbits},S=inftrees(CODES,e.lens,0,19,e.lencode,0,e.work,A),e.lenbits=A.bits,S){o.msg="invalid code lengths set",e.mode=BAD;break}e.have=0,e.mode=CODELENS;case CODELENS:for(;e.have<e.nlen+e.ndist;){for(;b=e.lencode[h&(1<<e.lenbits)-1],y=b>>>24,w=b>>>16&255,x=b&65535,!(y<=p);){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}if(x<16)h>>>=y,p-=y,e.lens[e.have++]=x;else{if(x===16){for(O=y+2;p<O;){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}if(h>>>=y,p-=y,e.have===0){o.msg="invalid bit length repeat",e.mode=BAD;break}I=e.lens[e.have-1],u=3+(h&3),h>>>=2,p-=2}else if(x===17){for(O=y+3;p<O;){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}h>>>=y,p-=y,I=0,u=3+(h&7),h>>>=3,p-=3}else{for(O=y+7;p<O;){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}h>>>=y,p-=y,I=0,u=11+(h&127),h>>>=7,p-=7}if(e.have+u>e.nlen+e.ndist){o.msg="invalid bit length repeat",e.mode=BAD;break}for(;u--;)e.lens[e.have++]=I}}if(e.mode===BAD)break;if(e.lens[256]===0){o.msg="invalid code -- missing end-of-block",e.mode=BAD;break}if(e.lenbits=9,A={bits:e.lenbits},S=inftrees(LENS,e.lens,0,e.nlen,e.lencode,0,e.work,A),e.lenbits=A.bits,S){o.msg="invalid literal/lengths set",e.mode=BAD;break}if(e.distbits=6,e.distcode=e.distdyn,A={bits:e.distbits},S=inftrees(DISTS,e.lens,e.nlen,e.ndist,e.distcode,0,e.work,A),e.distbits=A.bits,S){o.msg="invalid distances set",e.mode=BAD;break}if(e.mode=LEN_,t===Z_TREES)break t;case LEN_:e.mode=LEN;case LEN:if(f>=6&&g>=258){o.next_out=c,o.avail_out=g,o.next_in=l,o.avail_in=f,e.hold=h,e.bits=p,inffast(o,r),c=o.next_out,a=o.output,g=o.avail_out,l=o.next_in,n=o.input,f=o.avail_in,h=e.hold,p=e.bits,e.mode===TYPE&&(e.back=-1);break}for(e.back=0;b=e.lencode[h&(1<<e.lenbits)-1],y=b>>>24,w=b>>>16&255,x=b&65535,!(y<=p);){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}if(w&&!(w&240)){for(_=y,v=w,E=x;b=e.lencode[E+((h&(1<<_+v)-1)>>_)],y=b>>>24,w=b>>>16&255,x=b&65535,!(_+y<=p);){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}h>>>=_,p-=_,e.back+=_}if(h>>>=y,p-=y,e.back+=y,e.length=x,w===0){e.mode=LIT;break}if(w&32){e.back=-1,e.mode=TYPE;break}if(w&64){o.msg="invalid literal/length code",e.mode=BAD;break}e.extra=w&15,e.mode=LENEXT;case LENEXT:if(e.extra){for(O=e.extra;p<O;){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}e.length+=h&(1<<e.extra)-1,h>>>=e.extra,p-=e.extra,e.back+=e.extra}e.was=e.length,e.mode=DIST;case DIST:for(;b=e.distcode[h&(1<<e.distbits)-1],y=b>>>24,w=b>>>16&255,x=b&65535,!(y<=p);){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}if(!(w&240)){for(_=y,v=w,E=x;b=e.distcode[E+((h&(1<<_+v)-1)>>_)],y=b>>>24,w=b>>>16&255,x=b&65535,!(_+y<=p);){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}h>>>=_,p-=_,e.back+=_}if(h>>>=y,p-=y,e.back+=y,w&64){o.msg="invalid distance code",e.mode=BAD;break}e.offset=x,e.extra=w&15,e.mode=DISTEXT;case DISTEXT:if(e.extra){for(O=e.extra;p<O;){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}e.offset+=h&(1<<e.extra)-1,h>>>=e.extra,p-=e.extra,e.back+=e.extra}if(e.offset>e.dmax){o.msg="invalid distance too far back",e.mode=BAD;break}e.mode=MATCH;case MATCH:if(g===0)break t;if(u=r-g,e.offset>u){if(u=e.offset-u,u>e.whave&&e.sane){o.msg="invalid distance too far back",e.mode=BAD;break}u>e.wnext?(u-=e.wnext,d=e.wsize-u):d=e.wnext-u,u>e.length&&(u=e.length),m=e.window}else m=a,d=c-e.offset,u=e.length;u>g&&(u=g),g-=u,e.length-=u;do a[c++]=m[d++];while(--u);e.length===0&&(e.mode=LEN);break;case LIT:if(g===0)break t;a[c++]=e.length,g--,e.mode=LEN;break;case CHECK:if(e.wrap){for(;p<32;){if(f===0)break t;f--,h|=n[l++]<<p,p+=8}if(r-=g,o.total_out+=r,e.total+=r,e.wrap&4&&r&&(o.adler=e.check=e.flags?crc32_1(e.check,a,r,c-r):adler32_1(e.check,a,r,c-r)),r=g,e.wrap&4&&(e.flags?h:zswap32(h))!==e.check){o.msg="incorrect data check",e.mode=BAD;break}h=0,p=0}e.mode=LENGTH;case LENGTH:if(e.wrap&&e.flags){for(;p<32;){if(f===0)break t;f--,h+=n[l++]<<p,p+=8}if(e.wrap&4&&h!==(e.total&4294967295)){o.msg="incorrect length check",e.mode=BAD;break}h=0,p=0}e.mode=DONE;case DONE:S=Z_STREAM_END$1;break t;case BAD:S=Z_DATA_ERROR$1;break t;case MEM:return Z_MEM_ERROR$1;case SYNC:default:return Z_STREAM_ERROR$1}return o.next_out=c,o.avail_out=g,o.next_in=l,o.avail_in=f,e.hold=h,e.bits=p,(e.wsize||r!==o.avail_out&&e.mode<BAD&&(e.mode<CHECK||t!==Z_FINISH$1))&&updatewindow(o,o.output,o.next_out,r-o.avail_out),s-=o.avail_in,r-=o.avail_out,o.total_in+=s,o.total_out+=r,e.total+=r,e.wrap&4&&r&&(o.adler=e.check=e.flags?crc32_1(e.check,a,r,o.next_out-r):adler32_1(e.check,a,r,o.next_out-r)),o.data_type=e.bits+(e.last?64:0)+(e.mode===TYPE?128:0)+(e.mode===LEN_||e.mode===COPY_?256:0),(s===0&&r===0||t===Z_FINISH$1)&&S===Z_OK$1&&(S=Z_BUF_ERROR),S},inflateEnd=o=>{if(inflateStateCheck(o))return Z_STREAM_ERROR$1;let t=o.state;return t.window&&(t.window=null),o.state=null,Z_OK$1},inflateGetHeader=(o,t)=>{if(inflateStateCheck(o))return Z_STREAM_ERROR$1;const e=o.state;return e.wrap&2?(e.head=t,t.done=!1,Z_OK$1):Z_STREAM_ERROR$1},inflateSetDictionary=(o,t)=>{const e=t.length;let n,a,l;return inflateStateCheck(o)||(n=o.state,n.wrap!==0&&n.mode!==DICT)?Z_STREAM_ERROR$1:n.mode===DICT&&(a=1,a=adler32_1(a,t,e,0),a!==n.check)?Z_DATA_ERROR$1:(l=updatewindow(o,t,e,e),l?(n.mode=MEM,Z_MEM_ERROR$1):(n.havedict=1,Z_OK$1))};var inflateReset_1=inflateReset,inflateReset2_1=inflateReset2,inflateResetKeep_1=inflateResetKeep,inflateInit_1=inflateInit,inflateInit2_1=inflateInit2,inflate_2$1=inflate$2,inflateEnd_1=inflateEnd,inflateGetHeader_1=inflateGetHeader,inflateSetDictionary_1=inflateSetDictionary,inflateInfo="pako inflate (from Nodeca project)",inflate_1$2={inflateReset:inflateReset_1,inflateReset2:inflateReset2_1,inflateResetKeep:inflateResetKeep_1,inflateInit:inflateInit_1,inflateInit2:inflateInit2_1,inflate:inflate_2$1,inflateEnd:inflateEnd_1,inflateGetHeader:inflateGetHeader_1,inflateSetDictionary:inflateSetDictionary_1,inflateInfo};function GZheader(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}var gzheader=GZheader;const toString$2=Object.prototype.toString,{Z_NO_FLUSH,Z_FINISH,Z_OK,Z_STREAM_END,Z_NEED_DICT,Z_STREAM_ERROR,Z_DATA_ERROR,Z_MEM_ERROR}=constants$2;function Inflate$1(o){this.options=common.assign({chunkSize:1024*64,windowBits:15,to:""},o||{});const t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t.windowBits,t.windowBits===0&&(t.windowBits=-15)),t.windowBits>=0&&t.windowBits<16&&!(o&&o.windowBits)&&(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&(t.windowBits&15||(t.windowBits|=15)),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new zstream,this.strm.avail_out=0;let e=inflate_1$2.inflateInit2(this.strm,t.windowBits);if(e!==Z_OK)throw new Error(messages[e]);if(this.header=new gzheader,inflate_1$2.inflateGetHeader(this.strm,this.header),t.dictionary&&(typeof t.dictionary=="string"?t.dictionary=strings.string2buf(t.dictionary):toString$2.call(t.dictionary)==="[object ArrayBuffer]"&&(t.dictionary=new Uint8Array(t.dictionary)),t.raw&&(e=inflate_1$2.inflateSetDictionary(this.strm,t.dictionary),e!==Z_OK)))throw new Error(messages[e])}Inflate$1.prototype.push=function(o,t){const e=this.strm,n=this.options.chunkSize,a=this.options.dictionary;let l,c,f;if(this.ended)return!1;for(t===~~t?c=t:c=t===!0?Z_FINISH:Z_NO_FLUSH,toString$2.call(o)==="[object ArrayBuffer]"?e.input=new Uint8Array(o):e.input=o,e.next_in=0,e.avail_in=e.input.length;;){for(e.avail_out===0&&(e.output=new Uint8Array(n),e.next_out=0,e.avail_out=n),l=inflate_1$2.inflate(e,c),l===Z_NEED_DICT&&a&&(l=inflate_1$2.inflateSetDictionary(e,a),l===Z_OK?l=inflate_1$2.inflate(e,c):l===Z_DATA_ERROR&&(l=Z_NEED_DICT));e.avail_in>0&&l===Z_STREAM_END&&e.state.wrap>0&&o[e.next_in]!==0;)inflate_1$2.inflateReset(e),l=inflate_1$2.inflate(e,c);switch(l){case Z_STREAM_ERROR:case Z_DATA_ERROR:case Z_NEED_DICT:case Z_MEM_ERROR:return this.onEnd(l),this.ended=!0,!1}if(f=e.avail_out,e.next_out&&(e.avail_out===0||l===Z_STREAM_END))if(this.options.to==="string"){let g=strings.utf8border(e.output,e.next_out),h=e.next_out-g,p=strings.buf2string(e.output,g);e.next_out=h,e.avail_out=n-h,h&&e.output.set(e.output.subarray(g,g+h),0),this.onData(p)}else this.onData(e.output.length===e.next_out?e.output:e.output.subarray(0,e.next_out));if(!(l===Z_OK&&f===0)){if(l===Z_STREAM_END)return l=inflate_1$2.inflateEnd(this.strm),this.onEnd(l),this.ended=!0,!0;if(e.avail_in===0)break}}return!0},Inflate$1.prototype.onData=function(o){this.chunks.push(o)},Inflate$1.prototype.onEnd=function(o){o===Z_OK&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=common.flattenChunks(this.chunks)),this.chunks=[],this.err=o,this.msg=this.strm.msg};function inflate$1(o,t){const e=new Inflate$1(t);if(e.push(o),e.err)throw e.msg||messages[e.err];return e.result}function inflateRaw$1(o,t){return t=t||{},t.raw=!0,inflate$1(o,t)}var Inflate_1$1=Inflate$1,inflate_2=inflate$1,inflateRaw_1$1=inflateRaw$1,ungzip$1=inflate$1,constants=constants$2,inflate_1$1={Inflate:Inflate_1$1,inflate:inflate_2,inflateRaw:inflateRaw_1$1,ungzip:ungzip$1,constants};const{Deflate,deflate,deflateRaw,gzip}=deflate_1$1,{Inflate,inflate,inflateRaw,ungzip}=inflate_1$1;var deflate_1=deflate,Inflate_1=Inflate,inflate_1=inflate;const pngSignature=[137,80,78,71,13,10,26,10],crcTable=[];for(let o=0;o<256;o++){let t=o;for(let e=0;e<8;e++)t&1?t=3988292384^t>>>1:t=t>>>1;crcTable[o]=t}const initialCrc=4294967295;function updateCrc(o,t,e){let n=o;for(let a=0;a<e;a++)n=crcTable[(n^t[a])&255]^n>>>8;return n}function crc(o,t){return(updateCrc(initialCrc,o,t)^initialCrc)>>>0}var ColorType;(function(o){o[o.UNKNOWN=-1]="UNKNOWN",o[o.GREYSCALE=0]="GREYSCALE",o[o.TRUECOLOUR=2]="TRUECOLOUR",o[o.INDEXED_COLOUR=3]="INDEXED_COLOUR",o[o.GREYSCALE_ALPHA=4]="GREYSCALE_ALPHA",o[o.TRUECOLOUR_ALPHA=6]="TRUECOLOUR_ALPHA"})(ColorType||(ColorType={}));var CompressionMethod;(function(o){o[o.UNKNOWN=-1]="UNKNOWN",o[o.DEFLATE=0]="DEFLATE"})(CompressionMethod||(CompressionMethod={}));var FilterMethod;(function(o){o[o.UNKNOWN=-1]="UNKNOWN",o[o.ADAPTIVE=0]="ADAPTIVE"})(FilterMethod||(FilterMethod={}));var InterlaceMethod;(function(o){o[o.UNKNOWN=-1]="UNKNOWN",o[o.NO_INTERLACE=0]="NO_INTERLACE",o[o.ADAM7=1]="ADAM7"})(InterlaceMethod||(InterlaceMethod={}));const empty=new Uint8Array(0),NULL="\0",uint16=new Uint16Array([255]),uint8=new Uint8Array(uint16.buffer),osIsLittleEndian=uint8[0]===255;class PngDecoder extends IOBuffer$4{constructor(t,e={}){super(t);const{checkCrc:n=!1}=e;this._checkCrc=n,this._inflator=new Inflate_1,this._png={width:-1,height:-1,channels:-1,data:new Uint8Array(0),depth:1,text:{}},this._end=!1,this._hasPalette=!1,this._palette=[],this._compressionMethod=CompressionMethod.UNKNOWN,this._filterMethod=FilterMethod.UNKNOWN,this._interlaceMethod=InterlaceMethod.UNKNOWN,this._colorType=-1,this.setBigEndian()}decode(){for(this.decodeSignature();!this._end;)this.decodeChunk();return this.decodeImage(),this._png}decodeSignature(){for(let t=0;t<pngSignature.length;t++)if(this.readUint8()!==pngSignature[t])throw new Error(`wrong PNG signature. Byte at ${t} should be ${pngSignature[t]}.`)}decodeChunk(){const t=this.readUint32(),e=this.readChars(4),n=this.offset;switch(e){case"IHDR":this.decodeIHDR();break;case"PLTE":this.decodePLTE(t);break;case"IDAT":this.decodeIDAT(t);break;case"IEND":this._end=!0;break;case"tRNS":this.decodetRNS(t);break;case"iCCP":this.decodeiCCP(t);break;case"tEXt":this.decodetEXt(t);break;case"pHYs":this.decodepHYs();break;default:this.skip(t);break}if(this.offset-n!==t)throw new Error(`Length mismatch while decoding chunk ${e}`);if(this._checkCrc){const a=this.readUint32(),l=t+4,c=crc(new Uint8Array(this.buffer,this.byteOffset+this.offset-l-4,l),l);if(c!==a)throw new Error(`CRC mismatch for chunk ${e}. Expected ${a}, found ${c}`)}else this.skip(4)}decodeIHDR(){const t=this._png;t.width=this.readUint32(),t.height=this.readUint32(),t.depth=checkBitDepth(this.readUint8());const e=this.readUint8();this._colorType=e;let n;switch(e){case ColorType.GREYSCALE:n=1;break;case ColorType.TRUECOLOUR:n=3;break;case ColorType.INDEXED_COLOUR:n=1;break;case ColorType.GREYSCALE_ALPHA:n=2;break;case ColorType.TRUECOLOUR_ALPHA:n=4;break;default:throw new Error(`Unknown color type: ${e}`)}if(this._png.channels=n,this._compressionMethod=this.readUint8(),this._compressionMethod!==CompressionMethod.DEFLATE)throw new Error(`Unsupported compression method: ${this._compressionMethod}`);this._filterMethod=this.readUint8(),this._interlaceMethod=this.readUint8()}decodePLTE(t){if(t%3!==0)throw new RangeError(`PLTE field length must be a multiple of 3. Got ${t}`);const e=t/3;this._hasPalette=!0;const n=[];this._palette=n;for(let a=0;a<e;a++)n.push([this.readUint8(),this.readUint8(),this.readUint8()])}decodeIDAT(t){this._inflator.push(new Uint8Array(this.buffer,this.offset+this.byteOffset,t)),this.skip(t)}decodetRNS(t){if(this._colorType===3){if(t>this._palette.length)throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${t} vs ${this._palette.length})`);let e=0;for(;e<t;e++){const n=this.readByte();this._palette[e].push(n)}for(;e<this._palette.length;e++)this._palette[e].push(255)}}decodeiCCP(t){let e="",n;for(;(n=this.readChar())!==NULL;)e+=n;const a=this.readUint8();if(a!==CompressionMethod.DEFLATE)throw new Error(`Unsupported iCCP compression method: ${a}`);const l=this.readBytes(t-e.length-2);this._png.iccEmbeddedProfile={name:e,profile:inflate_1(l)}}decodetEXt(t){let e="",n;for(;(n=this.readChar())!==NULL;)e+=n;this._png.text[e]=this.readChars(t-e.length-1)}decodepHYs(){const t=this.readUint32(),e=this.readUint32(),n=this.readByte();this._png.resolution={x:t,y:e,unit:n}}decodeImage(){if(this._inflator.err)throw new Error(`Error while decompressing the data: ${this._inflator.err}`);const t=this._inflator.result;if(this._filterMethod!==FilterMethod.ADAPTIVE)throw new Error(`Filter method ${this._filterMethod} not supported`);if(this._interlaceMethod===InterlaceMethod.NO_INTERLACE)this.decodeInterlaceNull(t);else throw new Error(`Interlace method ${this._interlaceMethod} not supported`)}decodeInterlaceNull(t){const e=this._png.height,n=this._png.channels*this._png.depth/8,a=this._png.width*n,l=new Uint8Array(this._png.height*a);let c=empty,f=0,g,h;for(let p=0;p<e;p++){switch(g=t.subarray(f+1,f+1+a),h=l.subarray(p*a,(p+1)*a),t[f]){case 0:unfilterNone(g,h,a);break;case 1:unfilterSub(g,h,a,n);break;case 2:unfilterUp(g,h,c,a);break;case 3:unfilterAverage(g,h,c,a,n);break;case 4:unfilterPaeth(g,h,c,a,n);break;default:throw new Error(`Unsupported filter: ${t[f]}`)}c=h,f+=a+1}if(this._hasPalette&&(this._png.palette=this._palette),this._png.depth===16){const p=new Uint16Array(l.buffer);if(osIsLittleEndian)for(let s=0;s<p.length;s++)p[s]=swap16(p[s]);this._png.data=p}else this._png.data=l}}function unfilterNone(o,t,e){for(let n=0;n<e;n++)t[n]=o[n]}function unfilterSub(o,t,e,n){let a=0;for(;a<n;a++)t[a]=o[a];for(;a<e;a++)t[a]=o[a]+t[a-n]&255}function unfilterUp(o,t,e,n){let a=0;if(e.length===0)for(;a<n;a++)t[a]=o[a];else for(;a<n;a++)t[a]=o[a]+e[a]&255}function unfilterAverage(o,t,e,n,a){let l=0;if(e.length===0){for(;l<a;l++)t[l]=o[l];for(;l<n;l++)t[l]=o[l]+(t[l-a]>>1)&255}else{for(;l<a;l++)t[l]=o[l]+(e[l]>>1)&255;for(;l<n;l++)t[l]=o[l]+(t[l-a]+e[l]>>1)&255}}function unfilterPaeth(o,t,e,n,a){let l=0;if(e.length===0){for(;l<a;l++)t[l]=o[l];for(;l<n;l++)t[l]=o[l]+t[l-a]&255}else{for(;l<a;l++)t[l]=o[l]+e[l]&255;for(;l<n;l++)t[l]=o[l]+paethPredictor(t[l-a],e[l],e[l-a])&255}}function paethPredictor(o,t,e){const n=o+t-e,a=Math.abs(n-o),l=Math.abs(n-t),c=Math.abs(n-e);return a<=l&&a<=c?o:l<=c?t:e}function swap16(o){return(o&255)<<8|o>>8&255}function checkBitDepth(o){if(o!==1&&o!==2&&o!==4&&o!==8&&o!==16)throw new Error(`invalid bit depth: ${o}`);return o}const defaultZlibOptions={level:3};class PngEncoder extends IOBuffer$4{constructor(t,e={}){super(),this._colorType=ColorType.UNKNOWN,this._zlibOptions=Object.assign({},defaultZlibOptions,e.zlib),this._png=this._checkData(t),this.setBigEndian()}encode(){return this.encodeSignature(),this.encodeIHDR(),this.encodeData(),this.encodeIEND(),this.toArray()}encodeSignature(){this.writeBytes(pngSignature)}encodeIHDR(){this.writeUint32(13),this.writeChars("IHDR"),this.writeUint32(this._png.width),this.writeUint32(this._png.height),this.writeByte(this._png.depth),this.writeByte(this._colorType),this.writeByte(CompressionMethod.DEFLATE),this.writeByte(FilterMethod.ADAPTIVE),this.writeByte(InterlaceMethod.NO_INTERLACE),this.writeCrc(17)}encodeIEND(){this.writeUint32(0),this.writeChars("IEND"),this.writeCrc(4)}encodeIDAT(t){this.writeUint32(t.length),this.writeChars("IDAT"),this.writeBytes(t),this.writeCrc(t.length+4)}encodeData(){const{width:t,height:e,channels:n,depth:a,data:l}=this._png,c=n*t,f=new IOBuffer$4().setBigEndian();let g=0;for(let s=0;s<e;s++)if(f.writeByte(0),a===8)g=writeDataBytes(l,f,c,g);else if(a===16)g=writeDataUint16(l,f,c,g);else throw new Error("unreachable");const h=f.toArray(),p=deflate_1(h,this._zlibOptions);this.encodeIDAT(p)}_checkData(t){const{colorType:e,channels:n,depth:a}=getColorType(t),l={width:checkInteger(t.width,"width"),height:checkInteger(t.height,"height"),channels:n,data:t.data,depth:a,text:{}};this._colorType=e;const c=l.width*l.height*n;if(l.data.length!==c)throw new RangeError(`wrong data size. Found ${l.data.length}, expected ${c}`);return l}writeCrc(t){this.writeUint32(crc(new Uint8Array(this.buffer,this.byteOffset+this.offset-t,t),t))}}function checkInteger(o,t){if(Number.isInteger(o)&&o>0)return o;throw new TypeError(`${t} must be a positive integer`)}function getColorType(o){const{channels:t=4,depth:e=8}=o;if(t!==4&&t!==3&&t!==2&&t!==1)throw new RangeError(`unsupported number of channels: ${t}`);if(e!==8&&e!==16)throw new RangeError(`unsupported bit depth: ${e}`);const n={channels:t,depth:e,colorType:ColorType.UNKNOWN};switch(t){case 4:n.colorType=ColorType.TRUECOLOUR_ALPHA;break;case 3:n.colorType=ColorType.TRUECOLOUR;break;case 1:n.colorType=ColorType.GREYSCALE;break;case 2:n.colorType=ColorType.GREYSCALE_ALPHA;break;default:throw new Error("unsupported number of channels")}return n}function writeDataBytes(o,t,e,n){for(let a=0;a<e;a++)t.writeByte(o[n++]);return n}function writeDataUint16(o,t,e,n){for(let a=0;a<e;a++)t.writeUint16(o[n++]);return n}var ResolutionUnitSpecifier;(function(o){o[o.UNKNOWN=0]="UNKNOWN",o[o.METRE=1]="METRE"})(ResolutionUnitSpecifier||(ResolutionUnitSpecifier={}));function decodePng(o,t){return new PngDecoder(o,t).decode()}function encodePng$1(o,t){return new PngEncoder(o,t).encode()}var encoder={exports:{}};(function(o){function t(n){var a=Math.floor,l=new Array(64),c=new Array(64),f=new Array(64),g=new Array(64),h,p,s,r,u=new Array(65535),d=new Array(65535),m=new Array(64),b=new Array(64),y=[],w=0,x=7,_=new Array(64),v=new Array(64),E=new Array(64),I=new Array(256),S=new Array(2048),T,A=[0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,24,31,40,44,53,10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63],O=[0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0],$=[0,1,2,3,4,5,6,7,8,9,10,11],D=[0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,125],M=[1,2,3,0,4,17,5,18,33,49,65,6,19,81,97,7,34,113,20,50,129,145,161,8,35,66,177,193,21,82,209,240,36,51,98,114,130,9,10,22,23,24,25,26,37,38,39,40,41,42,52,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,225,226,227,228,229,230,231,232,233,234,241,242,243,244,245,246,247,248,249,250],F=[0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0],C=[0,1,2,3,4,5,6,7,8,9,10,11],R=[0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,119],j=[0,1,2,3,17,4,5,33,49,6,18,65,81,7,97,113,19,34,50,129,8,20,66,145,161,177,193,9,35,51,82,240,21,98,114,209,10,22,36,52,225,37,241,23,24,25,26,38,39,40,41,42,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,130,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,226,227,228,229,230,231,232,233,234,242,243,244,245,246,247,248,249,250];function G(H){for(var ft=[16,11,10,16,24,40,51,61,12,12,14,19,26,58,60,55,14,13,16,24,40,57,69,56,14,17,22,29,51,87,80,62,18,22,37,56,68,109,103,77,24,35,55,64,81,104,113,92,49,64,78,87,103,121,120,101,72,92,95,98,112,100,103,99],xt=0;xt<64;xt++){var _t=a((ft[xt]*H+50)/100);_t<1?_t=1:_t>255&&(_t=255),l[A[xt]]=_t}for(var et=[17,18,24,47,99,99,99,99,18,21,26,66,99,99,99,99,24,26,56,99,99,99,99,99,47,66,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99],Ct=0;Ct<64;Ct++){var Pt=a((et[Ct]*H+50)/100);Pt<1?Pt=1:Pt>255&&(Pt=255),c[A[Ct]]=Pt}for(var mt=[1,1.387039845,1.306562965,1.175875602,1,.785694958,.5411961,.275899379],vt=0,$t=0;$t<8;$t++)for(var Tt=0;Tt<8;Tt++)f[vt]=1/(l[A[vt]]*mt[$t]*mt[Tt]*8),g[vt]=1/(c[A[vt]]*mt[$t]*mt[Tt]*8),vt++}function W(H,ft){for(var xt=0,_t=0,et=new Array,Ct=1;Ct<=16;Ct++){for(var Pt=1;Pt<=H[Ct];Pt++)et[ft[_t]]=[],et[ft[_t]][0]=xt,et[ft[_t]][1]=Ct,_t++,xt++;xt*=2}return et}function Z(){h=W(O,$),p=W(F,C),s=W(D,M),r=W(R,j)}function at(){for(var H=1,ft=2,xt=1;xt<=15;xt++){for(var _t=H;_t<ft;_t++)d[32767+_t]=xt,u[32767+_t]=[],u[32767+_t][1]=xt,u[32767+_t][0]=_t;for(var et=-(ft-1);et<=-H;et++)d[32767+et]=xt,u[32767+et]=[],u[32767+et][1]=xt,u[32767+et][0]=ft-1+et;H<<=1,ft<<=1}}function J(){for(var H=0;H<256;H++)S[H]=19595*H,S[H+256>>0]=38470*H,S[H+512>>0]=7471*H+32768,S[H+768>>0]=-11059*H,S[H+1024>>0]=-21709*H,S[H+1280>>0]=32768*H+8421375,S[H+1536>>0]=-27439*H,S[H+1792>>0]=-5329*H}function Y(H){for(var ft=H[0],xt=H[1]-1;xt>=0;)ft&1<<xt&&(w|=1<<x),xt--,x--,x<0&&(w==255?(K(255),K(0)):K(w),x=7,w=0)}function K(H){y.push(H)}function it(H){K(H>>8&255),K(H&255)}function rt(H,ft){var xt,_t,et,Ct,Pt,mt,vt,$t,Tt=0,kt,Rt=8,lt=64;for(kt=0;kt<Rt;++kt){xt=H[Tt],_t=H[Tt+1],et=H[Tt+2],Ct=H[Tt+3],Pt=H[Tt+4],mt=H[Tt+5],vt=H[Tt+6],$t=H[Tt+7];var B=xt+$t,z=xt-$t,Q=_t+vt,st=_t-vt,ht=et+mt,bt=et-mt,Ft=Ct+Pt,Ht=Ct-Pt,zt=B+Ft,Vt=B-Ft,jt=Q+ht,Xt=Q-ht;H[Tt]=zt+jt,H[Tt+4]=zt-jt;var Jt=(Xt+Vt)*.707106781;H[Tt+2]=Vt+Jt,H[Tt+6]=Vt-Jt,zt=Ht+bt,jt=bt+st,Xt=st+z;var q=(zt-Xt)*.382683433,k=.5411961*zt+q,L=1.306562965*Xt+q,V=jt*.707106781,nt=z+V,wt=z-V;H[Tt+5]=wt+k,H[Tt+3]=wt-k,H[Tt+1]=nt+L,H[Tt+7]=nt-L,Tt+=8}for(Tt=0,kt=0;kt<Rt;++kt){xt=H[Tt],_t=H[Tt+8],et=H[Tt+16],Ct=H[Tt+24],Pt=H[Tt+32],mt=H[Tt+40],vt=H[Tt+48],$t=H[Tt+56];var Et=xt+$t,Gt=xt-$t,Ut=_t+vt,Yt=_t-vt,Zt=et+mt,se=et-mt,qt=Ct+Pt,oe=Ct-Pt,Bt=Et+qt,te=Et-qt,Kt=Ut+Zt,re=Ut-Zt;H[Tt]=Bt+Kt,H[Tt+32]=Bt-Kt;var ae=(re+te)*.707106781;H[Tt+16]=te+ae,H[Tt+48]=te-ae,Bt=oe+se,Kt=se+Yt,re=Yt+Gt;var ie=(Bt-re)*.382683433,ue=.5411961*Bt+ie,fe=1.306562965*re+ie,de=Kt*.707106781,pe=Gt+de,ge=Gt-de;H[Tt+40]=ge+ue,H[Tt+24]=ge-ue,H[Tt+8]=pe+fe,H[Tt+56]=pe-fe,Tt++}var ce;for(kt=0;kt<lt;++kt)ce=H[kt]*ft[kt],m[kt]=ce>0?ce+.5|0:ce-.5|0;return m}function yt(){it(65504),it(16),K(74),K(70),K(73),K(70),K(0),K(1),K(1),K(0),it(1),it(1),K(0),K(0)}function ut(H){if(H){it(65505),H[0]===69&&H[1]===120&&H[2]===105&&H[3]===102?it(H.length+2):(it(H.length+5+2),K(69),K(120),K(105),K(102),K(0));for(var ft=0;ft<H.length;ft++)K(H[ft])}}function St(H,ft){it(65472),it(17),K(8),it(ft),it(H),K(3),K(1),K(17),K(0),K(2),K(17),K(1),K(3),K(17),K(1)}function gt(){it(65499),it(132),K(0);for(var H=0;H<64;H++)K(l[H]);K(1);for(var ft=0;ft<64;ft++)K(c[ft])}function Ot(){it(65476),it(418),K(0);for(var H=0;H<16;H++)K(O[H+1]);for(var ft=0;ft<=11;ft++)K($[ft]);K(16);for(var xt=0;xt<16;xt++)K(D[xt+1]);for(var _t=0;_t<=161;_t++)K(M[_t]);K(1);for(var et=0;et<16;et++)K(F[et+1]);for(var Ct=0;Ct<=11;Ct++)K(C[Ct]);K(17);for(var Pt=0;Pt<16;Pt++)K(R[Pt+1]);for(var mt=0;mt<=161;mt++)K(j[mt])}function pt(H){typeof H>"u"||H.constructor!==Array||H.forEach(ft=>{if(typeof ft=="string"){it(65534);var xt=ft.length;it(xt+2);var _t;for(_t=0;_t<xt;_t++)K(ft.charCodeAt(_t))}})}function ct(){it(65498),it(12),K(3),K(1),K(0),K(2),K(17),K(3),K(17),K(0),K(63),K(0)}function ot(H,ft,xt,_t,et){for(var Ct=et[0],Pt=et[240],mt,vt=16,$t=63,Tt=64,kt=rt(H,ft),Rt=0;Rt<Tt;++Rt)b[A[Rt]]=kt[Rt];var lt=b[0]-xt;xt=b[0],lt==0?Y(_t[0]):(mt=32767+lt,Y(_t[d[mt]]),Y(u[mt]));for(var B=63;B>0&&b[B]==0;B--);if(B==0)return Y(Ct),xt;for(var z=1,Q;z<=B;){for(var st=z;b[z]==0&&z<=B;++z);var ht=z-st;if(ht>=vt){Q=ht>>4;for(var bt=1;bt<=Q;++bt)Y(Pt);ht=ht&15}mt=32767+b[z],Y(et[(ht<<4)+d[mt]]),Y(u[mt]),z++}return B!=$t&&Y(Ct),xt}function Mt(){for(var H=String.fromCharCode,ft=0;ft<256;ft++)I[ft]=H(ft)}this.encode=function(H,ft){new Date().getTime(),ft&&It(ft),y=new Array,w=0,x=7,it(65496),yt(),pt(H.comments),ut(H.exifBuffer),gt(),St(H.width,H.height),Ot(),ct();var xt=0,_t=0,et=0;w=0,x=7,this.encode.displayName="_encode_";for(var Ct=H.data,Pt=H.width,mt=H.height,vt=Pt*4,$t,Tt=0,kt,Rt,lt,B,z,Q,st,ht;Tt<mt;){for($t=0;$t<vt;){for(B=vt*Tt+$t,z=B,Q=-1,st=0,ht=0;ht<64;ht++)st=ht>>3,Q=(ht&7)*4,z=B+st*vt+Q,Tt+st>=mt&&(z-=vt*(Tt+1+st-mt)),$t+Q>=vt&&(z-=$t+Q-vt+4),kt=Ct[z++],Rt=Ct[z++],lt=Ct[z++],_[ht]=(S[kt]+S[Rt+256>>0]+S[lt+512>>0]>>16)-128,v[ht]=(S[kt+768>>0]+S[Rt+1024>>0]+S[lt+1280>>0]>>16)-128,E[ht]=(S[kt+1280>>0]+S[Rt+1536>>0]+S[lt+1792>>0]>>16)-128;xt=ot(_,f,xt,h,s),_t=ot(v,g,_t,p,r),et=ot(E,g,et,p,r),$t+=32}Tt+=8}if(x>=0){var bt=[];bt[1]=x+1,bt[0]=(1<<x+1)-1,Y(bt)}return it(65497),Buffer.from(y)};function It(H){if(H<=0&&(H=1),H>100&&(H=100),T!=H){var ft=0;H<50?ft=Math.floor(5e3/H):ft=Math.floor(200-H*2),G(ft),T=H}}function Dt(){var H=new Date().getTime();n||(n=50),Mt(),Z(),at(),J(),It(n),new Date().getTime()-H}Dt()}o.exports=e;function e(n,a){typeof a>"u"&&(a=50);var l=new t(a),c=l.encode(n,a);return{data:c,width:n.width,height:n.height}}})(encoder);var encoderExports=encoder.exports,decoder={exports:{}};(function(o){var t=function(){var a=new Int32Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]),l=4017,c=799,f=3406,g=2276,h=1567,p=3784,s=5793,r=2896;function u(){}function d(v,E){for(var I=0,S=[],T,A,O=16;O>0&&!v[O-1];)O--;S.push({children:[],index:0});var $=S[0],D;for(T=0;T<O;T++){for(A=0;A<v[T];A++){for($=S.pop(),$.children[$.index]=E[I];$.index>0;){if(S.length===0)throw new Error("Could not recreate Huffman Table");$=S.pop()}for($.index++,S.push($);S.length<=T;)S.push(D={children:[],index:0}),$.children[$.index]=D.children,$=D;I++}T+1<O&&(S.push(D={children:[],index:0}),$.children[$.index]=D.children,$=D)}return S[0].children}function m(v,E,I,S,T,A,O,$,D,M){I.precision,I.samplesPerLine,I.scanLines;var F=I.mcusPerLine,C=I.progressive;I.maxH,I.maxV;var R=E,j=0,G=0;function W(){if(G>0)return G--,j>>G&1;if(j=v[E++],j==255){var mt=v[E++];if(mt)throw new Error("unexpected marker: "+(j<<8|mt).toString(16))}return G=7,j>>>7}function Z(mt){for(var vt=mt,$t;($t=W())!==null;){if(vt=vt[$t],typeof vt=="number")return vt;if(typeof vt!="object")throw new Error("invalid huffman sequence")}return null}function at(mt){for(var vt=0;mt>0;){var $t=W();if($t===null)return;vt=vt<<1|$t,mt--}return vt}function J(mt){var vt=at(mt);return vt>=1<<mt-1?vt:vt+(-1<<mt)+1}function Y(mt,vt){var $t=Z(mt.huffmanTableDC),Tt=$t===0?0:J($t);vt[0]=mt.pred+=Tt;for(var kt=1;kt<64;){var Rt=Z(mt.huffmanTableAC),lt=Rt&15,B=Rt>>4;if(lt===0){if(B<15)break;kt+=16;continue}kt+=B;var z=a[kt];vt[z]=J(lt),kt++}}function K(mt,vt){var $t=Z(mt.huffmanTableDC),Tt=$t===0?0:J($t)<<D;vt[0]=mt.pred+=Tt}function it(mt,vt){vt[0]|=W()<<D}var rt=0;function yt(mt,vt){if(rt>0){rt--;return}for(var $t=A,Tt=O;$t<=Tt;){var kt=Z(mt.huffmanTableAC),Rt=kt&15,lt=kt>>4;if(Rt===0){if(lt<15){rt=at(lt)+(1<<lt)-1;break}$t+=16;continue}$t+=lt;var B=a[$t];vt[B]=J(Rt)*(1<<D),$t++}}var ut=0,St;function gt(mt,vt){for(var $t=A,Tt=O,kt=0;$t<=Tt;){var Rt=a[$t],lt=vt[Rt]<0?-1:1;switch(ut){case 0:var B=Z(mt.huffmanTableAC),z=B&15,kt=B>>4;if(z===0)kt<15?(rt=at(kt)+(1<<kt),ut=4):(kt=16,ut=1);else{if(z!==1)throw new Error("invalid ACn encoding");St=J(z),ut=kt?2:3}continue;case 1:case 2:vt[Rt]?vt[Rt]+=(W()<<D)*lt:(kt--,kt===0&&(ut=ut==2?3:0));break;case 3:vt[Rt]?vt[Rt]+=(W()<<D)*lt:(vt[Rt]=St<<D,ut=0);break;case 4:vt[Rt]&&(vt[Rt]+=(W()<<D)*lt);break}$t++}ut===4&&(rt--,rt===0&&(ut=0))}function Ot(mt,vt,$t,Tt,kt){var Rt=$t/F|0,lt=$t%F,B=Rt*mt.v+Tt,z=lt*mt.h+kt;mt.blocks[B]===void 0&&M.tolerantDecoding||vt(mt,mt.blocks[B][z])}function pt(mt,vt,$t){var Tt=$t/mt.blocksPerLine|0,kt=$t%mt.blocksPerLine;mt.blocks[Tt]===void 0&&M.tolerantDecoding||vt(mt,mt.blocks[Tt][kt])}var ct=S.length,ot,Mt,It,Dt,H,ft;C?A===0?ft=$===0?K:it:ft=$===0?yt:gt:ft=Y;var xt=0,_t,et;ct==1?et=S[0].blocksPerLine*S[0].blocksPerColumn:et=F*I.mcusPerColumn,T||(T=et);for(var Ct,Pt;xt<et;){for(Mt=0;Mt<ct;Mt++)S[Mt].pred=0;if(rt=0,ct==1)for(ot=S[0],H=0;H<T;H++)pt(ot,ft,xt),xt++;else for(H=0;H<T;H++){for(Mt=0;Mt<ct;Mt++)for(ot=S[Mt],Ct=ot.h,Pt=ot.v,It=0;It<Pt;It++)for(Dt=0;Dt<Ct;Dt++)Ot(ot,ft,xt,It,Dt);if(xt++,xt===et)break}if(xt===et)do{if(v[E]===255&&v[E+1]!==0)break;E+=1}while(E<v.length-2);if(G=0,_t=v[E]<<8|v[E+1],_t<65280)throw new Error("marker was not found");if(_t>=65488&&_t<=65495)E+=2;else break}return E-R}function b(v,E){var I=[],S=E.blocksPerLine,T=E.blocksPerColumn,A=S<<3,O=new Int32Array(64),$=new Uint8Array(64);function D(at,J,Y){var K=E.quantizationTable,it,rt,yt,ut,St,gt,Ot,pt,ct,ot=Y,Mt;for(Mt=0;Mt<64;Mt++)ot[Mt]=at[Mt]*K[Mt];for(Mt=0;Mt<8;++Mt){var It=8*Mt;if(ot[1+It]==0&&ot[2+It]==0&&ot[3+It]==0&&ot[4+It]==0&&ot[5+It]==0&&ot[6+It]==0&&ot[7+It]==0){ct=s*ot[0+It]+512>>10,ot[0+It]=ct,ot[1+It]=ct,ot[2+It]=ct,ot[3+It]=ct,ot[4+It]=ct,ot[5+It]=ct,ot[6+It]=ct,ot[7+It]=ct;continue}it=s*ot[0+It]+128>>8,rt=s*ot[4+It]+128>>8,yt=ot[2+It],ut=ot[6+It],St=r*(ot[1+It]-ot[7+It])+128>>8,pt=r*(ot[1+It]+ot[7+It])+128>>8,gt=ot[3+It]<<4,Ot=ot[5+It]<<4,ct=it-rt+1>>1,it=it+rt+1>>1,rt=ct,ct=yt*p+ut*h+128>>8,yt=yt*h-ut*p+128>>8,ut=ct,ct=St-Ot+1>>1,St=St+Ot+1>>1,Ot=ct,ct=pt+gt+1>>1,gt=pt-gt+1>>1,pt=ct,ct=it-ut+1>>1,it=it+ut+1>>1,ut=ct,ct=rt-yt+1>>1,rt=rt+yt+1>>1,yt=ct,ct=St*g+pt*f+2048>>12,St=St*f-pt*g+2048>>12,pt=ct,ct=gt*c+Ot*l+2048>>12,gt=gt*l-Ot*c+2048>>12,Ot=ct,ot[0+It]=it+pt,ot[7+It]=it-pt,ot[1+It]=rt+Ot,ot[6+It]=rt-Ot,ot[2+It]=yt+gt,ot[5+It]=yt-gt,ot[3+It]=ut+St,ot[4+It]=ut-St}for(Mt=0;Mt<8;++Mt){var Dt=Mt;if(ot[8+Dt]==0&&ot[16+Dt]==0&&ot[24+Dt]==0&&ot[32+Dt]==0&&ot[40+Dt]==0&&ot[48+Dt]==0&&ot[56+Dt]==0){ct=s*Y[Mt+0]+8192>>14,ot[0+Dt]=ct,ot[8+Dt]=ct,ot[16+Dt]=ct,ot[24+Dt]=ct,ot[32+Dt]=ct,ot[40+Dt]=ct,ot[48+Dt]=ct,ot[56+Dt]=ct;continue}it=s*ot[0+Dt]+2048>>12,rt=s*ot[32+Dt]+2048>>12,yt=ot[16+Dt],ut=ot[48+Dt],St=r*(ot[8+Dt]-ot[56+Dt])+2048>>12,pt=r*(ot[8+Dt]+ot[56+Dt])+2048>>12,gt=ot[24+Dt],Ot=ot[40+Dt],ct=it-rt+1>>1,it=it+rt+1>>1,rt=ct,ct=yt*p+ut*h+2048>>12,yt=yt*h-ut*p+2048>>12,ut=ct,ct=St-Ot+1>>1,St=St+Ot+1>>1,Ot=ct,ct=pt+gt+1>>1,gt=pt-gt+1>>1,pt=ct,ct=it-ut+1>>1,it=it+ut+1>>1,ut=ct,ct=rt-yt+1>>1,rt=rt+yt+1>>1,yt=ct,ct=St*g+pt*f+2048>>12,St=St*f-pt*g+2048>>12,pt=ct,ct=gt*c+Ot*l+2048>>12,gt=gt*l-Ot*c+2048>>12,Ot=ct,ot[0+Dt]=it+pt,ot[56+Dt]=it-pt,ot[8+Dt]=rt+Ot,ot[48+Dt]=rt-Ot,ot[16+Dt]=yt+gt,ot[40+Dt]=yt-gt,ot[24+Dt]=ut+St,ot[32+Dt]=ut-St}for(Mt=0;Mt<64;++Mt){var H=128+(ot[Mt]+8>>4);J[Mt]=H<0?0:H>255?255:H}}_(A*T*8);for(var M,F,C=0;C<T;C++){var R=C<<3;for(M=0;M<8;M++)I.push(new Uint8Array(A));for(var j=0;j<S;j++){D(E.blocks[C][j],$,O);var G=0,W=j<<3;for(F=0;F<8;F++){var Z=I[R+F];for(M=0;M<8;M++)Z[W+M]=$[G++]}}}return I}function y(v){return v<0?0:v>255?255:v}u.prototype={load:function(E){var I=new XMLHttpRequest;I.open("GET",E,!0),I.responseType="arraybuffer",I.onload=function(){var S=new Uint8Array(I.response||I.mozResponseArrayBuffer);this.parse(S),this.onload&&this.onload()}.bind(this),I.send(null)},parse:function(E){var I=this.opts.maxResolutionInMP*1e3*1e3,S=0;E.length;function T(){var lt=E[S]<<8|E[S+1];return S+=2,lt}function A(){var lt=T(),B=E.subarray(S,S+lt-2);return S+=B.length,B}function O(lt){var B=1,z=1,Q,st;for(st in lt.components)lt.components.hasOwnProperty(st)&&(Q=lt.components[st],B<Q.h&&(B=Q.h),z<Q.v&&(z=Q.v));var ht=Math.ceil(lt.samplesPerLine/8/B),bt=Math.ceil(lt.scanLines/8/z);for(st in lt.components)if(lt.components.hasOwnProperty(st)){Q=lt.components[st];var Ft=Math.ceil(Math.ceil(lt.samplesPerLine/8)*Q.h/B),Ht=Math.ceil(Math.ceil(lt.scanLines/8)*Q.v/z),zt=ht*Q.h,Vt=bt*Q.v,jt=Vt*zt,Xt=[];_(jt*256);for(var Jt=0;Jt<Vt;Jt++){for(var q=[],k=0;k<zt;k++)q.push(new Int32Array(64));Xt.push(q)}Q.blocksPerLine=Ft,Q.blocksPerColumn=Ht,Q.blocks=Xt}lt.maxH=B,lt.maxV=z,lt.mcusPerLine=ht,lt.mcusPerColumn=bt}var $=null,D=null,M,F,C=[],R=[],j=[],G=[],W=T(),Z=-1;if(this.comments=[],W!=65496)throw new Error("SOI not found");for(W=T();W!=65497;){var at,J;switch(W){case 65280:break;case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var Y=A();if(W===65534){var K=String.fromCharCode.apply(null,Y);this.comments.push(K)}W===65504&&Y[0]===74&&Y[1]===70&&Y[2]===73&&Y[3]===70&&Y[4]===0&&($={version:{major:Y[5],minor:Y[6]},densityUnits:Y[7],xDensity:Y[8]<<8|Y[9],yDensity:Y[10]<<8|Y[11],thumbWidth:Y[12],thumbHeight:Y[13],thumbData:Y.subarray(14,14+3*Y[12]*Y[13])}),W===65505&&Y[0]===69&&Y[1]===120&&Y[2]===105&&Y[3]===102&&Y[4]===0&&(this.exifBuffer=Y.subarray(5,Y.length)),W===65518&&Y[0]===65&&Y[1]===100&&Y[2]===111&&Y[3]===98&&Y[4]===101&&Y[5]===0&&(D={version:Y[6],flags0:Y[7]<<8|Y[8],flags1:Y[9]<<8|Y[10],transformCode:Y[11]});break;case 65499:for(var it=T(),rt=it+S-2;S<rt;){var yt=E[S++];_(256);var ut=new Int32Array(64);if(yt>>4)if(yt>>4===1)for(J=0;J<64;J++){var St=a[J];ut[St]=T()}else throw new Error("DQT: invalid table spec");else for(J=0;J<64;J++){var St=a[J];ut[St]=E[S++]}C[yt&15]=ut}break;case 65472:case 65473:case 65474:T(),M={},M.extended=W===65473,M.progressive=W===65474,M.precision=E[S++],M.scanLines=T(),M.samplesPerLine=T(),M.components={},M.componentsOrder=[];var gt=M.scanLines*M.samplesPerLine;if(gt>I){var Ot=Math.ceil((gt-I)/1e6);throw new Error(`maxResolutionInMP limit exceeded by ${Ot}MP`)}var pt=E[S++],ct;for(at=0;at<pt;at++){ct=E[S];var ot=E[S+1]>>4,Mt=E[S+1]&15,It=E[S+2];if(ot<=0||Mt<=0)throw new Error("Invalid sampling factor, expected values above 0");M.componentsOrder.push(ct),M.components[ct]={h:ot,v:Mt,quantizationIdx:It},S+=3}O(M),R.push(M);break;case 65476:var Dt=T();for(at=2;at<Dt;){var H=E[S++],ft=new Uint8Array(16),xt=0;for(J=0;J<16;J++,S++)xt+=ft[J]=E[S];_(16+xt);var _t=new Uint8Array(xt);for(J=0;J<xt;J++,S++)_t[J]=E[S];at+=17+xt,(H>>4?j:G)[H&15]=d(ft,_t)}break;case 65501:T(),F=T();break;case 65500:T(),T();break;case 65498:T();var et=E[S++],Ct=[],Pt;for(at=0;at<et;at++){Pt=M.components[E[S++]];var mt=E[S++];Pt.huffmanTableDC=G[mt>>4],Pt.huffmanTableAC=j[mt&15],Ct.push(Pt)}var vt=E[S++],$t=E[S++],Tt=E[S++],kt=m(E,S,M,Ct,F,vt,$t,Tt>>4,Tt&15,this.opts);S+=kt;break;case 65535:E[S]!==255&&S--;break;default:if(E[S-3]==255&&E[S-2]>=192&&E[S-2]<=254){S-=3;break}else if(W===224||W==225){if(Z!==-1)throw new Error(`first unknown JPEG marker at offset ${Z.toString(16)}, second unknown JPEG marker ${W.toString(16)} at offset ${(S-1).toString(16)}`);Z=S-1;const lt=T();if(E[S+lt-2]===255){S+=lt-2;break}}throw new Error("unknown JPEG marker "+W.toString(16))}W=T()}if(R.length!=1)throw new Error("only single frame JPEGs supported");for(var at=0;at<R.length;at++){var Rt=R[at].components;for(var J in Rt)Rt[J].quantizationTable=C[Rt[J].quantizationIdx],delete Rt[J].quantizationIdx}this.width=M.samplesPerLine,this.height=M.scanLines,this.jfif=$,this.adobe=D,this.components=[];for(var at=0;at<M.componentsOrder.length;at++){var Pt=M.components[M.componentsOrder[at]];this.components.push({lines:b(M,Pt),scaleX:Pt.h/M.maxH,scaleY:Pt.v/M.maxV})}},getData:function(E,I){var S=this.width/E,T=this.height/I,A,O,$,D,M,F,C,R,j,G,W=0,Z,at,J,Y,K,it,rt,yt,ut,St,gt,Ot=E*I*this.components.length;_(Ot);var pt=new Uint8Array(Ot);switch(this.components.length){case 1:for(A=this.components[0],G=0;G<I;G++)for(M=A.lines[0|G*A.scaleY*T],j=0;j<E;j++)Z=M[0|j*A.scaleX*S],pt[W++]=Z;break;case 2:for(A=this.components[0],O=this.components[1],G=0;G<I;G++)for(M=A.lines[0|G*A.scaleY*T],F=O.lines[0|G*O.scaleY*T],j=0;j<E;j++)Z=M[0|j*A.scaleX*S],pt[W++]=Z,Z=F[0|j*O.scaleX*S],pt[W++]=Z;break;case 3:for(gt=!0,this.adobe&&this.adobe.transformCode?gt=!0:typeof this.opts.colorTransform<"u"&&(gt=!!this.opts.colorTransform),A=this.components[0],O=this.components[1],$=this.components[2],G=0;G<I;G++)for(M=A.lines[0|G*A.scaleY*T],F=O.lines[0|G*O.scaleY*T],C=$.lines[0|G*$.scaleY*T],j=0;j<E;j++)gt?(Z=M[0|j*A.scaleX*S],at=F[0|j*O.scaleX*S],J=C[0|j*$.scaleX*S],yt=y(Z+1.402*(J-128)),ut=y(Z-.3441363*(at-128)-.71413636*(J-128)),St=y(Z+1.772*(at-128))):(yt=M[0|j*A.scaleX*S],ut=F[0|j*O.scaleX*S],St=C[0|j*$.scaleX*S]),pt[W++]=yt,pt[W++]=ut,pt[W++]=St;break;case 4:if(!this.adobe)throw new Error("Unsupported color mode (4 components)");for(gt=!1,this.adobe&&this.adobe.transformCode?gt=!0:typeof this.opts.colorTransform<"u"&&(gt=!!this.opts.colorTransform),A=this.components[0],O=this.components[1],$=this.components[2],D=this.components[3],G=0;G<I;G++)for(M=A.lines[0|G*A.scaleY*T],F=O.lines[0|G*O.scaleY*T],C=$.lines[0|G*$.scaleY*T],R=D.lines[0|G*D.scaleY*T],j=0;j<E;j++)gt?(Z=M[0|j*A.scaleX*S],at=F[0|j*O.scaleX*S],J=C[0|j*$.scaleX*S],Y=R[0|j*D.scaleX*S],K=255-y(Z+1.402*(J-128)),it=255-y(Z-.3441363*(at-128)-.71413636*(J-128)),rt=255-y(Z+1.772*(at-128))):(K=M[0|j*A.scaleX*S],it=F[0|j*O.scaleX*S],rt=C[0|j*$.scaleX*S],Y=R[0|j*D.scaleX*S]),pt[W++]=255-K,pt[W++]=255-it,pt[W++]=255-rt,pt[W++]=255-Y;break;default:throw new Error("Unsupported color mode")}return pt},copyToImageData:function(E,I){var S=E.width,T=E.height,A=E.data,O=this.getData(S,T),$=0,D=0,M,F,C,R,j,G,W,Z,at;switch(this.components.length){case 1:for(F=0;F<T;F++)for(M=0;M<S;M++)C=O[$++],A[D++]=C,A[D++]=C,A[D++]=C,I&&(A[D++]=255);break;case 3:for(F=0;F<T;F++)for(M=0;M<S;M++)W=O[$++],Z=O[$++],at=O[$++],A[D++]=W,A[D++]=Z,A[D++]=at,I&&(A[D++]=255);break;case 4:for(F=0;F<T;F++)for(M=0;M<S;M++)j=O[$++],G=O[$++],C=O[$++],R=O[$++],W=255-y(j*(1-R/255)+R),Z=255-y(G*(1-R/255)+R),at=255-y(C*(1-R/255)+R),A[D++]=W,A[D++]=Z,A[D++]=at,I&&(A[D++]=255);break;default:throw new Error("Unsupported color mode")}}};var w=0,x=0;function _(v=0){var E=w+v;if(E>x){var I=Math.ceil((E-x)/1024/1024);throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${I}MB`)}w=E}return u.resetMaxMemoryUsage=function(v){w=0,x=v},u.getBytesAllocated=function(){return w},u.requestMemoryAllocation=_,u}();o.exports=e;function e(n,a={}){var l={colorTransform:void 0,useTArray:!1,formatAsRGBA:!0,tolerantDecoding:!0,maxResolutionInMP:100,maxMemoryUsageInMB:512},c={...l,...a},f=new Uint8Array(n),g=new t;g.opts=c,t.resetMaxMemoryUsage(c.maxMemoryUsageInMB*1024*1024),g.parse(f);var h=c.formatAsRGBA?4:3,p=g.width*g.height*h;try{t.requestMemoryAllocation(p);var s={width:g.width,height:g.height,exifBuffer:g.exifBuffer,data:c.useTArray?new Uint8Array(p):Buffer.alloc(p)};g.comments.length>0&&(s.comments=g.comments)}catch(r){throw r instanceof RangeError?new Error("Could not allocate enough memory for the image. Required: "+p):r instanceof ReferenceError&&r.message==="Buffer is not defined"?new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true"):r}return g.copyToImageData(s,c.formatAsRGBA),s}})(decoder);var decoderExports=decoder.exports,encode$1=encoderExports,decode$4=decoderExports,jpegJs={encode:encode$1,decode:decode$4};let chars="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",lookup=new Uint8Array(256);for(let o=0;o<chars.length;o++)lookup[chars.charCodeAt(o)]=o;function encode(o){let t,e=o.length,n="";for(t=0;t<e;t+=3)n+=chars[o[t]>>2],n+=chars[(o[t]&3)<<4|o[t+1]>>4],n+=chars[(o[t+1]&15)<<2|o[t+2]>>6],n+=chars[o[t+2]&63];return e%3===2?n=`${n.substring(0,n.length-1)}=`:e%3===1&&(n=`${n.substring(0,n.length-2)}==`),n}function decode$3(o){let t=o.length*.75,e=o.length,n=0,a,l,c,f;o[o.length-1]==="="&&(t--,o[o.length-2]==="="&&t--);const g=new Uint8Array(t);for(let h=0;h<e;h+=4)a=lookup[o.charCodeAt(h)],l=lookup[o.charCodeAt(h+1)],c=lookup[o.charCodeAt(h+2)],f=lookup[o.charCodeAt(h+3)],g[n++]=a<<2|l>>4,g[n++]=(l&15)<<4|c>>2,g[n++]=(c&3)<<6|f&63;return g}function toBase64URL(o,t){const e=encode(o);return`data:${t};base64,${e}`}const ImageData$1=self.ImageData,DOMImage=self.Image;function createCanvas(o,t){let e=self.document.createElement("canvas");return e.width=o,e.height=t,e}function fetchBinary(o,{withCredentials:t=!1}={}){return new Promise(function(e,n){let a=new self.XMLHttpRequest;a.open("GET",o,!0),a.responseType="arraybuffer",a.withCredentials=t,a.onload=function(l){this.status!==200?n(l):e(this.response)},a.onerror=n,a.send()})}function createWriteStream(){throw new Error("createWriteStream does not exist in the browser")}function writeFile(){throw new Error("writeFile does not exist in the browser")}function getType(o){return o.includes("/")||(o=`image/${o}`),o}function encodeJpeg(o,t={}){const e={width:o.width,height:o.height,data:o.getRGBAData()};return jpegJs.encode(e,t.quality).data}function encodePng(o,t){const e={width:o.width,height:o.height,channels:o.channels,depth:o.bitDepth,data:o.data};return(e.depth===1||e.depth===32)&&(e.depth=8,e.channels=4,e.data=o.getRGBAData()),encodePng$1(e,t)}const exportMethods={save(o,t={}){const{useCanvas:e=!1,encoder:n=void 0}=t;let{format:a}=t;if(!a){const l=/\.(?<format>[a-zA-Z]+)$/.exec(o);l&&(a=l.groups.format.toLowerCase())}if(!a)throw new Error("file format not provided");return new Promise((l,c)=>{let f,g;switch(a.toLowerCase()){case"png":{e?f=this.getCanvas().pngStream():g=encodePng(this,n);break}case"jpg":case"jpeg":e?f=this.getCanvas().jpegStream():g=encodeJpeg(this,n);break;case"bmp":g=encode$2(this,n);break;default:throw new RangeError(`invalid output format: ${a}`)}if(f){let h=createWriteStream();h.on("finish",l),h.on("error",c),f.pipe(h)}else g&&writeFile()})},toDataURL(o="image/png",t={}){typeof o=="object"&&(t=o,o="image/png");const{useCanvas:e=!1,encoder:n=void 0}=t;o=getType(o);function a(l,c){const f=l(c,n);return toBase64URL(f,o)}return o==="image/bmp"?a(encode$2,this):o==="image/png"&&!e?a(encodePng,this):o==="image/jpeg"&&!e?a(encodeJpeg,this):this.getCanvas().toDataURL(o)},toBuffer(o={}){const{format:t="png",encoder:e=void 0}=o;switch(t.toLowerCase()){case"png":return encodePng(this,e);case"jpeg":case"jpg":return encodeJpeg(this,e);case"bmp":return encode$2(this,e);default:throw new RangeError(`invalid output format: ${t}`)}},toBase64(o="image/png",t={}){if(t.async)return this.toDataURL(o,t).then(function(e){return e.substring(e.indexOf(",")+1)});{const e=this.toDataURL(o,t);return e.substring(e.indexOf(",")+1)}},toBlob(o="image/png",t=.8){return canvasToBlob(this.getCanvas(),o,t)},getCanvas(){const o=new ImageData$1(this.getRGBAData({clamped:!0}),this.width,this.height);let t=createCanvas(this.width,this.height);return t.getContext("2d").putImageData(o,0,0),t}};function setExportMethods(o){for(const t in exportMethods)o.prototype[t]=exportMethods[t]}var hasOwn$1={exports:{}};const name$1="has-own",version="1.0.1",description="A safer .hasOwnProperty() - hasOwn(name, obj)",main="index.js",scripts={test:"make test"},author="Aaron Heckmann <aaron.heckmann+github@gmail.com>",license="MIT",repository={type:"git",url:"git://github.com/aheckmann/has-own.git"},homepage="https://github.com/aheckmann/has-own/",devDependencies={mocha:"^6.2.2"};var require$$0$2={name:name$1,version,description,main,scripts,author,license,repository,homepage,devDependencies};(function(o,t){var e=Object.prototype.hasOwnProperty;o.exports=t=function(a,l){return e.call(l,a)},t.version=require$$0$2.version})(hasOwn$1,hasOwn$1.exports);var hasOwnExports=hasOwn$1.exports,hasOwn=getDefaultExportFromCjs(hasOwnExports);let computedPropertyDescriptor$1={configurable:!0,enumerable:!1,get:void 0};function extendMethod(o,t,e={}){let{inPlace:n=!1,returnThis:a=!0,partialArgs:l=[]}=e;return n?Image$1.prototype[o]=function(...c){this.computed=null;let f=t.apply(this,[...l,...c]);return a?this:f}:Image$1.prototype[o]=function(...c){return t.apply(this,[...l,...c])},Image$1}function extendProperty(o,t,e={}){let{partialArgs:n=[]}=e;return computedPropertyDescriptor$1.get=function(){if(this.computed===null)this.computed={};else if(hasOwn(o,this.computed))return this.computed[o];let a=t.apply(this,n);return this.computed[o]=a,a},Object.defineProperty(Image$1.prototype,o,computedPropertyDescriptor$1),Image$1}const GREY$1="GREY",RGB$1="RGB",HSL="HSL",HSV="HSV",CMYK$1="CMYK";var ColorModel=Object.freeze({__proto__:null,CMYK:CMYK$1,GREY:GREY$1,HSL,HSV,RGB:RGB$1});function getRGBAData(o={}){const{clamped:t}=o;this.checkProcessable("getRGBAData",{components:[1,3],bitDepth:[1,8,16,32]});const e=this.width*this.height*4;let n=t?new Uint8ClampedArray(e):new Uint8Array(e);return this.bitDepth===1?fillDataFromBinary(this,n):this.bitDepth===32?(this.checkProcessable("getRGBAData",{alpha:0}),this.components===1?fillDataFromGrey32(this,n):this.components===3&&(this.checkProcessable("getRGBAData",{colorModel:[RGB$1]}),fillDataFromRGB32(this,n))):this.components===1?fillDataFromGrey(this,n):this.components===3&&(this.checkProcessable("getRGBAData",{colorModel:[RGB$1]}),fillDataFromRGB(this,n)),this.alpha===1?(this.checkProcessable("getRGBAData",{bitDepth:[8,16]}),copyAlpha(this,n)):fillAlpha(this,n),n}function fillDataFromBinary(o,t){for(let e=0;e<o.size;e++){const n=o.getBit(e);t[e*4]=n*255,t[e*4+1]=n*255,t[e*4+2]=n*255}}function fillDataFromGrey32(o,t){const e=o.min[0],a=o.max[0]-e;for(let l=0;l<o.size;l++){const c=Math.floor(255*(o.data[l]-e)/a);t[l*4]=c,t[l*4+1]=c,t[l*4+2]=c}}function fillDataFromRGB32(o,t){const e=Math.min(...o.min),a=Math.max(...o.max)-e;for(let l=0;l<o.size;l++){const c=Math.floor(255*(o.data[l*3]-e)/a),f=Math.floor(255*(o.data[l*3+1]-e)/a),g=Math.floor(255*(o.data[l*3+2]-e)/a);t[l*4]=c,t[l*4+1]=f,t[l*4+2]=g}}function fillDataFromGrey(o,t){for(let e=0;e<o.size;e++)t[e*4]=o.data[e*o.channels]>>>o.bitDepth-8,t[e*4+1]=o.data[e*o.channels]>>>o.bitDepth-8,t[e*4+2]=o.data[e*o.channels]>>>o.bitDepth-8}function fillDataFromRGB(o,t){for(let e=0;e<o.size;e++)t[e*4]=o.data[e*o.channels]>>>o.bitDepth-8,t[e*4+1]=o.data[e*o.channels+1]>>>o.bitDepth-8,t[e*4+2]=o.data[e*o.channels+2]>>>o.bitDepth-8}function copyAlpha(o,t){for(let e=0;e<o.size;e++)t[e*4+3]=o.data[e*o.channels+o.components]>>o.bitDepth-8}function fillAlpha(o,t){for(let e=0;e<o.size;e++)t[e*4+3]=255}const BINARY="BINARY",GREY="GREY",GREYA="GREYA",RGB="RGB",RGBA="RGBA",CMYK="CMYK",CMYKA="CMYKA",kinds={};kinds[BINARY]={components:1,alpha:0,bitDepth:1,colorModel:GREY$1},kinds[GREYA]={components:1,alpha:1,bitDepth:8,colorModel:GREY$1},kinds[GREY]={components:1,alpha:0,bitDepth:8,colorModel:GREY$1},kinds[RGBA]={components:3,alpha:1,bitDepth:8,colorModel:RGB$1},kinds[RGB]={components:3,alpha:0,bitDepth:8,colorModel:RGB$1},kinds[CMYK]={components:4,alpha:0,bitDepth:8,colorModel:CMYK$1},kinds[CMYKA]={components:4,alpha:1,bitDepth:8,colorModel:CMYK$1};function getKind(o){const t=kinds[o];if(!t)throw new RangeError(`invalid image kind: ${o}`);return t}const validBitDepth=[1,8,16,32];function verifyKindDefinition(o){const{components:t,alpha:e,bitDepth:n,colorModel:a}=o;if(!Number.isInteger(t)||t<=0)throw new RangeError(`invalid components: ${t}. Must be a positive integer`);if(e!==0&&e!==1&&typeof e!="boolean")throw new TypeError(`invalid alpha: ${e}: must be a boolean, 0 or 1`);if(!validBitDepth.includes(n))throw new RangeError(`invalid bitDepth: ${n}. Must be one of ${validBitDepth.join(", ")}`);if(!ColorModel[a])throw new RangeError(`invalid colorModel: ${a}. Must be one of ${Object.keys(ColorModel).join(", ")}`)}function getTheoreticalPixelArraySize(o,t,e){let n=t*o;return e===1&&(n=Math.ceil(n/8)),n}function createPixelArray(o,t,e,n,a,l){const c=n*o;let f;switch(a){case 1:f=new Uint8Array(Math.ceil(c/8));break;case 8:f=new Uint8Array(c);break;case 16:f=new Uint16Array(c);break;case 32:f=new Float32Array(c);break;default:throw new Error(`Cannot create pixel array for bit depth ${a}`)}if(e)for(let g=t;g<f.length;g+=n)f[g]=l;return f}const defaultByteLength=1024*8,charArray=[];let IOBuffer$2=class{constructor(t,e){e=e||{},t===void 0&&(t=defaultByteLength),typeof t=="number"&&(t=new ArrayBuffer(t));let n=t.byteLength;const a=e.offset?e.offset>>>0:0;t.buffer&&(n=t.byteLength-a,t.byteLength!==t.buffer.byteLength?t=t.buffer.slice(t.byteOffset+a,t.byteOffset+t.byteLength):a?t=t.buffer.slice(a):t=t.buffer),this.buffer=t,this.length=n,this.byteLength=n,this.byteOffset=0,this.offset=0,this.littleEndian=!0,this._data=new DataView(this.buffer),this._increment=n||defaultByteLength,this._mark=0}available(t){return t===void 0&&(t=1),this.offset+t<=this.length}isLittleEndian(){return this.littleEndian}setLittleEndian(){this.littleEndian=!0}isBigEndian(){return!this.littleEndian}setBigEndian(){this.littleEndian=!1}skip(t){t===void 0&&(t=1),this.offset+=t}seek(t){this.offset=t}mark(){this._mark=this.offset}reset(){this.offset=this._mark}rewind(){this.offset=0}ensureAvailable(t){if(t===void 0&&(t=1),!this.available(t)){const e=this._increment+this._increment;this._increment=e;const n=this.length+e,a=new Uint8Array(n);a.set(new Uint8Array(this.buffer)),this.buffer=a.buffer,this.length=n,this._data=new DataView(this.buffer)}}readBoolean(){return this.readUint8()!==0}readInt8(){return this._data.getInt8(this.offset++)}readUint8(){return this._data.getUint8(this.offset++)}readByte(){return this.readUint8()}readBytes(t){t===void 0&&(t=1);for(var e=new Uint8Array(t),n=0;n<t;n++)e[n]=this.readByte();return e}readInt16(){var t=this._data.getInt16(this.offset,this.littleEndian);return this.offset+=2,t}readUint16(){var t=this._data.getUint16(this.offset,this.littleEndian);return this.offset+=2,t}readInt32(){var t=this._data.getInt32(this.offset,this.littleEndian);return this.offset+=4,t}readUint32(){var t=this._data.getUint32(this.offset,this.littleEndian);return this.offset+=4,t}readFloat32(){var t=this._data.getFloat32(this.offset,this.littleEndian);return this.offset+=4,t}readFloat64(){var t=this._data.getFloat64(this.offset,this.littleEndian);return this.offset+=8,t}readChar(){return String.fromCharCode(this.readInt8())}readChars(t){t===void 0&&(t=1),charArray.length=t;for(var e=0;e<t;e++)charArray[e]=this.readChar();return charArray.join("")}writeBoolean(t){this.writeUint8(t?255:0)}writeInt8(t){this.ensureAvailable(1),this._data.setInt8(this.offset++,t)}writeUint8(t){this.ensureAvailable(1),this._data.setUint8(this.offset++,t)}writeByte(t){this.writeUint8(t)}writeBytes(t){this.ensureAvailable(t.length);for(var e=0;e<t.length;e++)this._data.setUint8(this.offset++,t[e])}writeInt16(t){this.ensureAvailable(2),this._data.setInt16(this.offset,t,this.littleEndian),this.offset+=2}writeUint16(t){this.ensureAvailable(2),this._data.setUint16(this.offset,t,this.littleEndian),this.offset+=2}writeInt32(t){this.ensureAvailable(4),this._data.setInt32(this.offset,t,this.littleEndian),this.offset+=4}writeUint32(t){this.ensureAvailable(4),this._data.setUint32(this.offset,t,this.littleEndian),this.offset+=4}writeFloat32(t){this.ensureAvailable(4),this._data.setFloat32(this.offset,t,this.littleEndian),this.offset+=4}writeFloat64(t){this.ensureAvailable(8),this._data.setFloat64(this.offset,t,this.littleEndian),this.offset+=8}writeChar(t){this.writeUint8(t.charCodeAt(0))}writeChars(t){for(var e=0;e<t.length;e++)this.writeUint8(t.charCodeAt(e))}toArray(){return new Uint8Array(this.buffer,0,this.offset)}};var IOBuffer_1=IOBuffer$2,src$4={};const tagsById$5={254:"NewSubfileType",255:"SubfileType",256:"ImageWidth",257:"ImageLength",258:"BitsPerSample",259:"Compression",262:"PhotometricInterpretation",263:"Threshholding",264:"CellWidth",265:"CellLength",266:"FillOrder",270:"ImageDescription",271:"Make",272:"Model",273:"StripOffsets",274:"Orientation",277:"SamplesPerPixel",278:"RowsPerStrip",279:"StripByteCounts",280:"MinSampleValue",281:"MaxSampleValue",282:"XResolution",283:"YResolution",284:"PlanarConfiguration",288:"FreeOffsets",289:"FreeByteCounts",290:"GrayResponseUnit",291:"GrayResponseCurve",296:"ResolutionUnit",305:"Software",306:"DateTime",315:"Artist",316:"HostComputer",320:"ColorMap",338:"ExtraSamples",33432:"Copyright",269:"DocumentName",285:"PageName",286:"XPosition",287:"YPosition",292:"T4Options",293:"T6Options",297:"PageNumber",301:"TransferFunction",317:"Predictor",318:"WhitePoint",319:"PrimaryChromaticities",321:"HalftoneHints",322:"TileWidth",323:"TileLength",324:"TileOffsets",325:"TileByteCounts",326:"BadFaxLines",327:"CleanFaxData",328:"ConsecutiveBadFaxLines",330:"SubIFDs",332:"InkSet",333:"InkNames",334:"NumberOfInks",336:"DotRange",337:"TargetPrinter",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",342:"TransferRange",343:"ClipPath",344:"XClipPathUnits",345:"YClipPathUnits",346:"Indexed",347:"JPEGTables",351:"OPIProxy",400:"GlobalParametersIFD",401:"ProfileType",402:"FaxProfile",403:"CodingMethods",404:"VersionYear",405:"ModeNumber",433:"Decode",434:"DefaultImageColor",512:"JPEGProc",513:"JPEGInterchangeFormat",514:"JPEGInterchangeFormatLength",515:"JPEGRestartInterval",517:"JPEGLosslessPredictors",518:"JPEGPointTransforms",519:"JPEGQTables",520:"JPEGDCTables",521:"JPEGACTables",529:"YCbCrCoefficients",530:"YCbCrSubSampling",531:"YCbCrPositioning",532:"ReferenceBlackWhite",559:"StripRowCounts",700:"XMP",32781:"ImageID",34732:"ImageLayer",32932:"WangAnnotatio",33445:"MDFileTag",33446:"MDScalePixel",33447:"MDColorTable",33448:"MDLabName",33449:"MDSampleInfo",33450:"MDPrepDate",33451:"MDPrepTime",33452:"MDFileUnits",33550:"ModelPixelScaleTag",33723:"IPTC",33918:"INGRPacketDataTag",33919:"INGRFlagRegisters",33920:"IrasBTransformationMatrix",33922:"ModelTiepointTag",34264:"ModelTransformationTag",34377:"Photoshop",34665:"ExifIFD",34675:"ICCProfile",34735:"GeoKeyDirectoryTag",34736:"GeoDoubleParamsTag",34737:"GeoAsciiParamsTag",34853:"GPSIFD",34908:"HylaFAXFaxRecvParams",34909:"HylaFAXFaxSubAddress",34910:"HylaFAXFaxRecvTime",37724:"ImageSourceData",40965:"InteroperabilityIFD",42112:"GDAL_METADATA",42113:"GDAL_NODATA",50215:"OceScanjobDescription",50216:"OceApplicationSelector",50217:"OceIdentificationNumber",50218:"OceImageLogicCharacteristics",50706:"DNGVersion",50707:"DNGBackwardVersion",50708:"UniqueCameraModel",50709:"LocalizedCameraModel",50710:"CFAPlaneColor",50711:"CFALayout",50712:"LinearizationTable",50713:"BlackLevelRepeatDim",50714:"BlackLevel",50715:"BlackLevelDeltaH",50716:"BlackLevelDeltaV",50717:"WhiteLevel",50718:"DefaultScale",50719:"DefaultCropOrigin",50720:"DefaultCropSize",50721:"ColorMatrix1",50722:"ColorMatrix2",50723:"CameraCalibration1",50724:"CameraCalibration2",50725:"ReductionMatrix1",50726:"ReductionMatrix2",50727:"AnalogBalance",50728:"AsShotNeutral",50729:"AsShotWhiteXY",50730:"BaselineExposure",50731:"BaselineNoise",50732:"BaselineSharpness",50733:"BayerGreenSplit",50734:"LinearResponseLimit",50735:"CameraSerialNumber",50736:"LensInfo",50737:"ChromaBlurRadius",50738:"AntiAliasStrength",50740:"DNGPrivateData",50741:"MakerNoteSafety",50778:"CalibrationIlluminant1",50779:"CalibrationIlluminant2",50780:"BestQualityScale",50784:"AliasLayerMetadata"},tagsByName$5={};for(var i$2 in tagsById$5)tagsByName$5[tagsById$5[i$2]]=i$2;var standard$1={tagsById:tagsById$5,tagsByName:tagsByName$5};const tagsById$4={33434:"ExposureTime",33437:"FNumber",34850:"ExposureProgram",34852:"SpectralSensitivity",34855:"ISOSpeedRatings",34856:"OECF",34864:"SensitivityType",34865:"StandardOutputSensitivity",34866:"RecommendedExposureIndex",34867:"ISOSpeed",34868:"ISOSpeedLatitudeyyy",34869:"ISOSpeedLatitudezzz",36864:"ExifVersion",36867:"DateTimeOriginal",36868:"DateTimeDigitized",37121:"ComponentsConfiguration",37122:"CompressedBitsPerPixel",37377:"ShutterSpeedValue",37378:"ApertureValue",37379:"BrightnessValue",37380:"ExposureBiasValue",37381:"MaxApertureValue",37382:"SubjectDistance",37383:"MeteringMode",37384:"LightSource",37385:"Flash",37386:"FocalLength",37396:"SubjectArea",37500:"MakerNote",37510:"UserComment",37520:"SubsecTime",37521:"SubsecTimeOriginal",37522:"SubsecTimeDigitized",40960:"FlashpixVersion",40961:"ColorSpace",40962:"PixelXDimension",40963:"PixelYDimension",40964:"RelatedSoundFile",41483:"FlashEnergy",41484:"SpatialFrequencyResponse",41486:"FocalPlaneXResolution",41487:"FocalPlaneYResolution",41488:"FocalPlaneResolutionUnit",41492:"SubjectLocation",41493:"ExposureIndex",41495:"SensingMethod",41728:"FileSource",41729:"SceneType",41730:"CFAPattern",41985:"CustomRendered",41986:"ExposureMode",41987:"WhiteBalance",41988:"DigitalZoomRatio",41989:"FocalLengthIn35mmFilm",41990:"SceneCaptureType",41991:"GainControl",41992:"Contrast",41993:"Saturation",41994:"Sharpness",41995:"DeviceSettingDescription",41996:"SubjectDistanceRange",42016:"ImageUniqueID",42032:"CameraOwnerName",42033:"BodySerialNumber",42034:"LensSpecification",42035:"LensMake",42036:"LensModel",42037:"LensSerialNumber",42240:"Gamma"},tagsByName$4={};for(var i$1 in tagsById$4)tagsByName$4[tagsById$4[i$1]]=i$1;var exif$1={tagsById:tagsById$4,tagsByName:tagsByName$4};const tagsById$3={0:"GPSVersionID",1:"GPSLatitudeRef",2:"GPSLatitude",3:"GPSLongitudeRef",4:"GPSLongitude",5:"GPSAltitudeRef",6:"GPSAltitude",7:"GPSTimeStamp",8:"GPSSatellites",9:"GPSStatus",10:"GPSMeasureMode",11:"GPSDOP",12:"GPSSpeedRef",13:"GPSSpeed",14:"GPSTrackRef",15:"GPSTrack",16:"GPSImgDirectionRef",17:"GPSImgDirection",18:"GPSMapDatum",19:"GPSDestLatitudeRef",20:"GPSDestLatitude",21:"GPSDestLongitudeRef",22:"GPSDestLongitude",23:"GPSDestBearingRef",24:"GPSDestBearing",25:"GPSDestDistanceRef",26:"GPSDestDistance",27:"GPSProcessingMethod",28:"GPSAreaInformation",29:"GPSDateStamp",30:"GPSDifferential",31:"GPSHPositioningError"},tagsByName$3={};for(var i in tagsById$3)tagsByName$3[tagsById$3[i]]=i;var gps$1={tagsById:tagsById$3,tagsByName:tagsByName$3};const tags$1={standard:standard$1,exif:exif$1,gps:gps$1};let IFD$2=class{constructor(t){if(!t)throw new Error("missing kind");this.data=null,this.fields=new Map,this.kind=t,this._map=null}get(t){if(typeof t=="number")return this.fields.get(t);if(typeof t=="string")return this.fields.get(tags$1[this.kind].tagsByName[t]);throw new Error("expected a number or string")}get map(){if(!this._map){this._map={};const e=tags$1[this.kind].tagsById;for(var t of this.fields.keys())e[t]&&(this._map[e[t]]=this.fields.get(t))}return this._map}};var ifd=IFD$2;const Ifd=ifd,dateTimeRegex$1=/^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})$/;let TiffIfd$1=class extends Ifd{constructor(){super("standard")}get size(){return this.width*this.height}get width(){return this.imageWidth}get height(){return this.imageLength}get components(){return this.samplesPerPixel}get date(){var t=new Date,e=dateTimeRegex$1.exec(this.dateTime);return t.setFullYear(e[1],e[2]-1,e[3]),t.setHours(e[4],e[5],e[6]),t}get newSubfileType(){return this.get(254)}get imageWidth(){return this.get(256)}get imageLength(){return this.get(257)}get bitsPerSample(){return this.get(258)}get compression(){return this.get(259)||1}get type(){return this.get(262)}get fillOrder(){return this.get(266)||1}get documentName(){return this.get(269)}get imageDescription(){return this.get(270)}get stripOffsets(){return alwaysArray$1(this.get(273))}get orientation(){return this.get(274)}get samplesPerPixel(){return this.get(277)}get rowsPerStrip(){return this.get(278)}get stripByteCounts(){return alwaysArray$1(this.get(279))}get minSampleValue(){return this.get(280)||0}get maxSampleValue(){return this.get(281)||Math.pow(2,this.bitsPerSample)-1}get xResolution(){return this.get(282)}get yResolution(){return this.get(283)}get planarConfiguration(){return this.get(284)||1}get resolutionUnit(){return this.get(296)||2}get dateTime(){return this.get(306)}get predictor(){return this.get(317)||1}get sampleFormat(){return this.get(339)||1}get sMinSampleValue(){return this.get(340)||this.minSampleValue}get sMaxSampleValue(){return this.get(341)||this.maxSampleValue}};function alwaysArray$1(o){return typeof o=="number"?[o]:o}var tiffIfd=TiffIfd$1,ifdValue={},types$1=new Map([[1,[1,readByte$1]],[2,[1,readASCII$1]],[3,[2,readShort$1]],[4,[4,readLong$1]],[5,[8,readRational$1]],[6,[1,readSByte$1]],[7,[1,readByte$1]],[8,[2,readSShort$1]],[9,[4,readSLong$1]],[10,[8,readSRational$1]],[11,[4,readFloat$1]],[12,[8,readDouble$1]]]);ifdValue.getByteLength=function(o,t){return types$1.get(o)[0]*t},ifdValue.readData=function(o,t,e){return types$1.get(t)[1](o,e)};function readByte$1(o,t){if(t===1)return o.readUint8();for(var e=new Uint8Array(t),n=0;n<t;n++)e[n]=o.readUint8();return e}function readASCII$1(o,t){for(var e=[],n="",a=0;a<t;a++){var l=String.fromCharCode(o.readUint8());l==="\0"?(e.push(n),n=""):n+=l}return e.length===1?e[0]:e}function readShort$1(o,t){if(t===1)return o.readUint16();for(var e=new Uint16Array(t),n=0;n<t;n++)e[n]=o.readUint16();return e}function readLong$1(o,t){if(t===1)return o.readUint32();for(var e=new Uint32Array(t),n=0;n<t;n++)e[n]=o.readUint32();return e}function readRational$1(o,t){if(t===1)return o.readUint32()/o.readUint32();for(var e=new Array(t),n=0;n<t;n++)e[n]=o.readUint32()/o.readUint32();return e}function readSByte$1(o,t){if(t===1)return o.readInt8();for(var e=new Int8Array(t),n=0;n<t;n++)e[n]=o.readInt8();return e}function readSShort$1(o,t){if(t===1)return o.readInt16();for(var e=new Int16Array(t),n=0;n<t;n++)e[n]=o.readInt16();return e}function readSLong$1(o,t){if(t===1)return o.readInt32();for(var e=new Int32Array(t),n=0;n<t;n++)e[n]=o.readInt32();return e}function readSRational$1(o,t){if(t===1)return o.readInt32()/o.readInt32();for(var e=new Array(t),n=0;n<t;n++)e[n]=o.readInt32()/o.readInt32();return e}function readFloat$1(o,t){if(t===1)return o.readFloat32();for(var e=new Float32Array(t),n=0;n<t;n++)e[n]=o.readFloat32();return e}function readDouble$1(o,t){if(t===1)return o.readFloat64();for(var e=new Float64Array(t),n=0;n<t;n++)e[n]=o.readFloat64();return e}const IOBuffer$1=IOBuffer_1,IFD$1=ifd,TiffIFD=tiffIfd,IFDValue=ifdValue,defaultOptions$d={ignoreImageData:!1,onlyFirst:!1};let TIFFDecoder$2=class extends IOBuffer$1{constructor(t,e){super(t,e),this._nextIFD=0}decode(t){t=Object.assign({},defaultOptions$d,t);const e=[];for(this.decodeHeader();this._nextIFD;)if(e.push(this.decodeIFD(t)),t.onlyFirst)return e[0];return e}decodeHeader(){let t=this.readUint16();if(t===18761)this.setLittleEndian();else if(t===19789)this.setBigEndian();else throw new Error("invalid byte order: 0x"+t.toString(16));if(t=this.readUint16(),t!==42)throw new Error("not a TIFF file");this._nextIFD=this.readUint32()}decodeIFD(t){this.seek(this._nextIFD);var e;t.kind?e=new IFD$1(t.kind):e=new TiffIFD;const n=this.readUint16();for(var a=0;a<n;a++)this.decodeIFDEntry(e);return t.ignoreImageData||this.decodeImageData(e),this._nextIFD=this.readUint32(),e}decodeIFDEntry(t){const e=this.offset,n=this.readUint16(),a=this.readUint16(),l=this.readUint32();if(a<1||a>12){this.skip(4);return}IFDValue.getByteLength(a,l)>4&&this.seek(this.readUint32());const f=IFDValue.readData(this,a,l);if(t.fields.set(n,f),n===34665||n===34853){let g=this.offset,h;n===34665?h="exif":n===34853&&(h="gps"),this._nextIFD=f,t[h]=this.decodeIFD({kind:h,ignoreImageData:!0}),this.offset=g}this.seek(e),this.skip(12)}decodeImageData(t){const e=t.orientation;switch(e&&e!==1&&unsupported$1("orientation",e),t.type){case 1:case 2:this.readStripData(t);break;default:unsupported$1("image type",t.type);break}}readStripData(t){const e=t.width,n=t.height,a=validateBitDepth(t.bitsPerSample),l=t.sampleFormat;let c=e*n;const f=getDataArray$1(c,1,a,l),g=t.compression,p=t.rowsPerStrip*e,s=t.stripOffsets,r=t.stripByteCounts;for(var u=0,d=0;d<s.length;d++){var m=this.getStripData(g,s[d],r[d]),b=c>p?p:c;c-=b,a===8?u=fill8bit$1(f,m,u,b):a===16?u=fill16bit$1(f,m,u,b,this.isLittleEndian()):a===32&&l===3?u=fillFloat32$1(f,m,u,b,this.isLittleEndian()):unsupported$1("bitDepth",a)}t.data=f}getStripData(t,e,n){switch(t){case 1:return new DataView(this.buffer,e,n);case 2:case 32773:return unsupported$1("Compression",t);default:throw new Error("invalid compression: "+t)}}};var tiffDecoder=TIFFDecoder$2;function getDataArray$1(o,t,e,n){return e===8?new Uint8Array(o*t):e===16?new Uint16Array(o*t):e===32&&n===3?new Float32Array(o*t):unsupported$1("bit depth / sample format",e+" / "+n)}function fill8bit$1(o,t,e,n){for(var a=0;a<n;a++)o[e++]=t.getUint8(a);return e}function fill16bit$1(o,t,e,n,a){for(var l=0;l<n*2;l+=2)o[e++]=t.getUint16(l,a);return e}function fillFloat32$1(o,t,e,n,a){for(var l=0;l<n*4;l+=4)o[e++]=t.getFloat32(l,a);return e}function unsupported$1(o,t){throw new Error("Unsupported "+o+": "+t)}function validateBitDepth(o){if(o.length){const e=o;o=e[0];for(var t=0;t<e.length;t++)e[t]!==o&&unsupported$1("bit depth",e)}return o}const TIFFDecoder$1=tiffDecoder;var decode$2=function(t,e){return new TIFFDecoder$1(t,e).decode(e)};src$4.decode=decode$2;const IOBuffer=IOBuffer_1,tiff=src$4;function decode$1(o){const t=new IOBuffer(o),e={};if(t.setBigEndian(),t.readUint16()!==65496)throw new Error("SOI marker not found. Not a valid JPEG file");if(t.readUint16()===65505){t.readUint16();const l=t.readBytes(6);if(l[0]===69&&l[1]===120&&l[2]===105&&l[3]===102&&l[4]===0&&l[5]===0){const c=tiff.decode(t,{onlyFirst:!0,ignoreImageData:!0,offset:t.offset});e.exif=c}}return e}var decode_1=decode$1,decode=decode_1,imageType$2={exports:{}},fileType$1={exports:{}};(function(module){const toBytes=o=>[...o].map(t=>t.charCodeAt(0)),xpiZipFilename=toBytes("META-INF/mozilla.rsa"),oxmlContentTypes=toBytes("[Content_Types].xml"),oxmlRels=toBytes("_rels/.rels");function readUInt64LE(o,t=0){let e=o[t],n=1,a=0;for(;++a<8;)n*=256,e+=o[t+a]*n;return e}const fileType=o=>{if(!(o instanceof Uint8Array||o instanceof ArrayBuffer||Buffer.isBuffer(o)))throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof o}\``);const t=o instanceof Uint8Array?o:new Uint8Array(o);if(!(t&&t.length>1))return null;const e=(a,l)=>{l=Object.assign({offset:0},l);for(let c=0;c<a.length;c++)if(l.mask){if(a[c]!==(l.mask[c]&t[c+l.offset]))return!1}else if(a[c]!==t[c+l.offset])return!1;return!0},n=(a,l)=>e(toBytes(a),l);if(e([255,216,255]))return{ext:"jpg",mime:"image/jpeg"};if(e([137,80,78,71,13,10,26,10]))return{ext:"png",mime:"image/png"};if(e([71,73,70]))return{ext:"gif",mime:"image/gif"};if(e([87,69,66,80],{offset:8}))return{ext:"webp",mime:"image/webp"};if(e([70,76,73,70]))return{ext:"flif",mime:"image/flif"};if((e([73,73,42,0])||e([77,77,0,42]))&&e([67,82],{offset:8}))return{ext:"cr2",mime:"image/x-canon-cr2"};if(e([73,73,42,0])||e([77,77,0,42]))return{ext:"tif",mime:"image/tiff"};if(e([66,77]))return{ext:"bmp",mime:"image/bmp"};if(e([73,73,188]))return{ext:"jxr",mime:"image/vnd.ms-photo"};if(e([56,66,80,83]))return{ext:"psd",mime:"image/vnd.adobe.photoshop"};if(e([80,75,3,4])){if(e([109,105,109,101,116,121,112,101,97,112,112,108,105,99,97,116,105,111,110,47,101,112,117,98,43,122,105,112],{offset:30}))return{ext:"epub",mime:"application/epub+zip"};if(e(xpiZipFilename,{offset:30}))return{ext:"xpi",mime:"application/x-xpinstall"};if(n("mimetypeapplication/vnd.oasis.opendocument.text",{offset:30}))return{ext:"odt",mime:"application/vnd.oasis.opendocument.text"};if(n("mimetypeapplication/vnd.oasis.opendocument.spreadsheet",{offset:30}))return{ext:"ods",mime:"application/vnd.oasis.opendocument.spreadsheet"};if(n("mimetypeapplication/vnd.oasis.opendocument.presentation",{offset:30}))return{ext:"odp",mime:"application/vnd.oasis.opendocument.presentation"};const a=(g,h=0)=>g.findIndex((p,s,r)=>s>=h&&r[s]===80&&r[s+1]===75&&r[s+2]===3&&r[s+3]===4);let l=0,c=!1,f=null;do{const g=l+30;if(c||(c=e(oxmlContentTypes,{offset:g})||e(oxmlRels,{offset:g})),f||(n("word/",{offset:g})?f={ext:"docx",mime:"application/vnd.openxmlformats-officedocument.wordprocessingml.document"}:n("ppt/",{offset:g})?f={ext:"pptx",mime:"application/vnd.openxmlformats-officedocument.presentationml.presentation"}:n("xl/",{offset:g})&&(f={ext:"xlsx",mime:"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"})),c&&f)return f;l=a(t,g)}while(l>=0);if(f)return f}if(e([80,75])&&(t[2]===3||t[2]===5||t[2]===7)&&(t[3]===4||t[3]===6||t[3]===8))return{ext:"zip",mime:"application/zip"};if(e([117,115,116,97,114],{offset:257}))return{ext:"tar",mime:"application/x-tar"};if(e([82,97,114,33,26,7])&&(t[6]===0||t[6]===1))return{ext:"rar",mime:"application/x-rar-compressed"};if(e([31,139,8]))return{ext:"gz",mime:"application/gzip"};if(e([66,90,104]))return{ext:"bz2",mime:"application/x-bzip2"};if(e([55,122,188,175,39,28]))return{ext:"7z",mime:"application/x-7z-compressed"};if(e([120,1]))return{ext:"dmg",mime:"application/x-apple-diskimage"};if(e([51,103,112,53])||e([0,0,0])&&e([102,116,121,112],{offset:4})&&(e([109,112,52,49],{offset:8})||e([109,112,52,50],{offset:8})||e([105,115,111,109],{offset:8})||e([105,115,111,50],{offset:8})||e([109,109,112,52],{offset:8})||e([77,52,86],{offset:8})||e([100,97,115,104],{offset:8})))return{ext:"mp4",mime:"video/mp4"};if(e([77,84,104,100]))return{ext:"mid",mime:"audio/midi"};if(e([26,69,223,163])){const a=t.subarray(4,4100),l=a.findIndex((c,f,g)=>g[f]===66&&g[f+1]===130);if(l!==-1){const c=l+3,f=g=>[...g].every((h,p)=>a[c+p]===h.charCodeAt(0));if(f("matroska"))return{ext:"mkv",mime:"video/x-matroska"};if(f("webm"))return{ext:"webm",mime:"video/webm"}}}if(e([0,0,0,20,102,116,121,112,113,116,32,32])||e([102,114,101,101],{offset:4})||e([102,116,121,112,113,116,32,32],{offset:4})||e([109,100,97,116],{offset:4})||e([109,111,111,118],{offset:4})||e([119,105,100,101],{offset:4}))return{ext:"mov",mime:"video/quicktime"};if(e([82,73,70,70])){if(e([65,86,73],{offset:8}))return{ext:"avi",mime:"video/vnd.avi"};if(e([87,65,86,69],{offset:8}))return{ext:"wav",mime:"audio/vnd.wave"};if(e([81,76,67,77],{offset:8}))return{ext:"qcp",mime:"audio/qcelp"}}if(e([48,38,178,117,142,102,207,17,166,217])){let a=30;do{const l=readUInt64LE(t,a+16);if(e([145,7,220,183,183,169,207,17,142,230,0,192,12,32,83,101],{offset:a})){if(e([64,158,105,248,77,91,207,17,168,253,0,128,95,92,68,43],{offset:a+24}))return{ext:"wma",mime:"audio/x-ms-wma"};if(e([192,239,25,188,77,91,207,17,168,253,0,128,95,92,68,43],{offset:a+24}))return{ext:"wmv",mime:"video/x-ms-asf"};break}a+=l}while(a+24<=t.length);return{ext:"asf",mime:"application/vnd.ms-asf"}}if(e([0,0,1,186])||e([0,0,1,179]))return{ext:"mpg",mime:"video/mpeg"};if(e([102,116,121,112,51,103],{offset:4}))return{ext:"3gp",mime:"video/3gpp"};for(let a=0;a<2&&a<t.length-16;a++){if(e([73,68,51],{offset:a})||e([255,226],{offset:a,mask:[255,226]}))return{ext:"mp3",mime:"audio/mpeg"};if(e([255,228],{offset:a,mask:[255,228]}))return{ext:"mp2",mime:"audio/mpeg"};if(e([255,248],{offset:a,mask:[255,252]}))return{ext:"mp2",mime:"audio/mpeg"};if(e([255,240],{offset:a,mask:[255,252]}))return{ext:"mp4",mime:"audio/mpeg"}}if(e([102,116,121,112,77,52,65],{offset:4}))return{ext:"m4a",mime:"audio/mp4"};if(e([79,112,117,115,72,101,97,100],{offset:28}))return{ext:"opus",mime:"audio/opus"};if(e([79,103,103,83]))return e([128,116,104,101,111,114,97],{offset:28})?{ext:"ogv",mime:"video/ogg"}:e([1,118,105,100,101,111,0],{offset:28})?{ext:"ogm",mime:"video/ogg"}:e([127,70,76,65,67],{offset:28})?{ext:"oga",mime:"audio/ogg"}:e([83,112,101,101,120,32,32],{offset:28})?{ext:"spx",mime:"audio/ogg"}:e([1,118,111,114,98,105,115],{offset:28})?{ext:"ogg",mime:"audio/ogg"}:{ext:"ogx",mime:"application/ogg"};if(e([102,76,97,67]))return{ext:"flac",mime:"audio/x-flac"};if(e([77,65,67,32]))return{ext:"ape",mime:"audio/ape"};if(e([119,118,112,107]))return{ext:"wv",mime:"audio/wavpack"};if(e([35,33,65,77,82,10]))return{ext:"amr",mime:"audio/amr"};if(e([37,80,68,70]))return{ext:"pdf",mime:"application/pdf"};if(e([77,90]))return{ext:"exe",mime:"application/x-msdownload"};if((t[0]===67||t[0]===70)&&e([87,83],{offset:1}))return{ext:"swf",mime:"application/x-shockwave-flash"};if(e([123,92,114,116,102]))return{ext:"rtf",mime:"application/rtf"};if(e([0,97,115,109]))return{ext:"wasm",mime:"application/wasm"};if(e([119,79,70,70])&&(e([0,1,0,0],{offset:4})||e([79,84,84,79],{offset:4})))return{ext:"woff",mime:"font/woff"};if(e([119,79,70,50])&&(e([0,1,0,0],{offset:4})||e([79,84,84,79],{offset:4})))return{ext:"woff2",mime:"font/woff2"};if(e([76,80],{offset:34})&&(e([0,0,1],{offset:8})||e([1,0,2],{offset:8})||e([2,0,2],{offset:8})))return{ext:"eot",mime:"application/vnd.ms-fontobject"};if(e([0,1,0,0,0]))return{ext:"ttf",mime:"font/ttf"};if(e([79,84,84,79,0]))return{ext:"otf",mime:"font/otf"};if(e([0,0,1,0]))return{ext:"ico",mime:"image/x-icon"};if(e([0,0,2,0]))return{ext:"cur",mime:"image/x-icon"};if(e([70,76,86,1]))return{ext:"flv",mime:"video/x-flv"};if(e([37,33]))return{ext:"ps",mime:"application/postscript"};if(e([253,55,122,88,90,0]))return{ext:"xz",mime:"application/x-xz"};if(e([83,81,76,105]))return{ext:"sqlite",mime:"application/x-sqlite3"};if(e([78,69,83,26]))return{ext:"nes",mime:"application/x-nintendo-nes-rom"};if(e([67,114,50,52]))return{ext:"crx",mime:"application/x-google-chrome-extension"};if(e([77,83,67,70])||e([73,83,99,40]))return{ext:"cab",mime:"application/vnd.ms-cab-compressed"};if(e([33,60,97,114,99,104,62,10,100,101,98,105,97,110,45,98,105,110,97,114,121]))return{ext:"deb",mime:"application/x-deb"};if(e([33,60,97,114,99,104,62]))return{ext:"ar",mime:"application/x-unix-archive"};if(e([237,171,238,219]))return{ext:"rpm",mime:"application/x-rpm"};if(e([31,160])||e([31,157]))return{ext:"Z",mime:"application/x-compress"};if(e([76,90,73,80]))return{ext:"lz",mime:"application/x-lzip"};if(e([208,207,17,224,161,177,26,225]))return{ext:"msi",mime:"application/x-msi"};if(e([6,14,43,52,2,5,1,1,13,1,2,1,1,2]))return{ext:"mxf",mime:"application/mxf"};if(e([71],{offset:4})&&(e([71],{offset:192})||e([71],{offset:196})))return{ext:"mts",mime:"video/mp2t"};if(e([66,76,69,78,68,69,82]))return{ext:"blend",mime:"application/x-blender"};if(e([66,80,71,251]))return{ext:"bpg",mime:"image/bpg"};if(e([0,0,0,12,106,80,32,32,13,10,135,10])){if(e([106,112,50,32],{offset:20}))return{ext:"jp2",mime:"image/jp2"};if(e([106,112,120,32],{offset:20}))return{ext:"jpx",mime:"image/jpx"};if(e([106,112,109,32],{offset:20}))return{ext:"jpm",mime:"image/jpm"};if(e([109,106,112,50],{offset:20}))return{ext:"mj2",mime:"image/mj2"}}if(e([70,79,82,77]))return{ext:"aif",mime:"audio/aiff"};if(n("<?xml "))return{ext:"xml",mime:"application/xml"};if(e([66,79,79,75,77,79,66,73],{offset:60}))return{ext:"mobi",mime:"application/x-mobipocket-ebook"};if(e([102,116,121,112],{offset:4})){if(e([109,105,102,49],{offset:8}))return{ext:"heic",mime:"image/heif"};if(e([109,115,102,49],{offset:8}))return{ext:"heic",mime:"image/heif-sequence"};if(e([104,101,105,99],{offset:8})||e([104,101,105,120],{offset:8}))return{ext:"heic",mime:"image/heic"};if(e([104,101,118,99],{offset:8})||e([104,101,118,120],{offset:8}))return{ext:"heic",mime:"image/heic-sequence"}}return e([171,75,84,88,32,49,49,187,13,10,26,10])?{ext:"ktx",mime:"image/ktx"}:e([68,73,67,77],{offset:128})?{ext:"dcm",mime:"application/dicom"}:e([77,80,43])?{ext:"mpc",mime:"audio/x-musepack"}:e([77,80,67,75])?{ext:"mpc",mime:"audio/x-musepack"}:e([66,69,71,73,78,58])?{ext:"ics",mime:"text/calendar"}:e([103,108,84,70,2,0,0,0])?{ext:"glb",mime:"model/gltf-binary"}:e([212,195,178,161])||e([161,178,195,212])?{ext:"pcap",mime:"application/vnd.tcpdump.pcap"}:null};module.exports=fileType,module.exports.default=fileType,Object.defineProperty(fileType,"minimumBytes",{value:4100}),module.exports.stream=readableStream=>new Promise((resolve,reject)=>{const stream=eval("require")("stream");readableStream.once("readable",()=>{const o=new stream.PassThrough,t=readableStream.read(module.exports.minimumBytes)||readableStream.read();try{o.fileType=fileType(t)}catch(e){reject(e)}readableStream.unshift(t),stream.pipeline?resolve(stream.pipeline(readableStream,o,()=>{})):resolve(readableStream.pipe(o))})})})(fileType$1);var fileTypeExports=fileType$1.exports;const fileType=fileTypeExports,imageExts=new Set(["jpg","png","gif","webp","flif","cr2","tif","bmp","jxr","psd","ico","bpg","jp2","jpm","jpx","heic","cur","dcm"]),imageType=o=>{const t=fileType(o);return imageExts.has(t&&t.ext)?t:null};imageType$2.exports=imageType,imageType$2.exports.default=imageType,Object.defineProperty(imageType,"minimumBytes",{value:fileType.minimumBytes});var imageTypeExports=imageType$2.exports,imageType$1=getDefaultExportFromCjs(imageTypeExports);function guessStripByteCounts(o){if(o.compression!==1)throw new Error("missing mandatory StripByteCounts field in compressed image");const t=o.rowsPerStrip*o.width*o.samplesPerPixel*(o.bitsPerSample/8);return new Array(o.stripOffsets.length).fill(t)}function applyHorizontalDifferencing8Bit(o,t,e){let n=0;for(;n<o.length;){for(let a=e;a<t*e;a+=e)for(let l=0;l<e;l++)o[n+a+l]=o[n+a+l]+o[n+a-(e-l)]&255;n+=t*e}}function applyHorizontalDifferencing16Bit(o,t,e){let n=0;for(;n<o.length;){for(let a=e;a<t*e;a+=e)for(let l=0;l<e;l++)o[n+a+l]=o[n+a+l]+o[n+a-(e-l)]&65535;n+=t*e}}const tagsById$2={33434:"ExposureTime",33437:"FNumber",34850:"ExposureProgram",34852:"SpectralSensitivity",34855:"ISOSpeedRatings",34856:"OECF",34864:"SensitivityType",34865:"StandardOutputSensitivity",34866:"RecommendedExposureIndex",34867:"ISOSpeed",34868:"ISOSpeedLatitudeyyy",34869:"ISOSpeedLatitudezzz",36864:"ExifVersion",36867:"DateTimeOriginal",36868:"DateTimeDigitized",37121:"ComponentsConfiguration",37122:"CompressedBitsPerPixel",37377:"ShutterSpeedValue",37378:"ApertureValue",37379:"BrightnessValue",37380:"ExposureBiasValue",37381:"MaxApertureValue",37382:"SubjectDistance",37383:"MeteringMode",37384:"LightSource",37385:"Flash",37386:"FocalLength",37396:"SubjectArea",37500:"MakerNote",37510:"UserComment",37520:"SubsecTime",37521:"SubsecTimeOriginal",37522:"SubsecTimeDigitized",40960:"FlashpixVersion",40961:"ColorSpace",40962:"PixelXDimension",40963:"PixelYDimension",40964:"RelatedSoundFile",41483:"FlashEnergy",41484:"SpatialFrequencyResponse",41486:"FocalPlaneXResolution",41487:"FocalPlaneYResolution",41488:"FocalPlaneResolutionUnit",41492:"SubjectLocation",41493:"ExposureIndex",41495:"SensingMethod",41728:"FileSource",41729:"SceneType",41730:"CFAPattern",41985:"CustomRendered",41986:"ExposureMode",41987:"WhiteBalance",41988:"DigitalZoomRatio",41989:"FocalLengthIn35mmFilm",41990:"SceneCaptureType",41991:"GainControl",41992:"Contrast",41993:"Saturation",41994:"Sharpness",41995:"DeviceSettingDescription",41996:"SubjectDistanceRange",42016:"ImageUniqueID",42032:"CameraOwnerName",42033:"BodySerialNumber",42034:"LensSpecification",42035:"LensMake",42036:"LensModel",42037:"LensSerialNumber",42240:"Gamma"},tagsByName$2={};for(let o in tagsById$2)tagsByName$2[tagsById$2[o]]=Number(o);var exif=Object.freeze({__proto__:null,tagsById:tagsById$2,tagsByName:tagsByName$2});const tagsById$1={0:"GPSVersionID",1:"GPSLatitudeRef",2:"GPSLatitude",3:"GPSLongitudeRef",4:"GPSLongitude",5:"GPSAltitudeRef",6:"GPSAltitude",7:"GPSTimeStamp",8:"GPSSatellites",9:"GPSStatus",10:"GPSMeasureMode",11:"GPSDOP",12:"GPSSpeedRef",13:"GPSSpeed",14:"GPSTrackRef",15:"GPSTrack",16:"GPSImgDirectionRef",17:"GPSImgDirection",18:"GPSMapDatum",19:"GPSDestLatitudeRef",20:"GPSDestLatitude",21:"GPSDestLongitudeRef",22:"GPSDestLongitude",23:"GPSDestBearingRef",24:"GPSDestBearing",25:"GPSDestDistanceRef",26:"GPSDestDistance",27:"GPSProcessingMethod",28:"GPSAreaInformation",29:"GPSDateStamp",30:"GPSDifferential",31:"GPSHPositioningError"},tagsByName$1={};for(let o in tagsById$1)tagsByName$1[tagsById$1[o]]=Number(o);var gps=Object.freeze({__proto__:null,tagsById:tagsById$1,tagsByName:tagsByName$1});const tagsById={254:"NewSubfileType",255:"SubfileType",256:"ImageWidth",257:"ImageLength",258:"BitsPerSample",259:"Compression",262:"PhotometricInterpretation",263:"Threshholding",264:"CellWidth",265:"CellLength",266:"FillOrder",270:"ImageDescription",271:"Make",272:"Model",273:"StripOffsets",274:"Orientation",277:"SamplesPerPixel",278:"RowsPerStrip",279:"StripByteCounts",280:"MinSampleValue",281:"MaxSampleValue",282:"XResolution",283:"YResolution",284:"PlanarConfiguration",288:"FreeOffsets",289:"FreeByteCounts",290:"GrayResponseUnit",291:"GrayResponseCurve",296:"ResolutionUnit",305:"Software",306:"DateTime",315:"Artist",316:"HostComputer",320:"ColorMap",338:"ExtraSamples",33432:"Copyright",269:"DocumentName",285:"PageName",286:"XPosition",287:"YPosition",292:"T4Options",293:"T6Options",297:"PageNumber",301:"TransferFunction",317:"Predictor",318:"WhitePoint",319:"PrimaryChromaticities",321:"HalftoneHints",322:"TileWidth",323:"TileLength",324:"TileOffsets",325:"TileByteCounts",326:"BadFaxLines",327:"CleanFaxData",328:"ConsecutiveBadFaxLines",330:"SubIFDs",332:"InkSet",333:"InkNames",334:"NumberOfInks",336:"DotRange",337:"TargetPrinter",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",342:"TransferRange",343:"ClipPath",344:"XClipPathUnits",345:"YClipPathUnits",346:"Indexed",347:"JPEGTables",351:"OPIProxy",400:"GlobalParametersIFD",401:"ProfileType",402:"FaxProfile",403:"CodingMethods",404:"VersionYear",405:"ModeNumber",433:"Decode",434:"DefaultImageColor",512:"JPEGProc",513:"JPEGInterchangeFormat",514:"JPEGInterchangeFormatLength",515:"JPEGRestartInterval",517:"JPEGLosslessPredictors",518:"JPEGPointTransforms",519:"JPEGQTables",520:"JPEGDCTables",521:"JPEGACTables",529:"YCbCrCoefficients",530:"YCbCrSubSampling",531:"YCbCrPositioning",532:"ReferenceBlackWhite",559:"StripRowCounts",700:"XMP",32781:"ImageID",34732:"ImageLayer",32932:"WangAnnotatio",33445:"MDFileTag",33446:"MDScalePixel",33447:"MDColorTable",33448:"MDLabName",33449:"MDSampleInfo",33450:"MDPrepDate",33451:"MDPrepTime",33452:"MDFileUnits",33550:"ModelPixelScaleTag",33723:"IPTC",33918:"INGRPacketDataTag",33919:"INGRFlagRegisters",33920:"IrasBTransformationMatrix",33922:"ModelTiepointTag",34264:"ModelTransformationTag",34377:"Photoshop",34665:"ExifIFD",34675:"ICCProfile",34735:"GeoKeyDirectoryTag",34736:"GeoDoubleParamsTag",34737:"GeoAsciiParamsTag",34853:"GPSIFD",34908:"HylaFAXFaxRecvParams",34909:"HylaFAXFaxSubAddress",34910:"HylaFAXFaxRecvTime",37724:"ImageSourceData",40965:"InteroperabilityIFD",42112:"GDAL_METADATA",42113:"GDAL_NODATA",50215:"OceScanjobDescription",50216:"OceApplicationSelector",50217:"OceIdentificationNumber",50218:"OceImageLogicCharacteristics",50706:"DNGVersion",50707:"DNGBackwardVersion",50708:"UniqueCameraModel",50709:"LocalizedCameraModel",50710:"CFAPlaneColor",50711:"CFALayout",50712:"LinearizationTable",50713:"BlackLevelRepeatDim",50714:"BlackLevel",50715:"BlackLevelDeltaH",50716:"BlackLevelDeltaV",50717:"WhiteLevel",50718:"DefaultScale",50719:"DefaultCropOrigin",50720:"DefaultCropSize",50721:"ColorMatrix1",50722:"ColorMatrix2",50723:"CameraCalibration1",50724:"CameraCalibration2",50725:"ReductionMatrix1",50726:"ReductionMatrix2",50727:"AnalogBalance",50728:"AsShotNeutral",50729:"AsShotWhiteXY",50730:"BaselineExposure",50731:"BaselineNoise",50732:"BaselineSharpness",50733:"BayerGreenSplit",50734:"LinearResponseLimit",50735:"CameraSerialNumber",50736:"LensInfo",50737:"ChromaBlurRadius",50738:"AntiAliasStrength",50740:"DNGPrivateData",50741:"MakerNoteSafety",50778:"CalibrationIlluminant1",50779:"CalibrationIlluminant2",50780:"BestQualityScale",50784:"AliasLayerMetadata"},tagsByName={};for(let o in tagsById)tagsByName[tagsById[o]]=Number(o);var standard=Object.freeze({__proto__:null,tagsById,tagsByName});const tags={standard,exif,gps};class IFD{constructor(t){if(!t)throw new Error("missing kind");this.data=new Uint8Array,this.fields=new Map,this.kind=t,this._hasMap=!1,this._map={}}get(t){if(typeof t=="number")return this.fields.get(t);if(typeof t=="string")return this.fields.get(tags[this.kind].tagsByName[t]);throw new Error("expected a number or string")}get map(){if(!this._hasMap){const t=tags[this.kind].tagsById;for(let e of this.fields.keys())t[e]&&(this._map[t[e]]=this.fields.get(e));this._hasMap=!0}return this._map}}let types=new Map([[1,[1,readByte]],[2,[1,readASCII]],[3,[2,readShort]],[4,[4,readLong]],[5,[8,readRational]],[6,[1,readSByte]],[7,[1,readByte]],[8,[2,readSShort]],[9,[4,readSLong]],[10,[8,readSRational]],[11,[4,readFloat]],[12,[8,readDouble]]]);function getByteLength(o,t){const e=types.get(o);if(!e)throw new Error(`type not found: ${o}`);return e[0]*t}function readData(o,t,e){const n=types.get(t);if(!n)throw new Error(`type not found: ${t}`);return n[1](o,e)}function readByte(o,t){if(t===1)return o.readUint8();let e=new Uint8Array(t);for(let n=0;n<t;n++)e[n]=o.readUint8();return e}function readASCII(o,t){let e=[],n="";for(let a=0;a<t;a++){let l=String.fromCharCode(o.readUint8());l==="\0"?(e.push(n),n=""):n+=l}return e.length===1?e[0]:e}function readShort(o,t){if(t===1)return o.readUint16();let e=new Uint16Array(t);for(let n=0;n<t;n++)e[n]=o.readUint16();return e}function readLong(o,t){if(t===1)return o.readUint32();let e=new Uint32Array(t);for(let n=0;n<t;n++)e[n]=o.readUint32();return e}function readRational(o,t){if(t===1)return o.readUint32()/o.readUint32();let e=new Array(t);for(let n=0;n<t;n++)e[n]=o.readUint32()/o.readUint32();return e}function readSByte(o,t){if(t===1)return o.readInt8();let e=new Int8Array(t);for(let n=0;n<t;n++)e[n]=o.readInt8();return e}function readSShort(o,t){if(t===1)return o.readInt16();let e=new Int16Array(t);for(let n=0;n<t;n++)e[n]=o.readInt16();return e}function readSLong(o,t){if(t===1)return o.readInt32();let e=new Int32Array(t);for(let n=0;n<t;n++)e[n]=o.readInt32();return e}function readSRational(o,t){if(t===1)return o.readInt32()/o.readInt32();let e=new Array(t);for(let n=0;n<t;n++)e[n]=o.readInt32()/o.readInt32();return e}function readFloat(o,t){if(t===1)return o.readFloat32();let e=new Float32Array(t);for(let n=0;n<t;n++)e[n]=o.readFloat32();return e}function readDouble(o,t){if(t===1)return o.readFloat64();let e=new Float64Array(t);for(let n=0;n<t;n++)e[n]=o.readFloat64();return e}const CLEAR_CODE=256,EOI_CODE=257,TABLE_START=258,MIN_BIT_LENGTH=9;let stringTable=[];function initializeStringTable(){if(stringTable.length===0){for(let t=0;t<256;t++)stringTable.push([t]);const o=[];for(let t=256;t<4096;t++)stringTable.push(o)}}const andTable=[511,1023,2047,4095],bitJumps=[0,0,0,0,0,0,0,0,0,511,1023,2047,4095];class LzwDecoder{constructor(t){this.nextData=0,this.nextBits=0,this.bytePointer=0,this.tableLength=TABLE_START,this.currentBitLength=MIN_BIT_LENGTH,this.stripArray=new Uint8Array(t.buffer,t.byteOffset,t.byteLength),this.outData=new IOBuffer$4(t.byteLength),this.initializeTable()}decode(){let t=0,e=0;for(;(t=this.getNextCode())!==EOI_CODE;)if(t===CLEAR_CODE){if(this.initializeTable(),t=this.getNextCode(),t===EOI_CODE)break;this.writeString(this.stringFromCode(t)),e=t}else if(this.isInTable(t))this.writeString(this.stringFromCode(t)),this.addStringToTable(this.stringFromCode(e).concat(this.stringFromCode(t)[0])),e=t;else{const a=this.stringFromCode(e).concat(this.stringFromCode(e)[0]);this.writeString(a),this.addStringToTable(a),e=t}const n=this.outData.toArray();return new DataView(n.buffer,n.byteOffset,n.byteLength)}initializeTable(){initializeStringTable(),this.tableLength=TABLE_START,this.currentBitLength=MIN_BIT_LENGTH}writeString(t){this.outData.writeBytes(t)}stringFromCode(t){return stringTable[t]}isInTable(t){return t<this.tableLength}addStringToTable(t){if(stringTable[this.tableLength++]=t,stringTable.length>4096)throw stringTable=[],new Error("LZW decoding error. Please open an issue at https://github.com/image-js/tiff/issues/new/choose (include a test image).");this.tableLength===bitJumps[this.currentBitLength]&&this.currentBitLength++}getNextCode(){this.nextData=this.nextData<<8|this.stripArray[this.bytePointer++]&255,this.nextBits+=8,this.nextBits<this.currentBitLength&&(this.nextData=this.nextData<<8|this.stripArray[this.bytePointer++]&255,this.nextBits+=8);const t=this.nextData>>this.nextBits-this.currentBitLength&andTable[this.currentBitLength-9];return this.nextBits-=this.currentBitLength,this.bytePointer>this.stripArray.length?257:t}}function decompressLzw(o){return new LzwDecoder(o).decode()}const dateTimeRegex=/^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})$/;class TiffIfd extends IFD{constructor(){super("standard")}get size(){return this.width*this.height}get width(){return this.imageWidth}get height(){return this.imageLength}get components(){return this.samplesPerPixel}get date(){let t=new Date,e=dateTimeRegex.exec(this.dateTime);if(e===null)throw new Error(`invalid dateTime: ${this.dateTime}`);return t.setFullYear(Number(e[1]),Number(e[2])-1,Number(e[3])),t.setHours(Number(e[4]),Number(e[5]),Number(e[6])),t}get newSubfileType(){return this.get("NewSubfileType")}get imageWidth(){return this.get("ImageWidth")}get imageLength(){return this.get("ImageLength")}get bitsPerSample(){const t=this.get("BitsPerSample");return t&&typeof t!="number"?t[0]:t}get alpha(){const t=this.extraSamples;return t?t[0]!==0:!1}get associatedAlpha(){const t=this.extraSamples;return t?t[0]===1:!1}get extraSamples(){return alwaysArray(this.get("ExtraSamples"))}get compression(){return this.get("Compression")||1}get type(){return this.get("PhotometricInterpretation")}get fillOrder(){return this.get("FillOrder")||1}get documentName(){return this.get("DocumentName")}get imageDescription(){return this.get("ImageDescription")}get stripOffsets(){return alwaysArray(this.get("StripOffsets"))}get orientation(){return this.get("Orientation")}get samplesPerPixel(){return this.get("SamplesPerPixel")||1}get rowsPerStrip(){return this.get("RowsPerStrip")}get stripByteCounts(){return alwaysArray(this.get("StripByteCounts"))}get minSampleValue(){return this.get("MinSampleValue")||0}get maxSampleValue(){return this.get("MaxSampleValue")||Math.pow(2,this.bitsPerSample)-1}get xResolution(){return this.get("XResolution")}get yResolution(){return this.get("YResolution")}get planarConfiguration(){return this.get("PlanarConfiguration")||1}get resolutionUnit(){return this.get("ResolutionUnit")||2}get dateTime(){return this.get("DateTime")}get predictor(){return this.get("Predictor")||1}get sampleFormat(){return this.get("SampleFormat")||1}get sMinSampleValue(){return this.get("SMinSampleValue")||this.minSampleValue}get sMaxSampleValue(){return this.get("SMaxSampleValue")||this.maxSampleValue}get palette(){const t=2**this.bitsPerSample,e=this.get("ColorMap");if(!e)return;if(e.length!==3*t)throw new Error(`ColorMap size must be ${t}`);const n=[];for(let a=0;a<t;a++)n.push([e[a],e[a+t],e[a+2*t]]);return n}}function alwaysArray(o){return typeof o=="number"?[o]:o}function decompressZlib(o){const t=new Uint8Array(o.buffer,o.byteOffset,o.byteLength),e=inflate_1(t);return new DataView(e.buffer,e.byteOffset,e.byteLength)}const defaultOptions$c={ignoreImageData:!1,onlyFirst:!1};class TIFFDecoder extends IOBuffer$4{constructor(t){super(t),this._nextIFD=0}get isMultiPage(){let t=0;for(this.decodeHeader();this._nextIFD;)if(t++,this.decodeIFD({ignoreImageData:!0},!0),t===2)return!0;if(t===1)return!1;throw unsupported("ifdCount",t)}get pageCount(){let t=0;for(this.decodeHeader();this._nextIFD;)t++,this.decodeIFD({ignoreImageData:!0},!0);if(t>0)return t;throw unsupported("ifdCount",t)}decode(t={}){t=Object.assign({},defaultOptions$c,t);const e=[];for(this.decodeHeader();this._nextIFD;)if(e.push(this.decodeIFD(t,!0)),t.onlyFirst)return[e[0]];return e}decodeHeader(){const t=this.readUint16();if(t===18761)this.setLittleEndian();else if(t===19789)this.setBigEndian();else throw new Error(`invalid byte order: 0x${t.toString(16)}`);if(this.readUint16()!==42)throw new Error("not a TIFF file");this._nextIFD=this.readUint32()}decodeIFD(t,e){this.seek(this._nextIFD);let n;if(e)n=new TiffIfd;else{if(!t.kind)throw new Error("kind is missing");n=new IFD(t.kind)}const a=this.readUint16();for(let l=0;l<a;l++)this.decodeIFDEntry(n);if(!t.ignoreImageData){if(!(n instanceof TiffIfd))throw new Error("must be a tiff ifd");this.decodeImageData(n)}return this._nextIFD=this.readUint32(),n}decodeIFDEntry(t){const e=this.offset,n=this.readUint16(),a=this.readUint16(),l=this.readUint32();if(a<1||a>12){this.skip(4);return}getByteLength(a,l)>4&&this.seek(this.readUint32());const f=readData(this,a,l);if(t.fields.set(n,f),n===34665||n===34853){let g=this.offset,h="exif";n===34665?h="exif":n===34853&&(h="gps"),this._nextIFD=f,t[h]=this.decodeIFD({kind:h,ignoreImageData:!0},!1),this.offset=g}this.seek(e),this.skip(12)}decodeImageData(t){const e=t.orientation;if(e&&e!==1)throw unsupported("orientation",e);switch(t.type){case 0:case 1:case 2:case 3:this.readStripData(t);break;default:throw unsupported("image type",t.type)}if(this.applyPredictor(t),this.convertAlpha(t),t.type===0){const n=t.bitsPerSample,a=Math.pow(2,n)-1;for(let l=0;l<t.data.length;l++)t.data[l]=a-t.data[l]}}readStripData(t){const e=t.width,n=t.height,a=t.bitsPerSample,l=t.sampleFormat,c=e*n*t.samplesPerPixel,f=getDataArray(c,a,l),h=t.rowsPerStrip*e*t.samplesPerPixel,p=t.stripOffsets,s=t.stripByteCounts||guessStripByteCounts(t);let r=c,u=0;for(let d=0;d<p.length;d++){let m=new DataView(this.buffer,this.byteOffset+p[d],s[d]),b=r>h?h:r;r-=b;let y=m;switch(t.compression){case 1:break;case 5:{y=decompressLzw(m);break}case 8:{y=decompressZlib(m);break}case 2:throw unsupported("Compression","CCITT Group 3");case 32773:throw unsupported("Compression","PackBits");default:throw unsupported("Compression",t.compression)}u=this.fillUncompressed(a,l,f,y,u,b)}t.data=f}fillUncompressed(t,e,n,a,l,c){if(t===8)return fill8bit(n,a,l,c);if(t===16)return fill16bit(n,a,l,c,this.isLittleEndian());if(t===32&&e===3)return fillFloat32(n,a,l,c,this.isLittleEndian());throw unsupported("bitDepth",t)}applyPredictor(t){const e=t.bitsPerSample;switch(t.predictor){case 1:break;case 2:{if(e===8)applyHorizontalDifferencing8Bit(t.data,t.width,t.components);else if(e===16)applyHorizontalDifferencing16Bit(t.data,t.width,t.components);else throw new Error(`Horizontal differencing is only supported for images with a bit depth of ${e}`);break}default:throw new Error(`invalid predictor: ${t.predictor}`)}}convertAlpha(t){if(t.alpha&&t.associatedAlpha){const{data:e,components:n,maxSampleValue:a}=t;for(let l=0;l<e.length;l+=n){const c=e[l+n-1];for(let f=0;f<n-1;f++)e[l+f]=Math.round(e[l+f]*a/c)}}}}function getDataArray(o,t,e){if(t===8)return new Uint8Array(o);if(t===16)return new Uint16Array(o);if(t===32&&e===3)return new Float32Array(o);throw unsupported("bit depth / sample format",`${t} / ${e}`)}function fill8bit(o,t,e,n){for(let a=0;a<n;a++)o[e++]=t.getUint8(a);return e}function fill16bit(o,t,e,n,a){for(let l=0;l<n*2;l+=2)o[e++]=t.getUint16(l,a);return e}function fillFloat32(o,t,e,n,a){for(let l=0;l<n*4;l+=4)o[e++]=t.getFloat32(l,a);return e}function unsupported(o,t){return new Error(`Unsupported ${o}: ${t}`)}function decodeTIFF(o,t){return new TIFFDecoder(o).decode(t)}function matchAndCrop(o={}){let{algorithm:t="matchToPrevious",ignoreBorder:e=[0,0]}=o;this.checkProcessable("matchAndCrop",{bitDepth:[8,16]});let n=t==="matchToPrevious",a=this[0],l=[];l[0]={position:[0,0],image:this[0]};let c=[0,0];for(let r=1;r<this.length;r++){let u=a.getBestMatch(this[r],{border:e});l[r]={position:[u[0]+c[0],u[1]+c[1]],image:this[r]},n&&(c[0]+=u[0],c[1]+=u[1],a=this[r])}let f=0,g=0,h=0,p=0;for(let r=0;r<l.length;r++){let u=l[r];u.position[0]>f&&(f=u.position[0]),u.position[0]<g&&(g=u.position[0]),u.position[1]>h&&(h=u.position[1]),u.position[1]<p&&(p=u.position[1])}g=0-g,p=0-p;for(let r=0;r<l.length;r++){let u=l[r];u.crop=u.image.crop({x:f-u.position[0],y:h-u.position[1],width:a.width-g-f,height:a.height-p-h})}let s=[];for(let r=0;r<l.length;r++)s[r]=l[r].crop;return new Stack(s)}function min$2(){this.checkProcessable("min",{bitDepth:[8,16]});let o=this[0].min;for(let t=1;t<this.length;t++)for(let e=0;e<o.length;e++)o[e]=Math.min(o[e],this[t].min[e]);return o}function max$2(){this.checkProcessable("min",{bitDepth:[8,16]});let o=this[0].max;for(let t=1;t<this.length;t++)for(let e=0;e<o.length;e++)o[e]=Math.max(o[e],this[t].max[e]);return o}function median$2(o){let t=o.reduce((c,f)=>c+f);if(t===0)throw new Error("unreachable");let e=0,n=0,a=t/2,l;for(;;){if(o[e]>0){if(l!==void 0)return(l+e)/2;if(n+=o[e],n>a)return e;n===a&&(l=e)}e++}}function mean$2(o){let t=0,e=0;for(let n=0;n<o.length;n++)t+=o[n],e+=o[n]*n;return t===0?0:e/t}function median$1(){this.checkProcessable("median",{bitDepth:[8,16]});let o=this.getHistograms({maxSlots:this[0].maxValue+1}),t=new Array(o.length);for(let e=0;e<o.length;e++){let n=o[e];t[e]=median$2(n)}return t}function histogram(o){this.checkProcessable("min",{bitDepth:[8,16]});let t=this[0].getHistogram(o);for(let e=1;e<this.length;e++){let n=this[e].getHistogram(o);for(let a=0;a<t.length;a++)t[a]+=n[a]}return t}function histograms(o){this.checkProcessable("min",{bitDepth:[8,16]});let t=this[0].getHistograms(o),e=t[0].length;for(let n=1;n<this.length;n++){let a=this[n].getHistograms(o);for(let l=0;l<t.length;l++)for(let c=0;c<e;c++)t[l][c]+=a[l][c]}return t}function averageImage(){this.checkProcessable("averageImage",{bitDepth:[8,16]});let o=new Uint32Array(this[0].data.length);for(let n=0;n<this.length;n++){let a=this[n];for(let l=0;l<this[0].data.length;l++)o[l]+=a.data[l]}let t=Image$1.createFrom(this[0]),e=t.data;for(let n=0;n<this[0].data.length;n++)e[n]=o[n]/this.length;return t}function maxImage(){this.checkProcessable("max",{bitDepth:[8,16]});let o=Image$1.createFrom(this[0]);o.data.fill(0);for(const t of this)for(let e=0;e<o.data.length;e++)o.data[e]=Math.max(t.data[e],o.data[e]);return o}function minImage(){this.checkProcessable("max",{bitDepth:[8,16]});let o=Image$1.createFrom(this[0]);o.data.fill(o.maxValue);for(const t of this)for(let e=0;e<o.data.length;e++)o.data[e]=Math.min(t.data[e],o.data[e]);return o}function extend$2(o){o.extendMethod("matchAndCrop",matchAndCrop),o.extendMethod("getMin",min$2),o.extendMethod("getMax",max$2),o.extendMethod("getMedian",median$1),o.extendMethod("getHistogram",histogram),o.extendMethod("getHistograms",histograms),o.extendMethod("getAverage",averageImage),o.extendMethod("getAverageImage",averageImage),o.extendMethod("getMaxImage",maxImage),o.extendMethod("getMinImage",minImage)}let computedPropertyDescriptor={configurable:!0,enumerable:!1,get:void 0};class Stack extends Array{constructor(t){if(Array.isArray(t)){super(t.length);for(let e=0;e<t.length;e++)this[e]=t[e]}else typeof t=="number"?super(t):super();this.computed=null}static load(t){return Promise.all(t.map(Image$1.load)).then(e=>new Stack(e))}static extendMethod(t,e,n={}){let{inPlace:a=!1,returnThis:l=!0,partialArgs:c=[]}=n;return a?Stack.prototype[t]=function(...f){this.computed=null;let g=e.apply(this,[...c,...f]);return l?this:g}:Stack.prototype[t]=function(...f){return e.apply(this,[...c,...f])},Stack}static extendProperty(t,e,n={}){let{partialArgs:a=[]}=n;return computedPropertyDescriptor.get=function(){if(this.computed===null)this.computed={};else if(hasOwn(t,this.computed))return this.computed[t];let l=e.apply(this,a);return this.computed[t]=l,l},Object.defineProperty(Stack.prototype,t,computedPropertyDescriptor),Stack}checkProcessable(t,e={}){if(typeof t!="string")throw new TypeError("checkProcessable requires as first parameter the processName (a string)");if(this.size===0)throw new TypeError(`The process: ${t} can not be applied on an empty stack`);this[0].checkProcessable(t,e);for(let n=1;n<this.length;n++){if((e.sameSize===void 0||e.sameSize)&&this[0].width!==this[n].width)throw new TypeError(`The process: ${t} can not be applied if width is not identical in all images`);if((e.sameSize===void 0||e.sameSize)&&this[0].height!==this[n].height)throw new TypeError(`The process: ${t} can not be applied if height is not identical in all images`);if((e.sameAlpha===void 0||e.sameAlpha)&&this[0].alpha!==this[n].alpha)throw new TypeError(`The process: ${t} can not be applied if alpha is not identical in all images`);if((e.sameBitDepth===void 0||e.sameBitDepth)&&this[0].bitDepth!==this[n].bitDepth)throw new TypeError(`The process: ${t} can not be applied if bitDepth is not identical in all images`);if((e.sameColorModel===void 0||e.sameColorModel)&&this[0].colorModel!==this[n].colorModel)throw new TypeError(`The process: ${t} can not be applied if colorModel is not identical in all images`);if((e.sameNumberChannels===void 0||e.sameNumberChannels)&&this[0].channels!==this[n].channels)throw new TypeError(`The process: ${t} can not be applied if channels is not identical in all images`)}}}Array[Symbol.species]||(Stack.prototype.map=function(o,t){if(typeof o!="function")throw new TypeError(`${o} is not a function`);let e=new Stack(this.length);for(let n=0;n<this.length;n++)e[n]=o.call(t,this[n],n,this);return e}),extend$2(Stack);const isDataURL=/^data:[a-z]+\/(?:[a-z]+);base64,/;function load(o,t){if(typeof o=="string")return loadURL(o,t);if(o instanceof ArrayBuffer)return Promise.resolve(loadBinary(new Uint8Array(o),void 0,t&&t.ignorePalette));if(o.buffer)return Promise.resolve(loadBinary(o,void 0,t&&t.ignorePalette));throw new Error('argument to "load" must be a string or buffer.')}function loadBinary(o,t,e){const n=imageType$1(o);if(n)switch(n.mime){case"image/png":return loadPNG(o);case"image/jpeg":return loadJPEG(o);case"image/tiff":return loadTIFF(o,e);default:return loadGeneric(a(n.mime))}return loadGeneric(a("application/octet-stream"));function a(l){return t||toBase64URL(o,l)}}function loadURL(o,t){const e=o.slice(0,64).match(isDataURL);let n;return e!==null?n=Promise.resolve(decode$3(o.slice(e[0].length))):n=fetchBinary(o,t),n.then(a=>{const l=new Uint8Array(a);return loadBinary(l,e?o:void 0,t&&t.ignorePalette)})}function loadPNG(o){const t=decodePng(o);let e=t.channels,n,a=0;return e===2||e===4?(n=e-1,a=1):n=e,t.palette?loadPNGFromPalette(t):new Image$1(t.width,t.height,t.data,{components:n,alpha:a,bitDepth:t.depth})}function loadPNGFromPalette(o){const t=o.width*o.height,e=o.palette[0].length,n=new Uint8Array(t*e),a=8/o.depth,l=o.depth<8?a:1,c=parseInt("1".repeat(o.depth),2),f=e===4;let g=0;for(let h=0;h<t;h++){const p=Math.floor(h/l);let s=o.data[p];o.depth<8&&(s=s>>>o.depth*(a-1-h%a)&c);const r=o.palette[s];n[g++]=r[0],n[g++]=r[1],n[g++]=r[2],f&&(n[g++]=r[3])}return new Image$1(o.width,o.height,n,{components:3,alpha:f,bitDepth:8})}function loadJPEG(o){const t=decode(o);let e;t.exif&&(e=getMetadata(t.exif));const n=jpegJs.decode(o,{useTArray:!0,maxMemoryUsageInMB:1024});let a=new Image$1(n.width,n.height,n.data,{meta:e});if(e&&e.tiff.tags.Orientation){const l=e.tiff.tags.Orientation;l>2&&(a=a.rotate({3:180,4:180,5:90,6:90,7:270,8:270}[l])),[2,4,5,7].includes(l)&&(a=a.flipX())}return a}function loadTIFF(o,t){let e=decodeTIFF(o);return e.length===1?getImageFromIFD(e[0],t):new Stack(e.map(function(n){return getImageFromIFD(n,t)}))}function getMetadata(o){const t={tiff:{fields:o.fields,tags:o.map}};return o.exif&&(t.exif=o.exif),o.gps&&(t.gps=o.gps),t}function getImageFromIFD(o,t){if(!t&&o.type===3){const e=new Uint16Array(3*o.width*o.height),n=o.palette;let a=0;for(let l=0;l<o.data.length;l++){const c=o.data[l],f=n[c];e[a++]=f[0],e[a++]=f[1],e[a++]=f[2]}return new Image$1(o.width,o.height,e,{components:3,alpha:o.alpha,colorModel:RGB$1,bitDepth:16,meta:getMetadata(o)})}else return new Image$1(o.width,o.height,o.data,{components:o.type===2?3:1,alpha:o.alpha,colorModel:o.type===2?RGB$1:GREY$1,bitDepth:o.bitsPerSample.length?o.bitsPerSample[0]:o.bitsPerSample,meta:getMetadata(o)})}function loadGeneric(o,t){return t=t||{},new Promise(function(e,n){let a=new DOMImage;a.onload=function(){let l=a.width,c=a.height,g=createCanvas(l,c).getContext("2d");g.drawImage(a,0,0,l,c);let h=g.getImageData(0,0,l,c).data;e(new Image$1(l,c,h,t))},a.onerror=function(){n(new Error(`Could not load ${o}`))},a.src=o})}const valueMethods={getValueXY(o,t,e){return this.data[(t*this.width+o)*this.channels+e]},setValueXY(o,t,e,n){return this.data[(t*this.width+o)*this.channels+e]=n,this.computed=null,this},getValue(o,t){return this.data[o*this.channels+t]},setValue(o,t,e){return this.data[o*this.channels+t]=e,this.computed=null,this},getPixelXY(o,t){return this.getPixel(t*this.width+o)},setPixelXY(o,t,e){return this.setPixel(t*this.width+o,e)},getPixel(o){const t=new Array(this.channels),e=o*this.channels;for(let n=0;n<this.channels;n++)t[n]=this.data[e+n];return t},setPixel(o,t){const e=o*this.channels;for(let n=0;n<t.length;n++)this.data[e+n]=t[n];return this.computed=null,this}};function setValueMethods(o){for(const t in valueMethods)o.prototype[t]=valueMethods[t]}function getImageParameters(o){return{width:o.width,height:o.height,components:o.components,alpha:o.alpha,colorModel:o.colorModel,bitDepth:o.bitDepth}}function getOutputImage(o,t,e,n={}){const{out:a}=t;if(a===void 0)return n.copy?o.clone():Image$1.createFrom(o,e);{if(!Image$1.isImage(a))throw new TypeError("out must be an Image object");const l=Object.assign(getImageParameters(o),e);for(const c in l)if(a[c]!==l[c])throw new RangeError(`cannot use out. Its ${c} must be "${l[c]}" (found "${a[c]}")`);return a}}function getOutputImageOrInPlace(o,t,e){if(t.inPlace!==void 0&&typeof t.inPlace!="boolean")throw new TypeError("inPlace option must be a boolean");if(t.inPlace){if(t.out!==void 0)throw new TypeError("out option must not be set if inPlace option is true");return o}return getOutputImage(o,t,null,e)}function abs(o={}){this.checkProcessable("abs",{bitDepth:[32]});const t=getOutputImageOrInPlace(this,o);return absolute(this,t),t}function absolute(o,t){for(let e=0;e<o.data.length;e++)t.data[e]=Math.abs(o.data[e])}function copyAlphaChannel(o,t){if(o.alpha===1&&t.alpha===1)for(let e=0;e<o.size;e++)t.data[e*t.channels+t.components]=o.data[e*o.channels+o.components]}function invert(o={}){this.checkProcessable("invert",{bitDepth:[1,8,16]});const t=getOutputImageOrInPlace(this,o);return this.bitDepth===1?invertBinary(this,t):(invertColor(this,t),this!==t&&copyAlphaChannel(this,t)),t}function invertBinary(o,t){for(let e=0;e<o.data.length;e++)t.data[e]=~o.data[e]}function invertColor(o,t){for(let e=0;e<o.data.length;e+=o.channels)for(let n=0;n<o.components;n++)t.data[e+n]=o.maxValue-o.data[e+n]}function flipX(){this.checkProcessable("flipX",{bitDepth:[8,16]});for(let o=0;o<this.height;o++){let t=o*this.width*this.channels;for(let e=0;e<Math.floor(this.width/2);e++){let n=e*this.channels+t,a=(this.width-e-1)*this.channels+t;for(let l=0;l<this.channels;l++){let c=this.data[n+l];this.data[n+l]=this.data[a+l],this.data[a+l]=c}}}return this}function flipY(){this.checkProcessable("flipY",{bitDepth:[8,16]});for(let o=0;o<Math.floor(this.height/2);o++)for(let t=0;t<this.width;t++){let e=t*this.channels+o*this.width*this.channels,n=t*this.channels+(this.height-1-o)*this.channels*this.width;for(let a=0;a<this.channels;a++){let l=this.data[e+a];this.data[e+a]=this.data[n+a],this.data[n+a]=l}}return this}function blurFilter(o={}){const{radius:t=1}=o;if(t<1)throw new Error("radius must be greater than 1");const e=2*t+1,n=new Array(e);for(let a=0;a<e;a++){n[a]=new Array(e);for(let l=0;l<e;l++)n[a][l]=1/(e*e)}return this.convolution(n)}var medianQuickselect_min={exports:{}};(function(o){(function(){function t(a){for(var l=0,c=a.length-1,f=void 0,g=void 0,h=void 0,p=n(l,c);;){if(c<=l)return a[p];if(c==l+1)return a[l]>a[c]&&e(a,l,c),a[p];for(f=n(l,c),a[f]>a[c]&&e(a,f,c),a[l]>a[c]&&e(a,l,c),a[f]>a[l]&&e(a,f,l),e(a,f,l+1),g=l+1,h=c;;){do g++;while(a[l]>a[g]);do h--;while(a[h]>a[l]);if(h<g)break;e(a,g,h)}e(a,l,h),h<=p&&(l=g),h>=p&&(c=h-1)}}var e=function(l,c,f){var g;return g=[l[f],l[c]],l[c]=g[0],l[f]=g[1],g},n=function(l,c){return~~((l+c)/2)};o.exports?o.exports=t:window.median=t})()})(medianQuickselect_min);var medianQuickselect_minExports=medianQuickselect_min.exports,quickSelectMedian=getDefaultExportFromCjs(medianQuickselect_minExports);function validateArrayOfChannels(o,t={}){let{channels:e,allowAlpha:n,defaultAlpha:a}=t;return typeof n!="boolean"&&(n=!0),typeof e>"u"?allChannels(o,a):validateChannels(o,e,n)}function allChannels(o,t){let e=t?o.channels:o.components,n=new Array(e);for(let a=0;a<e;a++)n[a]=a;return n}function validateChannels(o,t,e){Array.isArray(t)||(t=[t]);for(let n=0;n<t.length;n++)t[n]=validateChannel(o,t[n],e);return t}function validateChannel(o,t,e=!0){if(t===void 0)throw new RangeError(`validateChannel : the channel has to be >=0 and <${o.channels}`);if(typeof t=="string"){switch(o.colorModel){case GREY$1:break;case RGB$1:if("rgb".includes(t))switch(t){case"r":t=0;break;case"g":t=1;break;case"b":t=2;break}break;case HSL:if("hsl".includes(t))switch(t){case"h":t=0;break;case"s":t=1;break;case"l":t=2;break}break;case HSV:if("hsv".includes(t))switch(t){case"h":t=0;break;case"s":t=1;break;case"v":t=2;break}break;case CMYK$1:if("cmyk".includes(t))switch(t){case"c":t=0;break;case"m":t=1;break;case"y":t=2;break;case"k":t=3;break}break;default:throw new Error(`Unexpected color model: ${o.colorModel}`)}if(t==="a"){if(!o.alpha)throw new Error("validateChannel : the image does not contain alpha channel");t=o.components}if(typeof t=="string")throw new Error(`validateChannel : undefined channel: ${t}`)}if(t>=o.channels)throw new RangeError(`validateChannel : the channel has to be >=0 and <${o.channels}`);if(!e&&t>=o.components)throw new RangeError("validateChannel : alpha channel may not be selected");return t}function medianFilter(o={}){let{radius:t=1,border:e="copy",channels:n}=o;if(this.checkProcessable("medianFilter",{bitDepth:[8,16]}),t<1)throw new Error("radius must be greater than 0");n=validateArrayOfChannels(this,n);let a=t,l=t,c=Image$1.createFrom(this),f=(a*2+1)*(l*2+1),g=new Array(f);for(let h=0;h<n.length;h++){let p=n[h];for(let s=l;s<this.height-l;s++)for(let r=a;r<this.width-a;r++){let u=0;for(let m=-l;m<=l;m++)for(let b=-a;b<=a;b++){let y=((s+m)*this.width+r+b)*this.channels+p;g[u++]=this.data[y]}let d=(s*this.width+r)*this.channels+p;c.data[d]=quickSelectMedian(g)}}if(this.alpha&&!n.includes(this.channels))for(let h=this.components;h<this.data.length;h=h+this.channels)c.data[h]=this.data[h];return c.setBorder({size:[a,l],algorithm:e}),c}function gaussianFilter(o={}){let{radius:t=1,sigma:e,channels:n,border:a="copy"}=o;this.checkProcessable("gaussian",{bitDepth:[8,16]});const l=getKernel(t,e);return this.convolution([l,l],{border:a,channels:n,algorithm:"separable"})}function getKernel(o,t){const e=o*2+1,n=new Array(e),a=t||((e-1)*.5-1)*.3+.8,l=-.5/(a*a);let c=0;for(let f=0;f<e;f++){const g=f-o,h=Math.exp(l*g*g);n[f]=h,c+=h}for(let f=0;f<e;f++)n[f]/=c;return n}const SOBEL_X=[[-1,0,1],[-2,0,2],[-1,0,1]],SOBEL_Y=[[-1,-2,-1],[0,0,0],[1,2,1]],SCHARR_X=[[3,0,-3],[10,0,-10],[3,0,-3]],SCHARR_Y=[[3,10,3],[0,0,0],[-3,-10,-3]];var src$3={},fftlib={};(function(o){(function(){var t;t=o;var e={release:"0.3.0",date:"2013-03"};t.toString=function(){return"version "+e.release+", released "+e.date};for(var n=0,a=null,l=null,c={init:function(h){if(h!==0&&!(h&h-1))n=h,c._initArray(),c._makeBitReversalTable(),c._makeCosSinTable();else throw new Error("init: radix-2 required")},fft1d:function(h,p){c.fft(h,p,1)},ifft1d:function(h,p){var s=1/n;c.fft(h,p,-1);for(var r=0;r<n;r++)h[r]*=s,p[r]*=s},bt1d:function(h,p){c.fft(h,p,-1)},fft2d:function(h,p){for(var s=[],r=[],u=0,d=0;d<n;d++){u=d*n;for(var m=0;m<n;m++)s[m]=h[m+u],r[m]=p[m+u];c.fft1d(s,r);for(var b=0;b<n;b++)h[b+u]=s[b],p[b+u]=r[b]}for(var y=0;y<n;y++){for(var w=0;w<n;w++)u=y+w*n,s[w]=h[u],r[w]=p[u];c.fft1d(s,r);for(var x=0;x<n;x++)u=y+x*n,h[u]=s[x],p[u]=r[x]}},ifft2d:function(h,p){for(var s=[],r=[],u=0,d=0;d<n;d++){u=d*n;for(var m=0;m<n;m++)s[m]=h[m+u],r[m]=p[m+u];c.ifft1d(s,r);for(var b=0;b<n;b++)h[b+u]=s[b],p[b+u]=r[b]}for(var y=0;y<n;y++){for(var w=0;w<n;w++)u=y+w*n,s[w]=h[u],r[w]=p[u];c.ifft1d(s,r);for(var x=0;x<n;x++)u=y+x*n,h[u]=s[x],p[u]=r[x]}},fft:function(h,p,s){for(var r,u,d,m,b,y,w,x,_,v=n>>2,E=0;E<n;E++)m=a[E],E<m&&(b=h[E],h[E]=h[m],h[m]=b,b=p[E],p[E]=p[m],p[m]=b);for(var I=1;I<n;I<<=1){u=0,r=n/(I<<1);for(var S=0;S<I;S++){y=l[u+v],w=s*l[u];for(var T=S;T<n;T+=I<<1)d=T+I,x=y*h[d]+w*p[d],_=y*p[d]-w*h[d],h[d]=h[T]-x,h[T]+=x,p[d]=p[T]-_,p[T]+=_;u+=r}}},_initArray:function(){typeof Uint32Array<"u"?a=new Uint32Array(n):a=[],typeof Float64Array<"u"?l=new Float64Array(n*1.25):l=[]},_paddingZero:function(){},_makeBitReversalTable:function(){var h=0,p=0,s=0;for(a[0]=0;++h<n;){for(s=n>>1;s<=p;)p-=s,s>>=1;p+=s,a[h]=p}},_makeCosSinTable:function(){var h=n>>1,p=n>>2,s=n>>3,r=h+p,u=Math.sin(Math.PI/n),d=2*u*u,m=Math.sqrt(d*(2-d)),b=l[p]=1,y=l[0]=0;u=2*d;for(var w=1;w<s;w++)b-=d,d+=u*b,y+=m,m-=u*y,l[w]=y,l[p-w]=b;s!==0&&(l[s]=Math.sqrt(.5));for(var x=0;x<p;x++)l[h-x]=l[x];for(var _=0;_<r;_++)l[_+h]=-l[_]}},f=["init","fft1d","ifft1d","fft2d","ifft2d"],g=0;g<f.length;g++)t[f[g]]=c[f[g]];return t.bt=c.bt1d,t.fft=c.fft1d,t.ifft=c.ifft1d,t}).call(commonjsGlobal)})(fftlib);var FFT$1=fftlib,FFTUtils$1={DEBUG:!1,ifft2DArray:function(o,t,e){var n=new Array(t*e),a=t/2,l=(e-1)*2;FFT$1.init(a);for(var c={re:new Array(a),im:new Array(a)},f=0;f<e;f++){for(var g=a-1;g>=0;g--)c.re[g]=o[g*2*e+f],c.im[g]=o[(g*2+1)*e+f];FFT$1.bt(c.re,c.im);for(var g=a-1;g>=0;g--)n[g*2*e+f]=c.re[g],n[(g*2+1)*e+f]=c.im[g]}var h=new Array(a*l);FFT$1.init(l);for(var p={re:new Array(l),im:new Array(l)},s=l*a,g=0;g<t;g+=2){p.re[0]=n[g*e],p.im[0]=n[(g+1)*e];for(var f=1;f<e;f++)p.re[f]=n[g*e+f],p.im[f]=n[(g+1)*e+f],p.re[l-f]=n[g*e+f],p.im[l-f]=-n[(g+1)*e+f];FFT$1.bt(p.re,p.im);for(var r=g/2*l,f=l-1;f>=0;f--)h[r+f]=p.re[f]/s}return h},fft2DArray:function(o,t,e,n){Object.assign({},{inplace:!0});var a=e/2+1,l=t*2,c=new Array(l*a);FFT$1.init(e);for(var f={re:new Array(e),im:new Array(e)},g={re:new Array(e),im:new Array(e)},h={re:new Array(e),im:new Array(e)},p,s,r,u,d,m=0;m<t/2;m++){p=m*2*e,f.re=o.slice(p,p+e),p=(m*2+1)*e,f.im=o.slice(p,p+e),FFT$1.fft1d(f.re,f.im),this.reconstructTwoRealFFT(f,g,h),s=m*4*a,r=(m*4+1)*a,u=(m*4+2)*a,d=(m*4+3)*a;for(var b=a-1;b>=0;b--)c[s+b]=g.re[b],c[r+b]=g.im[b],c[u+b]=h.re[b],c[d+b]=h.im[b]}g=null,h=null;var y=new Array(l*a);FFT$1.init(t);for(var w={re:new Array(t),im:new Array(t)},x=a-1;x>=0;x--){for(var m=t-1;m>=0;m--)w.re[m]=c[m*2*a+x],w.im[m]=c[(m*2+1)*a+x],isNaN(w.re[m])&&(w.re[m]=0),isNaN(w.im[m])&&(w.im[m]=0);FFT$1.fft1d(w.re,w.im);for(var m=t-1;m>=0;m--)y[m*2*a+x]=w.re[m],y[(m*2+1)*a+x]=w.im[m]}return y},reconstructTwoRealFFT:function(o,t,e){var n=o.re.length;t.re[0]=o.re[0],t.im[0]=0,e.re[0]=o.im[0],e.im[0]=0;for(var a,l,c,f,g,h=n/2;h>0;h--)g=n-h,a=.5*(o.re[h]-o.re[g]),l=.5*(o.re[h]+o.re[g]),c=.5*(o.im[h]-o.im[g]),f=.5*(o.im[h]+o.im[g]),t.re[h]=l,t.im[h]=c,t.re[g]=l,t.im[g]=-c,e.re[h]=f,e.im[h]=-a,e.re[g]=f,e.im[g]=a},convolute2DI:function(o,t,e,n){for(var a,l,c=0;c<e/2;c++)for(var f=0;f<n;f++)a=o[c*2*n+f]*t[c*2*n+f]-o[(c*2+1)*n+f]*t[(c*2+1)*n+f],l=o[c*2*n+f]*t[(c*2+1)*n+f]+o[(c*2+1)*n+f]*t[c*2*n+f],o[c*2*n+f]=a,o[(c*2+1)*n+f]=l},convolute:function(o,t,e,n,a){for(var l=new Array(n*e),c=0;c<e*n;c++)l[c]=o[c];l=this.fft2DArray(l,e,n);for(var f=t.length,g=t[0].length,h=new Array(n*e),c=0;c<n*e;c++)h[c]=0;for(var p,s,r=Math.floor((f-1)/2),u=Math.floor((g-1)/2),d=0;d<f;d++){p=(d-r+e)%e;for(var m=0;m<g;m++)s=(m-u+n)%n,h[p*n+s]=t[d][m]}h=this.fft2DArray(h,e,n);var b=e*2,y=n/2+1;return this.convolute2DI(l,h,b,y),this.ifft2DArray(l,b,y)},toRadix2:function(o,t,e){var n,a,l,c,f=e,g=t;if(!(e!==0&&!(e&e-1))){for(f=0;e>>++f;);f=1<<f}if(!(t!==0&&!(t&t-1))){for(g=0;t>>++g;);g=1<<g}if(g==t&&f==e)return{data:o,rows:t,cols:e};var h=new Array(g*f),p=Math.floor((g-t)/2)-t,s=Math.floor((f-e)/2)-e;for(n=0;n<g;n++)for(l=n*f,c=(n-p)%t*e,a=0;a<f;a++)h[l+a]=o[c+(a-s)%e];return{data:h,rows:g,cols:f}},crop:function(o,t,e,n,a,l){if(t==n&&e==a)return o;Object.assign({},l);var c=new Array(a*n),f=Math.floor((t-n)/2),g=Math.floor((e-a)/2),h,p,s,r;for(s=0;s<n;s++)for(h=s*a,p=(s+f)*e,r=0;r<a;r++)c[h+r]=o[p+(r+g)];return c}},FFTUtils_1=FFTUtils$1;src$3.FFTUtils=FFTUtils_1,src$3.FFT=fftlib;var FFTUtils=src$3.FFTUtils;function convolutionFFT(o,t,e){var n=matrix2Array(o),a=n.data,l=Object.assign({normalize:!1,divisor:1,rows:n.rows,cols:n.cols},e),c,f;if(l.rows&&l.cols)c=l.rows,f=l.cols;else throw new Error("Invalid number of rows or columns "+c+" "+f);var g=l.divisor,h,p,s=t.length,r=t[0].length;if(l.normalize)for(g=0,h=0;h<s;h++)for(p=0;p<r;p++)g+=t[h][p];if(g===0)throw new RangeError("convolution: The divisor is equal to zero");var u=FFTUtils.toRadix2(a,c,f),d=FFTUtils.convolute(u.data,t,u.rows,u.cols);if(d=FFTUtils.crop(d,u.rows,u.cols,c,f),g!=0&&g!=1)for(h=0;h<d.length;h++)d[h]/=g;return d}function convolutionDirect(o,t,e){var n=matrix2Array(o),a=n.data,l=Object.assign({normalize:!1,divisor:1,rows:n.rows,cols:n.cols},e),c,f;if(l.rows&&l.cols)c=l.rows,f=l.cols;else throw new Error("Invalid number of rows or columns "+c+" "+f);var g=l.divisor,h=t.length,p=t[0].length,s,r,u,d,m,b,y,w,x;if(l.normalize)for(g=0,s=0;s<h;s++)for(r=0;r<p;r++)g+=t[s][r];if(g===0)throw new RangeError("convolution: The divisor is equal to zero");var _=new Array(c*f),v=Math.floor(h/2),E=Math.floor(p/2);for(d=0;d<c;d++)for(u=0;u<f;u++){for(b=0,r=0;r<h;r++)for(s=0;s<p;s++)y=t[h-r-1][p-s-1],w=(d+r-v+c)%c,x=(u+s-E+f)%f,m=w*f+x,b+=a[m]*y;m=d*f+u,_[m]=b/g}return _}function LoG(o,t,e){var n=1e3;e&&e.factor&&(n=e.factor);var a=new Array(t),l,c,f,g;n*=-1;var h=(t-1)/2,p=2*o*o;for(l=0;l<t;l++)for(a[l]=new Array(t),g=(l-h)*(l-h),c=0;c<t;c++)f=-((c-h)*(c-h)+g)/p,a[l][c]=Math.round(n*(1+f)*Math.exp(f));return a}function matrix2Array(o){var t=o,e,n;if(typeof o[0]!="number"){e=o.length,n=o[0].length,t=new Array(e*n);for(var a=0;a<e;a++)for(var l=0;l<n;l++)t[a*n+l]=o[a][l]}else{var c=Math.sqrt(o.length);Number.isInteger(c)&&(e=c,n=c)}return{data:t,rows:e,cols:n}}var src$2={fft:convolutionFFT,direct:convolutionDirect,kernelFactory:{LoG},matrix2Array},_isFinite=Number.isFinite||function(o){return!(typeof o!="number"||o!==o||o===1/0||o===-1/0)},isFinite$1=_isFinite,isInteger=Number.isInteger||function(o){return typeof o=="number"&&isFinite$1(o)&&Math.floor(o)===o},isInteger$1=getDefaultExportFromCjs(isInteger);function validateKernel(o){let t,e;if(Array.isArray(o))if(Array.isArray(o[0])){if(!(o.length&1)||!(o[0].length&1))throw new RangeError("validateKernel: Kernel rows and columns should be odd numbers");t=Math.floor(o.length/2),e=Math.floor(o[0].length/2)}else{let n=Math.sqrt(o.length);if(isInteger$1(n))e=t=Math.floor(Math.sqrt(o.length)/2);else throw new RangeError("validateKernel: Kernel array should be a square");let a=new Array(n);for(let l=0;l<n;l++){a[l]=new Array(n);for(let c=0;c<n;c++)a[l][c]=o[l*n+c]}o=a}else throw new Error(`validateKernel: Invalid Kernel: ${o}`);return{kernel:o,kWidth:e,kHeight:t}}function clamp(o,t){return Math.round(Math.min(Math.max(o,0),t.maxValue))}function directConvolution(o,t,e){if(e===void 0){const l=o.length+t.length-1;e=new Array(l)}fill(e);for(var n=0;n<o.length;n++)for(var a=0;a<t.length;a++)e[n+a]+=o[n]*t[a];return e}function fill(o){for(var t=0;t<o.length;t++)o[t]=0}function FFT(o){if(this.size=o|0,this.size<=1||this.size&this.size-1)throw new Error("FFT size must be a power of two and bigger than 1");this._csize=o<<1;for(var t=new Array(this.size*2),e=0;e<t.length;e+=2){const g=Math.PI*e/this.size;t[e]=Math.cos(g),t[e+1]=-Math.sin(g)}this.table=t;for(var n=0,a=1;this.size>a;a<<=1)n++;this._width=n%2===0?n-1:n,this._bitrev=new Array(1<<this._width);for(var l=0;l<this._bitrev.length;l++){this._bitrev[l]=0;for(var c=0;c<this._width;c+=2){var f=this._width-c-2;this._bitrev[l]|=(l>>>c&3)<<f}}this._out=null,this._data=null,this._inv=0}FFT.prototype.fromComplexArray=function o(t,e){for(var n=e||new Array(t.length>>>1),a=0;a<t.length;a+=2)n[a>>>1]=t[a];return n},FFT.prototype.createComplexArray=function o(){const t=new Array(this._csize);for(var e=0;e<t.length;e++)t[e]=0;return t},FFT.prototype.toComplexArray=function o(t,e){for(var n=e||this.createComplexArray(),a=0;a<n.length;a+=2)n[a]=t[a>>>1],n[a+1]=0;return n},FFT.prototype.completeSpectrum=function o(t){for(var e=this._csize,n=e>>>1,a=2;a<n;a+=2)t[e-a]=t[a],t[e-a+1]=-t[a+1]},FFT.prototype.transform=function o(t,e){if(t===e)throw new Error("Input and output buffers must be different");this._out=t,this._data=e,this._inv=0,this._transform4(),this._out=null,this._data=null},FFT.prototype.realTransform=function o(t,e){if(t===e)throw new Error("Input and output buffers must be different");this._out=t,this._data=e,this._inv=0,this._realTransform4(),this._out=null,this._data=null},FFT.prototype.inverseTransform=function o(t,e){if(t===e)throw new Error("Input and output buffers must be different");this._out=t,this._data=e,this._inv=1,this._transform4();for(var n=0;n<t.length;n++)t[n]/=this.size;this._out=null,this._data=null},FFT.prototype._transform4=function o(){var t=this._out,e=this._csize,n=this._width,a=1<<n,l=e/a<<1,c,f,g=this._bitrev;if(l===4)for(c=0,f=0;c<e;c+=l,f++){const m=g[f];this._singleTransform2(c,m,a)}else for(c=0,f=0;c<e;c+=l,f++){const m=g[f];this._singleTransform4(c,m,a)}var h=this._inv?-1:1,p=this.table;for(a>>=2;a>=2;a>>=2){l=e/a<<1;var s=l>>>2;for(c=0;c<e;c+=l)for(var r=c+s,u=c,d=0;u<r;u+=2,d+=a){const m=u,b=m+s,y=b+s,w=y+s,x=t[m],_=t[m+1],v=t[b],E=t[b+1],I=t[y],S=t[y+1],T=t[w],A=t[w+1],O=x,$=_,D=p[d],M=h*p[d+1],F=v*D-E*M,C=v*M+E*D,R=p[2*d],j=h*p[2*d+1],G=I*R-S*j,W=I*j+S*R,Z=p[3*d],at=h*p[3*d+1],J=T*Z-A*at,Y=T*at+A*Z,K=O+G,it=$+W,rt=O-G,yt=$-W,ut=F+J,St=C+Y,gt=h*(F-J),Ot=h*(C-Y),pt=K+ut,ct=it+St,ot=K-ut,Mt=it-St,It=rt+Ot,Dt=yt-gt,H=rt-Ot,ft=yt+gt;t[m]=pt,t[m+1]=ct,t[b]=It,t[b+1]=Dt,t[y]=ot,t[y+1]=Mt,t[w]=H,t[w+1]=ft}}},FFT.prototype._singleTransform2=function o(t,e,n){const a=this._out,l=this._data,c=l[e],f=l[e+1],g=l[e+n],h=l[e+n+1],p=c+g,s=f+h,r=c-g,u=f-h;a[t]=p,a[t+1]=s,a[t+2]=r,a[t+3]=u},FFT.prototype._singleTransform4=function o(t,e,n){const a=this._out,l=this._data,c=this._inv?-1:1,f=n*2,g=n*3,h=l[e],p=l[e+1],s=l[e+n],r=l[e+n+1],u=l[e+f],d=l[e+f+1],m=l[e+g],b=l[e+g+1],y=h+u,w=p+d,x=h-u,_=p-d,v=s+m,E=r+b,I=c*(s-m),S=c*(r-b),T=y+v,A=w+E,O=x+S,$=_-I,D=y-v,M=w-E,F=x-S,C=_+I;a[t]=T,a[t+1]=A,a[t+2]=O,a[t+3]=$,a[t+4]=D,a[t+5]=M,a[t+6]=F,a[t+7]=C},FFT.prototype._realTransform4=function o(){var t=this._out,e=this._csize,n=this._width,a=1<<n,l=e/a<<1,c,f,g=this._bitrev;if(l===4)for(c=0,f=0;c<e;c+=l,f++){const z=g[f];this._singleRealTransform2(c,z>>>1,a>>>1)}else for(c=0,f=0;c<e;c+=l,f++){const z=g[f];this._singleRealTransform4(c,z>>>1,a>>>1)}var h=this._inv?-1:1,p=this.table;for(a>>=2;a>=2;a>>=2){l=e/a<<1;var s=l>>>1,r=s>>>1,u=r>>>1;for(c=0;c<e;c+=l)for(var d=0,m=0;d<=u;d+=2,m+=a){var b=c+d,y=b+r,w=y+r,x=w+r,_=t[b],v=t[b+1],E=t[y],I=t[y+1],S=t[w],T=t[w+1],A=t[x],O=t[x+1],$=_,D=v,M=p[m],F=h*p[m+1],C=E*M-I*F,R=E*F+I*M,j=p[2*m],G=h*p[2*m+1],W=S*j-T*G,Z=S*G+T*j,at=p[3*m],J=h*p[3*m+1],Y=A*at-O*J,K=A*J+O*at,it=$+W,rt=D+Z,yt=$-W,ut=D-Z,St=C+Y,gt=R+K,Ot=h*(C-Y),pt=h*(R-K),ct=it+St,ot=rt+gt,Mt=yt+pt,It=ut-Ot;if(t[b]=ct,t[b+1]=ot,t[y]=Mt,t[y+1]=It,d===0){var Dt=it-St,H=rt-gt;t[w]=Dt,t[w+1]=H;continue}if(d!==u){var ft=yt,xt=-ut,_t=it,et=-rt,Ct=-h*pt,Pt=-h*Ot,mt=-h*gt,vt=-h*St,$t=ft+Ct,Tt=xt+Pt,kt=_t+vt,Rt=et-mt,lt=c+r-d,B=c+s-d;t[lt]=$t,t[lt+1]=Tt,t[B]=kt,t[B+1]=Rt}}}},FFT.prototype._singleRealTransform2=function o(t,e,n){const a=this._out,l=this._data,c=l[e],f=l[e+n],g=c+f,h=c-f;a[t]=g,a[t+1]=0,a[t+2]=h,a[t+3]=0},FFT.prototype._singleRealTransform4=function o(t,e,n){const a=this._out,l=this._data,c=this._inv?-1:1,f=n*2,g=n*3,h=l[e],p=l[e+n],s=l[e+f],r=l[e+g],u=h+s,d=h-s,m=p+r,b=c*(p-r),y=u+m,w=d,x=-b,_=u-m,v=d,E=b;a[t]=y,a[t+1]=0,a[t+2]=w,a[t+3]=x,a[t+4]=_,a[t+5]=0,a[t+6]=v,a[t+7]=E};function convolutionSeparable(o,t,e,n){const a=new Array(o.length);let l,c,f,g;g=t[1],f=(g.length-1)/2,c=new Array(e+g.length-1),l=new Array(e);for(let h=0;h<n;h++){for(let p=0;p<e;p++)l[p]=o[h*e+p];directConvolution(l,g,c);for(let p=0;p<e;p++)a[h*e+p]=c[f+p]}g=t[0],f=(g.length-1)/2,c=new Array(n+g.length-1),l=new Array(n);for(let h=0;h<e;h++){for(let p=0;p<n;p++)l[p]=a[p*e+h];directConvolution(l,g,c);for(let p=0;p<n;p++)a[p*e+h]=c[f+p]}return a}const toString$1=Object.prototype.toString;function isAnyArray(o){const t=toString$1.call(o);return t.endsWith("Array]")&&!t.includes("Big")}function max$1(o){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!isAnyArray(o))throw new TypeError("input must be an array");if(o.length===0)throw new TypeError("input must not be empty");var e=t.fromIndex,n=e===void 0?0:e,a=t.toIndex,l=a===void 0?o.length:a;if(n<0||n>=o.length||!Number.isInteger(n))throw new Error("fromIndex must be a positive integer smaller than length");if(l<=n||l>o.length||!Number.isInteger(l))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var c=o[n],f=n+1;f<l;f++)o[f]>c&&(c=o[f]);return c}function min$1(o){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!isAnyArray(o))throw new TypeError("input must be an array");if(o.length===0)throw new TypeError("input must not be empty");var e=t.fromIndex,n=e===void 0?0:e,a=t.toIndex,l=a===void 0?o.length:a;if(n<0||n>=o.length||!Number.isInteger(n))throw new Error("fromIndex must be a positive integer smaller than length");if(l<=n||l>o.length||!Number.isInteger(l))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var c=o[n],f=n+1;f<l;f++)o[f]<c&&(c=o[f]);return c}function rescale(o){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(isAnyArray(o)){if(o.length===0)throw new TypeError("input must not be empty")}else throw new TypeError("input must be an array");var e;if(t.output!==void 0){if(!isAnyArray(t.output))throw new TypeError("output option must be an array if specified");e=t.output}else e=new Array(o.length);var n=min$1(o),a=max$1(o);if(n===a)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var l=t.min,c=l===void 0?t.autoMinMax?n:0:l,f=t.max,g=f===void 0?t.autoMinMax?a:1:f;if(c>=g)throw new RangeError("min option must be smaller than max option");for(var h=(g-c)/(a-n),p=0;p<o.length;p++)e[p]=(o[p]-n)*h+c;return e}const indent=" ".repeat(2),indentData=" ".repeat(4);function inspectMatrix(){return inspectMatrixWithOptions(this)}function inspectMatrixWithOptions(o,t={}){const{maxRows:e=15,maxColumns:n=10,maxNumSize:a=8,padMinus:l="auto"}=t;return`${o.constructor.name} {
${indent}[
${indentData}${inspectData(o,e,n,a,l)}
${indent}]
${indent}rows: ${o.rows}
${indent}columns: ${o.columns}
}`}function inspectData(o,t,e,n,a){const{rows:l,columns:c}=o,f=Math.min(l,t),g=Math.min(c,e),h=[];if(a==="auto"){a=!1;t:for(let p=0;p<f;p++)for(let s=0;s<g;s++)if(o.get(p,s)<0){a=!0;break t}}for(let p=0;p<f;p++){let s=[];for(let r=0;r<g;r++)s.push(formatNumber(o.get(p,r),n,a));h.push(`${s.join(" ")}`)}return g!==c&&(h[h.length-1]+=` ... ${c-e} more columns`),f!==l&&h.push(`... ${l-t} more rows`),h.join(`
${indentData}`)}function formatNumber(o,t,e){return(o>=0&&e?` ${formatNumber2(o,t-1)}`:formatNumber2(o,t)).padEnd(t)}function formatNumber2(o,t){let e=o.toString();if(e.length<=t)return e;let n=o.toFixed(t);if(n.length>t&&(n=o.toFixed(Math.max(0,t-(n.length-t)))),n.length<=t&&!n.startsWith("0.000")&&!n.startsWith("-0.000"))return n;let a=o.toExponential(t);return a.length>t&&(a=o.toExponential(Math.max(0,t-(a.length-t)))),a.slice(0)}function installMathOperations(o,t){o.prototype.add=function(n){return typeof n=="number"?this.addS(n):this.addM(n)},o.prototype.addS=function(n){for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)+n);return this},o.prototype.addM=function(n){if(n=t.checkMatrix(n),this.rows!==n.rows||this.columns!==n.columns)throw new RangeError("Matrices dimensions must be equal");for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)+n.get(a,l));return this},o.add=function(n,a){return new t(n).add(a)},o.prototype.sub=function(n){return typeof n=="number"?this.subS(n):this.subM(n)},o.prototype.subS=function(n){for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)-n);return this},o.prototype.subM=function(n){if(n=t.checkMatrix(n),this.rows!==n.rows||this.columns!==n.columns)throw new RangeError("Matrices dimensions must be equal");for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)-n.get(a,l));return this},o.sub=function(n,a){return new t(n).sub(a)},o.prototype.subtract=o.prototype.sub,o.prototype.subtractS=o.prototype.subS,o.prototype.subtractM=o.prototype.subM,o.subtract=o.sub,o.prototype.mul=function(n){return typeof n=="number"?this.mulS(n):this.mulM(n)},o.prototype.mulS=function(n){for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)*n);return this},o.prototype.mulM=function(n){if(n=t.checkMatrix(n),this.rows!==n.rows||this.columns!==n.columns)throw new RangeError("Matrices dimensions must be equal");for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)*n.get(a,l));return this},o.mul=function(n,a){return new t(n).mul(a)},o.prototype.multiply=o.prototype.mul,o.prototype.multiplyS=o.prototype.mulS,o.prototype.multiplyM=o.prototype.mulM,o.multiply=o.mul,o.prototype.div=function(n){return typeof n=="number"?this.divS(n):this.divM(n)},o.prototype.divS=function(n){for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)/n);return this},o.prototype.divM=function(n){if(n=t.checkMatrix(n),this.rows!==n.rows||this.columns!==n.columns)throw new RangeError("Matrices dimensions must be equal");for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)/n.get(a,l));return this},o.div=function(n,a){return new t(n).div(a)},o.prototype.divide=o.prototype.div,o.prototype.divideS=o.prototype.divS,o.prototype.divideM=o.prototype.divM,o.divide=o.div,o.prototype.mod=function(n){return typeof n=="number"?this.modS(n):this.modM(n)},o.prototype.modS=function(n){for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)%n);return this},o.prototype.modM=function(n){if(n=t.checkMatrix(n),this.rows!==n.rows||this.columns!==n.columns)throw new RangeError("Matrices dimensions must be equal");for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)%n.get(a,l));return this},o.mod=function(n,a){return new t(n).mod(a)},o.prototype.modulus=o.prototype.mod,o.prototype.modulusS=o.prototype.modS,o.prototype.modulusM=o.prototype.modM,o.modulus=o.mod,o.prototype.and=function(n){return typeof n=="number"?this.andS(n):this.andM(n)},o.prototype.andS=function(n){for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)&n);return this},o.prototype.andM=function(n){if(n=t.checkMatrix(n),this.rows!==n.rows||this.columns!==n.columns)throw new RangeError("Matrices dimensions must be equal");for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)&n.get(a,l));return this},o.and=function(n,a){return new t(n).and(a)},o.prototype.or=function(n){return typeof n=="number"?this.orS(n):this.orM(n)},o.prototype.orS=function(n){for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)|n);return this},o.prototype.orM=function(n){if(n=t.checkMatrix(n),this.rows!==n.rows||this.columns!==n.columns)throw new RangeError("Matrices dimensions must be equal");for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)|n.get(a,l));return this},o.or=function(n,a){return new t(n).or(a)},o.prototype.xor=function(n){return typeof n=="number"?this.xorS(n):this.xorM(n)},o.prototype.xorS=function(n){for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)^n);return this},o.prototype.xorM=function(n){if(n=t.checkMatrix(n),this.rows!==n.rows||this.columns!==n.columns)throw new RangeError("Matrices dimensions must be equal");for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)^n.get(a,l));return this},o.xor=function(n,a){return new t(n).xor(a)},o.prototype.leftShift=function(n){return typeof n=="number"?this.leftShiftS(n):this.leftShiftM(n)},o.prototype.leftShiftS=function(n){for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)<<n);return this},o.prototype.leftShiftM=function(n){if(n=t.checkMatrix(n),this.rows!==n.rows||this.columns!==n.columns)throw new RangeError("Matrices dimensions must be equal");for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)<<n.get(a,l));return this},o.leftShift=function(n,a){return new t(n).leftShift(a)},o.prototype.signPropagatingRightShift=function(n){return typeof n=="number"?this.signPropagatingRightShiftS(n):this.signPropagatingRightShiftM(n)},o.prototype.signPropagatingRightShiftS=function(n){for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)>>n);return this},o.prototype.signPropagatingRightShiftM=function(n){if(n=t.checkMatrix(n),this.rows!==n.rows||this.columns!==n.columns)throw new RangeError("Matrices dimensions must be equal");for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)>>n.get(a,l));return this},o.signPropagatingRightShift=function(n,a){return new t(n).signPropagatingRightShift(a)},o.prototype.rightShift=function(n){return typeof n=="number"?this.rightShiftS(n):this.rightShiftM(n)},o.prototype.rightShiftS=function(n){for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)>>>n);return this},o.prototype.rightShiftM=function(n){if(n=t.checkMatrix(n),this.rows!==n.rows||this.columns!==n.columns)throw new RangeError("Matrices dimensions must be equal");for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,this.get(a,l)>>>n.get(a,l));return this},o.rightShift=function(n,a){return new t(n).rightShift(a)},o.prototype.zeroFillRightShift=o.prototype.rightShift,o.prototype.zeroFillRightShiftS=o.prototype.rightShiftS,o.prototype.zeroFillRightShiftM=o.prototype.rightShiftM,o.zeroFillRightShift=o.rightShift,o.prototype.not=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,~this.get(n,a));return this},o.not=function(n){return new t(n).not()},o.prototype.abs=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.abs(this.get(n,a)));return this},o.abs=function(n){return new t(n).abs()},o.prototype.acos=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.acos(this.get(n,a)));return this},o.acos=function(n){return new t(n).acos()},o.prototype.acosh=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.acosh(this.get(n,a)));return this},o.acosh=function(n){return new t(n).acosh()},o.prototype.asin=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.asin(this.get(n,a)));return this},o.asin=function(n){return new t(n).asin()},o.prototype.asinh=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.asinh(this.get(n,a)));return this},o.asinh=function(n){return new t(n).asinh()},o.prototype.atan=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.atan(this.get(n,a)));return this},o.atan=function(n){return new t(n).atan()},o.prototype.atanh=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.atanh(this.get(n,a)));return this},o.atanh=function(n){return new t(n).atanh()},o.prototype.cbrt=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.cbrt(this.get(n,a)));return this},o.cbrt=function(n){return new t(n).cbrt()},o.prototype.ceil=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.ceil(this.get(n,a)));return this},o.ceil=function(n){return new t(n).ceil()},o.prototype.clz32=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.clz32(this.get(n,a)));return this},o.clz32=function(n){return new t(n).clz32()},o.prototype.cos=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.cos(this.get(n,a)));return this},o.cos=function(n){return new t(n).cos()},o.prototype.cosh=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.cosh(this.get(n,a)));return this},o.cosh=function(n){return new t(n).cosh()},o.prototype.exp=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.exp(this.get(n,a)));return this},o.exp=function(n){return new t(n).exp()},o.prototype.expm1=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.expm1(this.get(n,a)));return this},o.expm1=function(n){return new t(n).expm1()},o.prototype.floor=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.floor(this.get(n,a)));return this},o.floor=function(n){return new t(n).floor()},o.prototype.fround=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.fround(this.get(n,a)));return this},o.fround=function(n){return new t(n).fround()},o.prototype.log=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.log(this.get(n,a)));return this},o.log=function(n){return new t(n).log()},o.prototype.log1p=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.log1p(this.get(n,a)));return this},o.log1p=function(n){return new t(n).log1p()},o.prototype.log10=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.log10(this.get(n,a)));return this},o.log10=function(n){return new t(n).log10()},o.prototype.log2=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.log2(this.get(n,a)));return this},o.log2=function(n){return new t(n).log2()},o.prototype.round=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.round(this.get(n,a)));return this},o.round=function(n){return new t(n).round()},o.prototype.sign=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.sign(this.get(n,a)));return this},o.sign=function(n){return new t(n).sign()},o.prototype.sin=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.sin(this.get(n,a)));return this},o.sin=function(n){return new t(n).sin()},o.prototype.sinh=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.sinh(this.get(n,a)));return this},o.sinh=function(n){return new t(n).sinh()},o.prototype.sqrt=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.sqrt(this.get(n,a)));return this},o.sqrt=function(n){return new t(n).sqrt()},o.prototype.tan=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.tan(this.get(n,a)));return this},o.tan=function(n){return new t(n).tan()},o.prototype.tanh=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.tanh(this.get(n,a)));return this},o.tanh=function(n){return new t(n).tanh()},o.prototype.trunc=function(){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.set(n,a,Math.trunc(this.get(n,a)));return this},o.trunc=function(n){return new t(n).trunc()},o.pow=function(n,a){return new t(n).pow(a)},o.prototype.pow=function(n){return typeof n=="number"?this.powS(n):this.powM(n)},o.prototype.powS=function(n){for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,Math.pow(this.get(a,l),n));return this},o.prototype.powM=function(n){if(n=t.checkMatrix(n),this.rows!==n.rows||this.columns!==n.columns)throw new RangeError("Matrices dimensions must be equal");for(let a=0;a<this.rows;a++)for(let l=0;l<this.columns;l++)this.set(a,l,Math.pow(this.get(a,l),n.get(a,l)));return this}}function checkRowIndex(o,t,e){let n=e?o.rows:o.rows-1;if(t<0||t>n)throw new RangeError("Row index out of range")}function checkColumnIndex(o,t,e){let n=e?o.columns:o.columns-1;if(t<0||t>n)throw new RangeError("Column index out of range")}function checkRowVector(o,t){if(t.to1DArray&&(t=t.to1DArray()),t.length!==o.columns)throw new RangeError("vector size must be the same as the number of columns");return t}function checkColumnVector(o,t){if(t.to1DArray&&(t=t.to1DArray()),t.length!==o.rows)throw new RangeError("vector size must be the same as the number of rows");return t}function checkRowIndices(o,t){if(!isAnyArray(t))throw new TypeError("row indices must be an array");for(let e=0;e<t.length;e++)if(t[e]<0||t[e]>=o.rows)throw new RangeError("row indices are out of range")}function checkColumnIndices(o,t){if(!isAnyArray(t))throw new TypeError("column indices must be an array");for(let e=0;e<t.length;e++)if(t[e]<0||t[e]>=o.columns)throw new RangeError("column indices are out of range")}function checkRange(o,t,e,n,a){if(arguments.length!==5)throw new RangeError("expected 4 arguments");if(checkNumber("startRow",t),checkNumber("endRow",e),checkNumber("startColumn",n),checkNumber("endColumn",a),t>e||n>a||t<0||t>=o.rows||e<0||e>=o.rows||n<0||n>=o.columns||a<0||a>=o.columns)throw new RangeError("Submatrix indices are out of range")}function newArray$2(o,t=0){let e=[];for(let n=0;n<o;n++)e.push(t);return e}function checkNumber(o,t){if(typeof t!="number")throw new TypeError(`${o} must be a number`)}function checkNonEmpty(o){if(o.isEmpty())throw new Error("Empty matrix has no elements to index")}function sumByRow(o){let t=newArray$2(o.rows);for(let e=0;e<o.rows;++e)for(let n=0;n<o.columns;++n)t[e]+=o.get(e,n);return t}function sumByColumn(o){let t=newArray$2(o.columns);for(let e=0;e<o.rows;++e)for(let n=0;n<o.columns;++n)t[n]+=o.get(e,n);return t}function sumAll(o){let t=0;for(let e=0;e<o.rows;e++)for(let n=0;n<o.columns;n++)t+=o.get(e,n);return t}function productByRow(o){let t=newArray$2(o.rows,1);for(let e=0;e<o.rows;++e)for(let n=0;n<o.columns;++n)t[e]*=o.get(e,n);return t}function productByColumn(o){let t=newArray$2(o.columns,1);for(let e=0;e<o.rows;++e)for(let n=0;n<o.columns;++n)t[n]*=o.get(e,n);return t}function productAll(o){let t=1;for(let e=0;e<o.rows;e++)for(let n=0;n<o.columns;n++)t*=o.get(e,n);return t}function varianceByRow(o,t,e){const n=o.rows,a=o.columns,l=[];for(let c=0;c<n;c++){let f=0,g=0,h=0;for(let p=0;p<a;p++)h=o.get(c,p)-e[c],f+=h,g+=h*h;t?l.push((g-f*f/a)/(a-1)):l.push((g-f*f/a)/a)}return l}function varianceByColumn(o,t,e){const n=o.rows,a=o.columns,l=[];for(let c=0;c<a;c++){let f=0,g=0,h=0;for(let p=0;p<n;p++)h=o.get(p,c)-e[c],f+=h,g+=h*h;t?l.push((g-f*f/n)/(n-1)):l.push((g-f*f/n)/n)}return l}function varianceAll(o,t,e){const n=o.rows,a=o.columns,l=n*a;let c=0,f=0,g=0;for(let h=0;h<n;h++)for(let p=0;p<a;p++)g=o.get(h,p)-e,c+=g,f+=g*g;return t?(f-c*c/l)/(l-1):(f-c*c/l)/l}function centerByRow(o,t){for(let e=0;e<o.rows;e++)for(let n=0;n<o.columns;n++)o.set(e,n,o.get(e,n)-t[e])}function centerByColumn(o,t){for(let e=0;e<o.rows;e++)for(let n=0;n<o.columns;n++)o.set(e,n,o.get(e,n)-t[n])}function centerAll(o,t){for(let e=0;e<o.rows;e++)for(let n=0;n<o.columns;n++)o.set(e,n,o.get(e,n)-t)}function getScaleByRow(o){const t=[];for(let e=0;e<o.rows;e++){let n=0;for(let a=0;a<o.columns;a++)n+=Math.pow(o.get(e,a),2)/(o.columns-1);t.push(Math.sqrt(n))}return t}function scaleByRow(o,t){for(let e=0;e<o.rows;e++)for(let n=0;n<o.columns;n++)o.set(e,n,o.get(e,n)/t[e])}function getScaleByColumn(o){const t=[];for(let e=0;e<o.columns;e++){let n=0;for(let a=0;a<o.rows;a++)n+=Math.pow(o.get(a,e),2)/(o.rows-1);t.push(Math.sqrt(n))}return t}function scaleByColumn(o,t){for(let e=0;e<o.rows;e++)for(let n=0;n<o.columns;n++)o.set(e,n,o.get(e,n)/t[n])}function getScaleAll(o){const t=o.size-1;let e=0;for(let n=0;n<o.columns;n++)for(let a=0;a<o.rows;a++)e+=Math.pow(o.get(a,n),2)/t;return Math.sqrt(e)}function scaleAll(o,t){for(let e=0;e<o.rows;e++)for(let n=0;n<o.columns;n++)o.set(e,n,o.get(e,n)/t)}class AbstractMatrix{static from1DArray(t,e,n){if(t*e!==n.length)throw new RangeError("data length does not match given dimensions");let l=new Matrix$2(t,e);for(let c=0;c<t;c++)for(let f=0;f<e;f++)l.set(c,f,n[c*e+f]);return l}static rowVector(t){let e=new Matrix$2(1,t.length);for(let n=0;n<t.length;n++)e.set(0,n,t[n]);return e}static columnVector(t){let e=new Matrix$2(t.length,1);for(let n=0;n<t.length;n++)e.set(n,0,t[n]);return e}static zeros(t,e){return new Matrix$2(t,e)}static ones(t,e){return new Matrix$2(t,e).fill(1)}static rand(t,e,n={}){if(typeof n!="object")throw new TypeError("options must be an object");const{random:a=Math.random}=n;let l=new Matrix$2(t,e);for(let c=0;c<t;c++)for(let f=0;f<e;f++)l.set(c,f,a());return l}static randInt(t,e,n={}){if(typeof n!="object")throw new TypeError("options must be an object");const{min:a=0,max:l=1e3,random:c=Math.random}=n;if(!Number.isInteger(a))throw new TypeError("min must be an integer");if(!Number.isInteger(l))throw new TypeError("max must be an integer");if(a>=l)throw new RangeError("min must be smaller than max");let f=l-a,g=new Matrix$2(t,e);for(let h=0;h<t;h++)for(let p=0;p<e;p++){let s=a+Math.round(c()*f);g.set(h,p,s)}return g}static eye(t,e,n){e===void 0&&(e=t),n===void 0&&(n=1);let a=Math.min(t,e),l=this.zeros(t,e);for(let c=0;c<a;c++)l.set(c,c,n);return l}static diag(t,e,n){let a=t.length;e===void 0&&(e=a),n===void 0&&(n=e);let l=Math.min(a,e,n),c=this.zeros(e,n);for(let f=0;f<l;f++)c.set(f,f,t[f]);return c}static min(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let n=t.rows,a=t.columns,l=new Matrix$2(n,a);for(let c=0;c<n;c++)for(let f=0;f<a;f++)l.set(c,f,Math.min(t.get(c,f),e.get(c,f)));return l}static max(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let n=t.rows,a=t.columns,l=new this(n,a);for(let c=0;c<n;c++)for(let f=0;f<a;f++)l.set(c,f,Math.max(t.get(c,f),e.get(c,f)));return l}static checkMatrix(t){return AbstractMatrix.isMatrix(t)?t:new Matrix$2(t)}static isMatrix(t){return t!=null&&t.klass==="Matrix"}get size(){return this.rows*this.columns}apply(t){if(typeof t!="function")throw new TypeError("callback must be a function");for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)t.call(this,e,n);return this}to1DArray(){let t=[];for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)t.push(this.get(e,n));return t}to2DArray(){let t=[];for(let e=0;e<this.rows;e++){t.push([]);for(let n=0;n<this.columns;n++)t[e].push(this.get(e,n))}return t}toJSON(){return this.to2DArray()}isRowVector(){return this.rows===1}isColumnVector(){return this.columns===1}isVector(){return this.rows===1||this.columns===1}isSquare(){return this.rows===this.columns}isEmpty(){return this.rows===0||this.columns===0}isSymmetric(){if(this.isSquare()){for(let t=0;t<this.rows;t++)for(let e=0;e<=t;e++)if(this.get(t,e)!==this.get(e,t))return!1;return!0}return!1}isEchelonForm(){let t=0,e=0,n=-1,a=!0,l=!1;for(;t<this.rows&&a;){for(e=0,l=!1;e<this.columns&&l===!1;)this.get(t,e)===0?e++:this.get(t,e)===1&&e>n?(l=!0,n=e):(a=!1,l=!0);t++}return a}isReducedEchelonForm(){let t=0,e=0,n=-1,a=!0,l=!1;for(;t<this.rows&&a;){for(e=0,l=!1;e<this.columns&&l===!1;)this.get(t,e)===0?e++:this.get(t,e)===1&&e>n?(l=!0,n=e):(a=!1,l=!0);for(let c=e+1;c<this.rows;c++)this.get(t,c)!==0&&(a=!1);t++}return a}echelonForm(){let t=this.clone(),e=0,n=0;for(;e<t.rows&&n<t.columns;){let a=e;for(let l=e;l<t.rows;l++)t.get(l,n)>t.get(a,n)&&(a=l);if(t.get(a,n)===0)n++;else{t.swapRows(e,a);let l=t.get(e,n);for(let c=n;c<t.columns;c++)t.set(e,c,t.get(e,c)/l);for(let c=e+1;c<t.rows;c++){let f=t.get(c,n)/t.get(e,n);t.set(c,n,0);for(let g=n+1;g<t.columns;g++)t.set(c,g,t.get(c,g)-t.get(e,g)*f)}e++,n++}}return t}reducedEchelonForm(){let t=this.echelonForm(),e=t.columns,n=t.rows,a=n-1;for(;a>=0;)if(t.maxRow(a)===0)a--;else{let l=0,c=!1;for(;l<n&&c===!1;)t.get(a,l)===1?c=!0:l++;for(let f=0;f<a;f++){let g=t.get(f,l);for(let h=l;h<e;h++){let p=t.get(f,h)-g*t.get(a,h);t.set(f,h,p)}}a--}return t}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(t={}){if(typeof t!="object")throw new TypeError("options must be an object");const{rows:e=1,columns:n=1}=t;if(!Number.isInteger(e)||e<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(n)||n<=0)throw new TypeError("columns must be a positive integer");let a=new Matrix$2(this.rows*e,this.columns*n);for(let l=0;l<e;l++)for(let c=0;c<n;c++)a.setSubMatrix(this,this.rows*l,this.columns*c);return a}fill(t){for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,t);return this}neg(){return this.mulS(-1)}getRow(t){checkRowIndex(this,t);let e=[];for(let n=0;n<this.columns;n++)e.push(this.get(t,n));return e}getRowVector(t){return Matrix$2.rowVector(this.getRow(t))}setRow(t,e){checkRowIndex(this,t),e=checkRowVector(this,e);for(let n=0;n<this.columns;n++)this.set(t,n,e[n]);return this}swapRows(t,e){checkRowIndex(this,t),checkRowIndex(this,e);for(let n=0;n<this.columns;n++){let a=this.get(t,n);this.set(t,n,this.get(e,n)),this.set(e,n,a)}return this}getColumn(t){checkColumnIndex(this,t);let e=[];for(let n=0;n<this.rows;n++)e.push(this.get(n,t));return e}getColumnVector(t){return Matrix$2.columnVector(this.getColumn(t))}setColumn(t,e){checkColumnIndex(this,t),e=checkColumnVector(this,e);for(let n=0;n<this.rows;n++)this.set(n,t,e[n]);return this}swapColumns(t,e){checkColumnIndex(this,t),checkColumnIndex(this,e);for(let n=0;n<this.rows;n++){let a=this.get(n,t);this.set(n,t,this.get(n,e)),this.set(n,e,a)}return this}addRowVector(t){t=checkRowVector(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)+t[n]);return this}subRowVector(t){t=checkRowVector(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)-t[n]);return this}mulRowVector(t){t=checkRowVector(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)*t[n]);return this}divRowVector(t){t=checkRowVector(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)/t[n]);return this}addColumnVector(t){t=checkColumnVector(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)+t[e]);return this}subColumnVector(t){t=checkColumnVector(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)-t[e]);return this}mulColumnVector(t){t=checkColumnVector(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)*t[e]);return this}divColumnVector(t){t=checkColumnVector(this,t);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)this.set(e,n,this.get(e,n)/t[e]);return this}mulRow(t,e){checkRowIndex(this,t);for(let n=0;n<this.columns;n++)this.set(t,n,this.get(t,n)*e);return this}mulColumn(t,e){checkColumnIndex(this,t);for(let n=0;n<this.rows;n++)this.set(n,t,this.get(n,t)*e);return this}max(t){if(this.isEmpty())return NaN;switch(t){case"row":{const e=new Array(this.rows).fill(Number.NEGATIVE_INFINITY);for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.get(n,a)>e[n]&&(e[n]=this.get(n,a));return e}case"column":{const e=new Array(this.columns).fill(Number.NEGATIVE_INFINITY);for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.get(n,a)>e[a]&&(e[a]=this.get(n,a));return e}case void 0:{let e=this.get(0,0);for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.get(n,a)>e&&(e=this.get(n,a));return e}default:throw new Error(`invalid option: ${t}`)}}maxIndex(){checkNonEmpty(this);let t=this.get(0,0),e=[0,0];for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.get(n,a)>t&&(t=this.get(n,a),e[0]=n,e[1]=a);return e}min(t){if(this.isEmpty())return NaN;switch(t){case"row":{const e=new Array(this.rows).fill(Number.POSITIVE_INFINITY);for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.get(n,a)<e[n]&&(e[n]=this.get(n,a));return e}case"column":{const e=new Array(this.columns).fill(Number.POSITIVE_INFINITY);for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.get(n,a)<e[a]&&(e[a]=this.get(n,a));return e}case void 0:{let e=this.get(0,0);for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.get(n,a)<e&&(e=this.get(n,a));return e}default:throw new Error(`invalid option: ${t}`)}}minIndex(){checkNonEmpty(this);let t=this.get(0,0),e=[0,0];for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)this.get(n,a)<t&&(t=this.get(n,a),e[0]=n,e[1]=a);return e}maxRow(t){if(checkRowIndex(this,t),this.isEmpty())return NaN;let e=this.get(t,0);for(let n=1;n<this.columns;n++)this.get(t,n)>e&&(e=this.get(t,n));return e}maxRowIndex(t){checkRowIndex(this,t),checkNonEmpty(this);let e=this.get(t,0),n=[t,0];for(let a=1;a<this.columns;a++)this.get(t,a)>e&&(e=this.get(t,a),n[1]=a);return n}minRow(t){if(checkRowIndex(this,t),this.isEmpty())return NaN;let e=this.get(t,0);for(let n=1;n<this.columns;n++)this.get(t,n)<e&&(e=this.get(t,n));return e}minRowIndex(t){checkRowIndex(this,t),checkNonEmpty(this);let e=this.get(t,0),n=[t,0];for(let a=1;a<this.columns;a++)this.get(t,a)<e&&(e=this.get(t,a),n[1]=a);return n}maxColumn(t){if(checkColumnIndex(this,t),this.isEmpty())return NaN;let e=this.get(0,t);for(let n=1;n<this.rows;n++)this.get(n,t)>e&&(e=this.get(n,t));return e}maxColumnIndex(t){checkColumnIndex(this,t),checkNonEmpty(this);let e=this.get(0,t),n=[0,t];for(let a=1;a<this.rows;a++)this.get(a,t)>e&&(e=this.get(a,t),n[0]=a);return n}minColumn(t){if(checkColumnIndex(this,t),this.isEmpty())return NaN;let e=this.get(0,t);for(let n=1;n<this.rows;n++)this.get(n,t)<e&&(e=this.get(n,t));return e}minColumnIndex(t){checkColumnIndex(this,t),checkNonEmpty(this);let e=this.get(0,t),n=[0,t];for(let a=1;a<this.rows;a++)this.get(a,t)<e&&(e=this.get(a,t),n[0]=a);return n}diag(){let t=Math.min(this.rows,this.columns),e=[];for(let n=0;n<t;n++)e.push(this.get(n,n));return e}norm(t="frobenius"){let e=0;if(t==="max")return this.max();if(t==="frobenius"){for(let n=0;n<this.rows;n++)for(let a=0;a<this.columns;a++)e=e+this.get(n,a)*this.get(n,a);return Math.sqrt(e)}else throw new RangeError(`unknown norm type: ${t}`)}cumulativeSum(){let t=0;for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)t+=this.get(e,n),this.set(e,n,t);return this}dot(t){AbstractMatrix.isMatrix(t)&&(t=t.to1DArray());let e=this.to1DArray();if(e.length!==t.length)throw new RangeError("vectors do not have the same size");let n=0;for(let a=0;a<e.length;a++)n+=e[a]*t[a];return n}mmul(t){t=Matrix$2.checkMatrix(t);let e=this.rows,n=this.columns,a=t.columns,l=new Matrix$2(e,a),c=new Float64Array(n);for(let f=0;f<a;f++){for(let g=0;g<n;g++)c[g]=t.get(g,f);for(let g=0;g<e;g++){let h=0;for(let p=0;p<n;p++)h+=this.get(g,p)*c[p];l.set(g,f,h)}}return l}strassen2x2(t){t=Matrix$2.checkMatrix(t);let e=new Matrix$2(2,2);const n=this.get(0,0),a=t.get(0,0),l=this.get(0,1),c=t.get(0,1),f=this.get(1,0),g=t.get(1,0),h=this.get(1,1),p=t.get(1,1),s=(n+h)*(a+p),r=(f+h)*a,u=n*(c-p),d=h*(g-a),m=(n+l)*p,b=(f-n)*(a+c),y=(l-h)*(g+p),w=s+d-m+y,x=u+m,_=r+d,v=s-r+u+b;return e.set(0,0,w),e.set(0,1,x),e.set(1,0,_),e.set(1,1,v),e}strassen3x3(t){t=Matrix$2.checkMatrix(t);let e=new Matrix$2(3,3);const n=this.get(0,0),a=this.get(0,1),l=this.get(0,2),c=this.get(1,0),f=this.get(1,1),g=this.get(1,2),h=this.get(2,0),p=this.get(2,1),s=this.get(2,2),r=t.get(0,0),u=t.get(0,1),d=t.get(0,2),m=t.get(1,0),b=t.get(1,1),y=t.get(1,2),w=t.get(2,0),x=t.get(2,1),_=t.get(2,2),v=(n+a+l-c-f-p-s)*b,E=(n-c)*(-u+b),I=f*(-r+u+m-b-y-w+_),S=(-n+c+f)*(r-u+b),T=(c+f)*(-r+u),A=n*r,O=(-n+h+p)*(r-d+y),$=(-n+h)*(d-y),D=(h+p)*(-r+d),M=(n+a+l-f-g-h-p)*y,F=p*(-r+d+m-b-y-w+x),C=(-l+p+s)*(b+w-x),R=(l-s)*(b-x),j=l*w,G=(p+s)*(-w+x),W=(-l+f+g)*(y+w-_),Z=(l-g)*(y-_),at=(f+g)*(-w+_),J=a*m,Y=g*x,K=c*d,it=h*u,rt=s*_,yt=A+j+J,ut=v+S+T+A+C+j+G,St=A+O+D+M+j+W+at,gt=E+I+S+A+j+W+Z,Ot=E+S+T+A+Y,pt=j+W+Z+at+K,ct=A+O+$+F+C+R+j,ot=C+R+j+G+it,Mt=A+O+$+D+rt;return e.set(0,0,yt),e.set(0,1,ut),e.set(0,2,St),e.set(1,0,gt),e.set(1,1,Ot),e.set(1,2,pt),e.set(2,0,ct),e.set(2,1,ot),e.set(2,2,Mt),e}mmulStrassen(t){t=Matrix$2.checkMatrix(t);let e=this.clone(),n=e.rows,a=e.columns,l=t.rows,c=t.columns;a!==l&&console.warn(`Multiplying ${n} x ${a} and ${l} x ${c} matrix: dimensions do not match.`);function f(s,r,u){let d=s.rows,m=s.columns;if(d===r&&m===u)return s;{let b=AbstractMatrix.zeros(r,u);return b=b.setSubMatrix(s,0,0),b}}let g=Math.max(n,l),h=Math.max(a,c);e=f(e,g,h),t=f(t,g,h);function p(s,r,u,d){if(u<=512||d<=512)return s.mmul(r);u%2===1&&d%2===1?(s=f(s,u+1,d+1),r=f(r,u+1,d+1)):u%2===1?(s=f(s,u+1,d),r=f(r,u+1,d)):d%2===1&&(s=f(s,u,d+1),r=f(r,u,d+1));let m=parseInt(s.rows/2,10),b=parseInt(s.columns/2,10),y=s.subMatrix(0,m-1,0,b-1),w=r.subMatrix(0,m-1,0,b-1),x=s.subMatrix(0,m-1,b,s.columns-1),_=r.subMatrix(0,m-1,b,r.columns-1),v=s.subMatrix(m,s.rows-1,0,b-1),E=r.subMatrix(m,r.rows-1,0,b-1),I=s.subMatrix(m,s.rows-1,b,s.columns-1),S=r.subMatrix(m,r.rows-1,b,r.columns-1),T=p(AbstractMatrix.add(y,I),AbstractMatrix.add(w,S),m,b),A=p(AbstractMatrix.add(v,I),w,m,b),O=p(y,AbstractMatrix.sub(_,S),m,b),$=p(I,AbstractMatrix.sub(E,w),m,b),D=p(AbstractMatrix.add(y,x),S,m,b),M=p(AbstractMatrix.sub(v,y),AbstractMatrix.add(w,_),m,b),F=p(AbstractMatrix.sub(x,I),AbstractMatrix.add(E,S),m,b),C=AbstractMatrix.add(T,$);C.sub(D),C.add(F);let R=AbstractMatrix.add(O,D),j=AbstractMatrix.add(A,$),G=AbstractMatrix.sub(T,A);G.add(O),G.add(M);let W=AbstractMatrix.zeros(2*C.rows,2*C.columns);return W=W.setSubMatrix(C,0,0),W=W.setSubMatrix(R,C.rows,0),W=W.setSubMatrix(j,0,C.columns),W=W.setSubMatrix(G,C.rows,C.columns),W.subMatrix(0,u-1,0,d-1)}return p(e,t,g,h)}scaleRows(t={}){if(typeof t!="object")throw new TypeError("options must be an object");const{min:e=0,max:n=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(n))throw new TypeError("max must be a number");if(e>=n)throw new RangeError("min must be smaller than max");let a=new Matrix$2(this.rows,this.columns);for(let l=0;l<this.rows;l++){const c=this.getRow(l);c.length>0&&rescale(c,{min:e,max:n,output:c}),a.setRow(l,c)}return a}scaleColumns(t={}){if(typeof t!="object")throw new TypeError("options must be an object");const{min:e=0,max:n=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(n))throw new TypeError("max must be a number");if(e>=n)throw new RangeError("min must be smaller than max");let a=new Matrix$2(this.rows,this.columns);for(let l=0;l<this.columns;l++){const c=this.getColumn(l);c.length&&rescale(c,{min:e,max:n,output:c}),a.setColumn(l,c)}return a}flipRows(){const t=Math.ceil(this.columns/2);for(let e=0;e<this.rows;e++)for(let n=0;n<t;n++){let a=this.get(e,n),l=this.get(e,this.columns-1-n);this.set(e,n,l),this.set(e,this.columns-1-n,a)}return this}flipColumns(){const t=Math.ceil(this.rows/2);for(let e=0;e<this.columns;e++)for(let n=0;n<t;n++){let a=this.get(n,e),l=this.get(this.rows-1-n,e);this.set(n,e,l),this.set(this.rows-1-n,e,a)}return this}kroneckerProduct(t){t=Matrix$2.checkMatrix(t);let e=this.rows,n=this.columns,a=t.rows,l=t.columns,c=new Matrix$2(e*a,n*l);for(let f=0;f<e;f++)for(let g=0;g<n;g++)for(let h=0;h<a;h++)for(let p=0;p<l;p++)c.set(a*f+h,l*g+p,this.get(f,g)*t.get(h,p));return c}kroneckerSum(t){if(t=Matrix$2.checkMatrix(t),!this.isSquare()||!t.isSquare())throw new Error("Kronecker Sum needs two Square Matrices");let e=this.rows,n=t.rows,a=this.kroneckerProduct(Matrix$2.eye(n,n)),l=Matrix$2.eye(e,e).kroneckerProduct(t);return a.add(l)}transpose(){let t=new Matrix$2(this.columns,this.rows);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)t.set(n,e,this.get(e,n));return t}sortRows(t=compareNumbers){for(let e=0;e<this.rows;e++)this.setRow(e,this.getRow(e).sort(t));return this}sortColumns(t=compareNumbers){for(let e=0;e<this.columns;e++)this.setColumn(e,this.getColumn(e).sort(t));return this}subMatrix(t,e,n,a){checkRange(this,t,e,n,a);let l=new Matrix$2(e-t+1,a-n+1);for(let c=t;c<=e;c++)for(let f=n;f<=a;f++)l.set(c-t,f-n,this.get(c,f));return l}subMatrixRow(t,e,n){if(e===void 0&&(e=0),n===void 0&&(n=this.columns-1),e>n||e<0||e>=this.columns||n<0||n>=this.columns)throw new RangeError("Argument out of range");let a=new Matrix$2(t.length,n-e+1);for(let l=0;l<t.length;l++)for(let c=e;c<=n;c++){if(t[l]<0||t[l]>=this.rows)throw new RangeError(`Row index out of range: ${t[l]}`);a.set(l,c-e,this.get(t[l],c))}return a}subMatrixColumn(t,e,n){if(e===void 0&&(e=0),n===void 0&&(n=this.rows-1),e>n||e<0||e>=this.rows||n<0||n>=this.rows)throw new RangeError("Argument out of range");let a=new Matrix$2(n-e+1,t.length);for(let l=0;l<t.length;l++)for(let c=e;c<=n;c++){if(t[l]<0||t[l]>=this.columns)throw new RangeError(`Column index out of range: ${t[l]}`);a.set(c-e,l,this.get(c,t[l]))}return a}setSubMatrix(t,e,n){if(t=Matrix$2.checkMatrix(t),t.isEmpty())return this;let a=e+t.rows-1,l=n+t.columns-1;checkRange(this,e,a,n,l);for(let c=0;c<t.rows;c++)for(let f=0;f<t.columns;f++)this.set(e+c,n+f,t.get(c,f));return this}selection(t,e){checkRowIndices(this,t),checkColumnIndices(this,e);let n=new Matrix$2(t.length,e.length);for(let a=0;a<t.length;a++){let l=t[a];for(let c=0;c<e.length;c++){let f=e[c];n.set(a,c,this.get(l,f))}}return n}trace(){let t=Math.min(this.rows,this.columns),e=0;for(let n=0;n<t;n++)e+=this.get(n,n);return e}clone(){let t=new Matrix$2(this.rows,this.columns);for(let e=0;e<this.rows;e++)for(let n=0;n<this.columns;n++)t.set(e,n,this.get(e,n));return t}sum(t){switch(t){case"row":return sumByRow(this);case"column":return sumByColumn(this);case void 0:return sumAll(this);default:throw new Error(`invalid option: ${t}`)}}product(t){switch(t){case"row":return productByRow(this);case"column":return productByColumn(this);case void 0:return productAll(this);default:throw new Error(`invalid option: ${t}`)}}mean(t){const e=this.sum(t);switch(t){case"row":{for(let n=0;n<this.rows;n++)e[n]/=this.columns;return e}case"column":{for(let n=0;n<this.columns;n++)e[n]/=this.rows;return e}case void 0:return e/this.size;default:throw new Error(`invalid option: ${t}`)}}variance(t,e={}){if(typeof t=="object"&&(e=t,t=void 0),typeof e!="object")throw new TypeError("options must be an object");const{unbiased:n=!0,mean:a=this.mean(t)}=e;if(typeof n!="boolean")throw new TypeError("unbiased must be a boolean");switch(t){case"row":{if(!isAnyArray(a))throw new TypeError("mean must be an array");return varianceByRow(this,n,a)}case"column":{if(!isAnyArray(a))throw new TypeError("mean must be an array");return varianceByColumn(this,n,a)}case void 0:{if(typeof a!="number")throw new TypeError("mean must be a number");return varianceAll(this,n,a)}default:throw new Error(`invalid option: ${t}`)}}standardDeviation(t,e){typeof t=="object"&&(e=t,t=void 0);const n=this.variance(t,e);if(t===void 0)return Math.sqrt(n);for(let a=0;a<n.length;a++)n[a]=Math.sqrt(n[a]);return n}center(t,e={}){if(typeof t=="object"&&(e=t,t=void 0),typeof e!="object")throw new TypeError("options must be an object");const{center:n=this.mean(t)}=e;switch(t){case"row":{if(!isAnyArray(n))throw new TypeError("center must be an array");return centerByRow(this,n),this}case"column":{if(!isAnyArray(n))throw new TypeError("center must be an array");return centerByColumn(this,n),this}case void 0:{if(typeof n!="number")throw new TypeError("center must be a number");return centerAll(this,n),this}default:throw new Error(`invalid option: ${t}`)}}scale(t,e={}){if(typeof t=="object"&&(e=t,t=void 0),typeof e!="object")throw new TypeError("options must be an object");let n=e.scale;switch(t){case"row":{if(n===void 0)n=getScaleByRow(this);else if(!isAnyArray(n))throw new TypeError("scale must be an array");return scaleByRow(this,n),this}case"column":{if(n===void 0)n=getScaleByColumn(this);else if(!isAnyArray(n))throw new TypeError("scale must be an array");return scaleByColumn(this,n),this}case void 0:{if(n===void 0)n=getScaleAll(this);else if(typeof n!="number")throw new TypeError("scale must be a number");return scaleAll(this,n),this}default:throw new Error(`invalid option: ${t}`)}}toString(t){return inspectMatrixWithOptions(this,t)}}AbstractMatrix.prototype.klass="Matrix",typeof Symbol<"u"&&(AbstractMatrix.prototype[Symbol.for("nodejs.util.inspect.custom")]=inspectMatrix);function compareNumbers(o,t){return o-t}function isArrayOfNumbers(o){return o.every(t=>typeof t=="number")}AbstractMatrix.random=AbstractMatrix.rand,AbstractMatrix.randomInt=AbstractMatrix.randInt,AbstractMatrix.diagonal=AbstractMatrix.diag,AbstractMatrix.prototype.diagonal=AbstractMatrix.prototype.diag,AbstractMatrix.identity=AbstractMatrix.eye,AbstractMatrix.prototype.negate=AbstractMatrix.prototype.neg,AbstractMatrix.prototype.tensorProduct=AbstractMatrix.prototype.kroneckerProduct;let Matrix$2=class Ne extends AbstractMatrix{constructor(t,e){if(super(),Ne.isMatrix(t))return t.clone();if(Number.isInteger(t)&&t>=0)if(this.data=[],Number.isInteger(e)&&e>=0)for(let n=0;n<t;n++)this.data.push(new Float64Array(e));else throw new TypeError("nColumns must be a positive integer");else if(isAnyArray(t)){const n=t;if(t=n.length,e=t?n[0].length:0,typeof e!="number")throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let a=0;a<t;a++){if(n[a].length!==e)throw new RangeError("Inconsistent array dimensions");if(!isArrayOfNumbers(n[a]))throw new TypeError("Input data contains non-numeric values");this.data.push(Float64Array.from(n[a]))}}else throw new TypeError("First argument must be a positive number or an array");this.rows=t,this.columns=e}set(t,e,n){return this.data[t][e]=n,this}get(t,e){return this.data[t][e]}removeRow(t){return checkRowIndex(this,t),this.data.splice(t,1),this.rows-=1,this}addRow(t,e){return e===void 0&&(e=t,t=this.rows),checkRowIndex(this,t,!0),e=Float64Array.from(checkRowVector(this,e)),this.data.splice(t,0,e),this.rows+=1,this}removeColumn(t){checkColumnIndex(this,t);for(let e=0;e<this.rows;e++){const n=new Float64Array(this.columns-1);for(let a=0;a<t;a++)n[a]=this.data[e][a];for(let a=t+1;a<this.columns;a++)n[a-1]=this.data[e][a];this.data[e]=n}return this.columns-=1,this}addColumn(t,e){typeof e>"u"&&(e=t,t=this.columns),checkColumnIndex(this,t,!0),e=checkColumnVector(this,e);for(let n=0;n<this.rows;n++){const a=new Float64Array(this.columns+1);let l=0;for(;l<t;l++)a[l]=this.data[n][l];for(a[l++]=e[n];l<this.columns+1;l++)a[l]=this.data[n][l-1];this.data[n]=a}return this.columns+=1,this}};installMathOperations(AbstractMatrix,Matrix$2);class BaseView extends AbstractMatrix{constructor(t,e,n){super(),this.matrix=t,this.rows=e,this.columns=n}}class MatrixColumnView extends BaseView{constructor(t,e){checkColumnIndex(t,e),super(t,t.rows,1),this.column=e}set(t,e,n){return this.matrix.set(t,this.column,n),this}get(t){return this.matrix.get(t,this.column)}}class MatrixColumnSelectionView extends BaseView{constructor(t,e){checkColumnIndices(t,e),super(t,t.rows,e.length),this.columnIndices=e}set(t,e,n){return this.matrix.set(t,this.columnIndices[e],n),this}get(t,e){return this.matrix.get(t,this.columnIndices[e])}}class MatrixFlipColumnView extends BaseView{constructor(t){super(t,t.rows,t.columns)}set(t,e,n){return this.matrix.set(t,this.columns-e-1,n),this}get(t,e){return this.matrix.get(t,this.columns-e-1)}}class MatrixFlipRowView extends BaseView{constructor(t){super(t,t.rows,t.columns)}set(t,e,n){return this.matrix.set(this.rows-t-1,e,n),this}get(t,e){return this.matrix.get(this.rows-t-1,e)}}class MatrixRowView extends BaseView{constructor(t,e){checkRowIndex(t,e),super(t,1,t.columns),this.row=e}set(t,e,n){return this.matrix.set(this.row,e,n),this}get(t,e){return this.matrix.get(this.row,e)}}class MatrixRowSelectionView extends BaseView{constructor(t,e){checkRowIndices(t,e),super(t,e.length,t.columns),this.rowIndices=e}set(t,e,n){return this.matrix.set(this.rowIndices[t],e,n),this}get(t,e){return this.matrix.get(this.rowIndices[t],e)}}class MatrixSelectionView extends BaseView{constructor(t,e,n){checkRowIndices(t,e),checkColumnIndices(t,n),super(t,e.length,n.length),this.rowIndices=e,this.columnIndices=n}set(t,e,n){return this.matrix.set(this.rowIndices[t],this.columnIndices[e],n),this}get(t,e){return this.matrix.get(this.rowIndices[t],this.columnIndices[e])}}class MatrixSubView extends BaseView{constructor(t,e,n,a,l){checkRange(t,e,n,a,l),super(t,n-e+1,l-a+1),this.startRow=e,this.startColumn=a}set(t,e,n){return this.matrix.set(this.startRow+t,this.startColumn+e,n),this}get(t,e){return this.matrix.get(this.startRow+t,this.startColumn+e)}}let MatrixTransposeView$1=class extends BaseView{constructor(t){super(t,t.columns,t.rows)}set(t,e,n){return this.matrix.set(e,t,n),this}get(t,e){return this.matrix.get(e,t)}};class WrapperMatrix1D extends AbstractMatrix{constructor(t,e={}){const{rows:n=1}=e;if(t.length%n!==0)throw new Error("the data length is not divisible by the number of rows");super(),this.rows=n,this.columns=t.length/n,this.data=t}set(t,e,n){let a=this._calculateIndex(t,e);return this.data[a]=n,this}get(t,e){let n=this._calculateIndex(t,e);return this.data[n]}_calculateIndex(t,e){return t*this.columns+e}}class WrapperMatrix2D extends AbstractMatrix{constructor(t){super(),this.data=t,this.rows=t.length,this.columns=t[0].length}set(t,e,n){return this.data[t][e]=n,this}get(t,e){return this.data[t][e]}}function wrap(o,t){if(isAnyArray(o))return o[0]&&isAnyArray(o[0])?new WrapperMatrix2D(o):new WrapperMatrix1D(o,t);throw new Error("the argument is not an array")}class LuDecomposition{constructor(t){t=WrapperMatrix2D.checkMatrix(t);let e=t.clone(),n=e.rows,a=e.columns,l=new Float64Array(n),c=1,f,g,h,p,s,r,u,d,m;for(f=0;f<n;f++)l[f]=f;for(d=new Float64Array(n),g=0;g<a;g++){for(f=0;f<n;f++)d[f]=e.get(f,g);for(f=0;f<n;f++){for(m=Math.min(f,g),s=0,h=0;h<m;h++)s+=e.get(f,h)*d[h];d[f]-=s,e.set(f,g,d[f])}for(p=g,f=g+1;f<n;f++)Math.abs(d[f])>Math.abs(d[p])&&(p=f);if(p!==g){for(h=0;h<a;h++)r=e.get(p,h),e.set(p,h,e.get(g,h)),e.set(g,h,r);u=l[p],l[p]=l[g],l[g]=u,c=-c}if(g<n&&e.get(g,g)!==0)for(f=g+1;f<n;f++)e.set(f,g,e.get(f,g)/e.get(g,g))}this.LU=e,this.pivotVector=l,this.pivotSign=c}isSingular(){let t=this.LU,e=t.columns;for(let n=0;n<e;n++)if(t.get(n,n)===0)return!0;return!1}solve(t){t=Matrix$2.checkMatrix(t);let e=this.LU;if(e.rows!==t.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let a=t.columns,l=t.subMatrixRow(this.pivotVector,0,a-1),c=e.columns,f,g,h;for(h=0;h<c;h++)for(f=h+1;f<c;f++)for(g=0;g<a;g++)l.set(f,g,l.get(f,g)-l.get(h,g)*e.get(f,h));for(h=c-1;h>=0;h--){for(g=0;g<a;g++)l.set(h,g,l.get(h,g)/e.get(h,h));for(f=0;f<h;f++)for(g=0;g<a;g++)l.set(f,g,l.get(f,g)-l.get(h,g)*e.get(f,h))}return l}get determinant(){let t=this.LU;if(!t.isSquare())throw new Error("Matrix must be square");let e=this.pivotSign,n=t.columns;for(let a=0;a<n;a++)e*=t.get(a,a);return e}get lowerTriangularMatrix(){let t=this.LU,e=t.rows,n=t.columns,a=new Matrix$2(e,n);for(let l=0;l<e;l++)for(let c=0;c<n;c++)l>c?a.set(l,c,t.get(l,c)):l===c?a.set(l,c,1):a.set(l,c,0);return a}get upperTriangularMatrix(){let t=this.LU,e=t.rows,n=t.columns,a=new Matrix$2(e,n);for(let l=0;l<e;l++)for(let c=0;c<n;c++)l<=c?a.set(l,c,t.get(l,c)):a.set(l,c,0);return a}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function hypotenuse$1(o,t){let e=0;return Math.abs(o)>Math.abs(t)?(e=t/o,Math.abs(o)*Math.sqrt(1+e*e)):t!==0?(e=o/t,Math.abs(t)*Math.sqrt(1+e*e)):0}class QrDecomposition{constructor(t){t=WrapperMatrix2D.checkMatrix(t);let e=t.clone(),n=t.rows,a=t.columns,l=new Float64Array(a),c,f,g,h;for(g=0;g<a;g++){let p=0;for(c=g;c<n;c++)p=hypotenuse$1(p,e.get(c,g));if(p!==0){for(e.get(g,g)<0&&(p=-p),c=g;c<n;c++)e.set(c,g,e.get(c,g)/p);for(e.set(g,g,e.get(g,g)+1),f=g+1;f<a;f++){for(h=0,c=g;c<n;c++)h+=e.get(c,g)*e.get(c,f);for(h=-h/e.get(g,g),c=g;c<n;c++)e.set(c,f,e.get(c,f)+h*e.get(c,g))}}l[g]=-p}this.QR=e,this.Rdiag=l}solve(t){t=Matrix$2.checkMatrix(t);let e=this.QR,n=e.rows;if(t.rows!==n)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let a=t.columns,l=t.clone(),c=e.columns,f,g,h,p;for(h=0;h<c;h++)for(g=0;g<a;g++){for(p=0,f=h;f<n;f++)p+=e.get(f,h)*l.get(f,g);for(p=-p/e.get(h,h),f=h;f<n;f++)l.set(f,g,l.get(f,g)+p*e.get(f,h))}for(h=c-1;h>=0;h--){for(g=0;g<a;g++)l.set(h,g,l.get(h,g)/this.Rdiag[h]);for(f=0;f<h;f++)for(g=0;g<a;g++)l.set(f,g,l.get(f,g)-l.get(h,g)*e.get(f,h))}return l.subMatrix(0,c-1,0,a-1)}isFullRank(){let t=this.QR.columns;for(let e=0;e<t;e++)if(this.Rdiag[e]===0)return!1;return!0}get upperTriangularMatrix(){let t=this.QR,e=t.columns,n=new Matrix$2(e,e),a,l;for(a=0;a<e;a++)for(l=0;l<e;l++)a<l?n.set(a,l,t.get(a,l)):a===l?n.set(a,l,this.Rdiag[a]):n.set(a,l,0);return n}get orthogonalMatrix(){let t=this.QR,e=t.rows,n=t.columns,a=new Matrix$2(e,n),l,c,f,g;for(f=n-1;f>=0;f--){for(l=0;l<e;l++)a.set(l,f,0);for(a.set(f,f,1),c=f;c<n;c++)if(t.get(f,f)!==0){for(g=0,l=f;l<e;l++)g+=t.get(l,f)*a.get(l,c);for(g=-g/t.get(f,f),l=f;l<e;l++)a.set(l,c,a.get(l,c)+g*t.get(l,f))}}return a}}class SingularValueDecomposition{constructor(t,e={}){if(t=WrapperMatrix2D.checkMatrix(t),t.isEmpty())throw new Error("Matrix must be non-empty");let n=t.rows,a=t.columns;const{computeLeftSingularVectors:l=!0,computeRightSingularVectors:c=!0,autoTranspose:f=!1}=e;let g=!!l,h=!!c,p=!1,s;if(n<a)if(!f)s=t.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else{s=t.transpose(),n=s.rows,a=s.columns,p=!0;let A=g;g=h,h=A}else s=t.clone();let r=Math.min(n,a),u=Math.min(n+1,a),d=new Float64Array(u),m=new Matrix$2(n,r),b=new Matrix$2(a,a),y=new Float64Array(a),w=new Float64Array(n),x=new Float64Array(u);for(let A=0;A<u;A++)x[A]=A;let _=Math.min(n-1,a),v=Math.max(0,Math.min(a-2,n)),E=Math.max(_,v);for(let A=0;A<E;A++){if(A<_){d[A]=0;for(let O=A;O<n;O++)d[A]=hypotenuse$1(d[A],s.get(O,A));if(d[A]!==0){s.get(A,A)<0&&(d[A]=-d[A]);for(let O=A;O<n;O++)s.set(O,A,s.get(O,A)/d[A]);s.set(A,A,s.get(A,A)+1)}d[A]=-d[A]}for(let O=A+1;O<a;O++){if(A<_&&d[A]!==0){let $=0;for(let D=A;D<n;D++)$+=s.get(D,A)*s.get(D,O);$=-$/s.get(A,A);for(let D=A;D<n;D++)s.set(D,O,s.get(D,O)+$*s.get(D,A))}y[O]=s.get(A,O)}if(g&&A<_)for(let O=A;O<n;O++)m.set(O,A,s.get(O,A));if(A<v){y[A]=0;for(let O=A+1;O<a;O++)y[A]=hypotenuse$1(y[A],y[O]);if(y[A]!==0){y[A+1]<0&&(y[A]=0-y[A]);for(let O=A+1;O<a;O++)y[O]/=y[A];y[A+1]+=1}if(y[A]=-y[A],A+1<n&&y[A]!==0){for(let O=A+1;O<n;O++)w[O]=0;for(let O=A+1;O<n;O++)for(let $=A+1;$<a;$++)w[O]+=y[$]*s.get(O,$);for(let O=A+1;O<a;O++){let $=-y[O]/y[A+1];for(let D=A+1;D<n;D++)s.set(D,O,s.get(D,O)+$*w[D])}}if(h)for(let O=A+1;O<a;O++)b.set(O,A,y[O])}}let I=Math.min(a,n+1);if(_<a&&(d[_]=s.get(_,_)),n<I&&(d[I-1]=0),v+1<I&&(y[v]=s.get(v,I-1)),y[I-1]=0,g){for(let A=_;A<r;A++){for(let O=0;O<n;O++)m.set(O,A,0);m.set(A,A,1)}for(let A=_-1;A>=0;A--)if(d[A]!==0){for(let O=A+1;O<r;O++){let $=0;for(let D=A;D<n;D++)$+=m.get(D,A)*m.get(D,O);$=-$/m.get(A,A);for(let D=A;D<n;D++)m.set(D,O,m.get(D,O)+$*m.get(D,A))}for(let O=A;O<n;O++)m.set(O,A,-m.get(O,A));m.set(A,A,1+m.get(A,A));for(let O=0;O<A-1;O++)m.set(O,A,0)}else{for(let O=0;O<n;O++)m.set(O,A,0);m.set(A,A,1)}}if(h)for(let A=a-1;A>=0;A--){if(A<v&&y[A]!==0)for(let O=A+1;O<a;O++){let $=0;for(let D=A+1;D<a;D++)$+=b.get(D,A)*b.get(D,O);$=-$/b.get(A+1,A);for(let D=A+1;D<a;D++)b.set(D,O,b.get(D,O)+$*b.get(D,A))}for(let O=0;O<a;O++)b.set(O,A,0);b.set(A,A,1)}let S=I-1,T=Number.EPSILON;for(;I>0;){let A,O;for(A=I-2;A>=-1&&A!==-1;A--){const $=Number.MIN_VALUE+T*Math.abs(d[A]+Math.abs(d[A+1]));if(Math.abs(y[A])<=$||Number.isNaN(y[A])){y[A]=0;break}}if(A===I-2)O=4;else{let $;for($=I-1;$>=A&&$!==A;$--){let D=($!==I?Math.abs(y[$]):0)+($!==A+1?Math.abs(y[$-1]):0);if(Math.abs(d[$])<=T*D){d[$]=0;break}}$===A?O=3:$===I-1?O=1:(O=2,A=$)}switch(A++,O){case 1:{let $=y[I-2];y[I-2]=0;for(let D=I-2;D>=A;D--){let M=hypotenuse$1(d[D],$),F=d[D]/M,C=$/M;if(d[D]=M,D!==A&&($=-C*y[D-1],y[D-1]=F*y[D-1]),h)for(let R=0;R<a;R++)M=F*b.get(R,D)+C*b.get(R,I-1),b.set(R,I-1,-C*b.get(R,D)+F*b.get(R,I-1)),b.set(R,D,M)}break}case 2:{let $=y[A-1];y[A-1]=0;for(let D=A;D<I;D++){let M=hypotenuse$1(d[D],$),F=d[D]/M,C=$/M;if(d[D]=M,$=-C*y[D],y[D]=F*y[D],g)for(let R=0;R<n;R++)M=F*m.get(R,D)+C*m.get(R,A-1),m.set(R,A-1,-C*m.get(R,D)+F*m.get(R,A-1)),m.set(R,D,M)}break}case 3:{const $=Math.max(Math.abs(d[I-1]),Math.abs(d[I-2]),Math.abs(y[I-2]),Math.abs(d[A]),Math.abs(y[A])),D=d[I-1]/$,M=d[I-2]/$,F=y[I-2]/$,C=d[A]/$,R=y[A]/$,j=((M+D)*(M-D)+F*F)/2,G=D*F*(D*F);let W=0;(j!==0||G!==0)&&(j<0?W=0-Math.sqrt(j*j+G):W=Math.sqrt(j*j+G),W=G/(j+W));let Z=(C+D)*(C-D)+W,at=C*R;for(let J=A;J<I-1;J++){let Y=hypotenuse$1(Z,at);Y===0&&(Y=Number.MIN_VALUE);let K=Z/Y,it=at/Y;if(J!==A&&(y[J-1]=Y),Z=K*d[J]+it*y[J],y[J]=K*y[J]-it*d[J],at=it*d[J+1],d[J+1]=K*d[J+1],h)for(let rt=0;rt<a;rt++)Y=K*b.get(rt,J)+it*b.get(rt,J+1),b.set(rt,J+1,-it*b.get(rt,J)+K*b.get(rt,J+1)),b.set(rt,J,Y);if(Y=hypotenuse$1(Z,at),Y===0&&(Y=Number.MIN_VALUE),K=Z/Y,it=at/Y,d[J]=Y,Z=K*y[J]+it*d[J+1],d[J+1]=-it*y[J]+K*d[J+1],at=it*y[J+1],y[J+1]=K*y[J+1],g&&J<n-1)for(let rt=0;rt<n;rt++)Y=K*m.get(rt,J)+it*m.get(rt,J+1),m.set(rt,J+1,-it*m.get(rt,J)+K*m.get(rt,J+1)),m.set(rt,J,Y)}y[I-2]=Z;break}case 4:{if(d[A]<=0&&(d[A]=d[A]<0?-d[A]:0,h))for(let $=0;$<=S;$++)b.set($,A,-b.get($,A));for(;A<S&&!(d[A]>=d[A+1]);){let $=d[A];if(d[A]=d[A+1],d[A+1]=$,h&&A<a-1)for(let D=0;D<a;D++)$=b.get(D,A+1),b.set(D,A+1,b.get(D,A)),b.set(D,A,$);if(g&&A<n-1)for(let D=0;D<n;D++)$=m.get(D,A+1),m.set(D,A+1,m.get(D,A)),m.set(D,A,$);A++}I--;break}}}if(p){let A=b;b=m,m=A}this.m=n,this.n=a,this.s=d,this.U=m,this.V=b}solve(t){let e=t,n=this.threshold,a=this.s.length,l=Matrix$2.zeros(a,a);for(let r=0;r<a;r++)Math.abs(this.s[r])<=n?l.set(r,r,0):l.set(r,r,1/this.s[r]);let c=this.U,f=this.rightSingularVectors,g=f.mmul(l),h=f.rows,p=c.rows,s=Matrix$2.zeros(h,p);for(let r=0;r<h;r++)for(let u=0;u<p;u++){let d=0;for(let m=0;m<a;m++)d+=g.get(r,m)*c.get(u,m);s.set(r,u,d)}return s.mmul(e)}solveForDiagonal(t){return this.solve(Matrix$2.diag(t))}inverse(){let t=this.V,e=this.threshold,n=t.rows,a=t.columns,l=new Matrix$2(n,this.s.length);for(let p=0;p<n;p++)for(let s=0;s<a;s++)Math.abs(this.s[s])>e&&l.set(p,s,t.get(p,s)/this.s[s]);let c=this.U,f=c.rows,g=c.columns,h=new Matrix$2(n,f);for(let p=0;p<n;p++)for(let s=0;s<f;s++){let r=0;for(let u=0;u<g;u++)r+=l.get(p,u)*c.get(s,u);h.set(p,s,r)}return h}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let t=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,e=0,n=this.s;for(let a=0,l=n.length;a<l;a++)n[a]>t&&e++;return e}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return Matrix$2.diag(this.s)}}function inverse(o,t=!1){return o=WrapperMatrix2D.checkMatrix(o),t?new SingularValueDecomposition(o).inverse():solve(o,Matrix$2.eye(o.rows))}function solve(o,t,e=!1){return o=WrapperMatrix2D.checkMatrix(o),t=WrapperMatrix2D.checkMatrix(t),e?new SingularValueDecomposition(o).solve(t):o.isSquare()?new LuDecomposition(o).solve(t):new QrDecomposition(o).solve(t)}function determinant(o){if(o=Matrix$2.checkMatrix(o),o.isSquare()){if(o.columns===0)return 1;let t,e,n,a;if(o.columns===2)return t=o.get(0,0),e=o.get(0,1),n=o.get(1,0),a=o.get(1,1),t*a-e*n;if(o.columns===3){let l,c,f;return l=new MatrixSelectionView(o,[1,2],[1,2]),c=new MatrixSelectionView(o,[1,2],[0,2]),f=new MatrixSelectionView(o,[1,2],[0,1]),t=o.get(0,0),e=o.get(0,1),n=o.get(0,2),t*determinant(l)-e*determinant(c)+n*determinant(f)}else return new LuDecomposition(o).determinant}else throw Error("determinant can only be calculated for a square matrix")}function xrange(o,t){let e=[];for(let n=0;n<o;n++)n!==t&&e.push(n);return e}function dependenciesOneRow(o,t,e,n=1e-9,a=1e-9){if(o>a)return new Array(t.rows+1).fill(0);{let l=t.addRow(e,[0]);for(let c=0;c<l.rows;c++)Math.abs(l.get(c,0))<n&&l.set(c,0,0);return l.to1DArray()}}function linearDependencies(o,t={}){const{thresholdValue:e=1e-9,thresholdError:n=1e-9}=t;o=Matrix$2.checkMatrix(o);let a=o.rows,l=new Matrix$2(a,a);for(let c=0;c<a;c++){let f=Matrix$2.columnVector(o.getRow(c)),g=o.subMatrixRow(xrange(a,c)).transpose(),p=new SingularValueDecomposition(g).solve(f),s=Matrix$2.sub(f,g.mmul(p)).abs().max();l.setRow(c,dependenciesOneRow(s,p,c,e,n))}return l}function pseudoInverse(o,t=Number.EPSILON){if(o=Matrix$2.checkMatrix(o),o.isEmpty())return o.transpose();let e=new SingularValueDecomposition(o,{autoTranspose:!0}),n=e.leftSingularVectors,a=e.rightSingularVectors,l=e.diagonal;for(let c=0;c<l.length;c++)Math.abs(l[c])>t?l[c]=1/l[c]:l[c]=0;return a.mmul(Matrix$2.diag(l).mmul(n.transpose()))}function covariance(o,t=o,e={}){o=new Matrix$2(o);let n=!1;if(typeof t=="object"&&!Matrix$2.isMatrix(t)&&!isAnyArray(t)?(e=t,t=o,n=!0):t=new Matrix$2(t),o.rows!==t.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:a=!0}=e;a&&(o=o.center("column"),n||(t=t.center("column")));const l=o.transpose().mmul(t);for(let c=0;c<l.rows;c++)for(let f=0;f<l.columns;f++)l.set(c,f,l.get(c,f)*(1/(o.rows-1)));return l}function correlation(o,t=o,e={}){o=new Matrix$2(o);let n=!1;if(typeof t=="object"&&!Matrix$2.isMatrix(t)&&!isAnyArray(t)?(e=t,t=o,n=!0):t=new Matrix$2(t),o.rows!==t.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:a=!0,scale:l=!0}=e;a&&(o.center("column"),n||t.center("column")),l&&(o.scale("column"),n||t.scale("column"));const c=o.standardDeviation("column",{unbiased:!0}),f=n?c:t.standardDeviation("column",{unbiased:!0}),g=o.transpose().mmul(t);for(let h=0;h<g.rows;h++)for(let p=0;p<g.columns;p++)g.set(h,p,g.get(h,p)*(1/(c[h]*f[p]))*(1/(o.rows-1)));return g}class EigenvalueDecomposition{constructor(t,e={}){const{assumeSymmetric:n=!1}=e;if(t=WrapperMatrix2D.checkMatrix(t),!t.isSquare())throw new Error("Matrix is not a square matrix");if(t.isEmpty())throw new Error("Matrix must be non-empty");let a=t.columns,l=new Matrix$2(a,a),c=new Float64Array(a),f=new Float64Array(a),g=t,h,p,s=!1;if(n?s=!0:s=t.isSymmetric(),s){for(h=0;h<a;h++)for(p=0;p<a;p++)l.set(h,p,g.get(h,p));tred2(a,f,c,l),tql2(a,f,c,l)}else{let r=new Matrix$2(a,a),u=new Float64Array(a);for(p=0;p<a;p++)for(h=0;h<a;h++)r.set(h,p,g.get(h,p));orthes(a,r,u,l),hqr2(a,f,c,l,r)}this.n=a,this.e=f,this.d=c,this.V=l}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){let t=this.n,e=this.e,n=this.d,a=new Matrix$2(t,t),l,c;for(l=0;l<t;l++){for(c=0;c<t;c++)a.set(l,c,0);a.set(l,l,n[l]),e[l]>0?a.set(l,l+1,e[l]):e[l]<0&&a.set(l,l-1,e[l])}return a}}function tred2(o,t,e,n){let a,l,c,f,g,h,p,s;for(g=0;g<o;g++)e[g]=n.get(o-1,g);for(f=o-1;f>0;f--){for(s=0,c=0,h=0;h<f;h++)s=s+Math.abs(e[h]);if(s===0)for(t[f]=e[f-1],g=0;g<f;g++)e[g]=n.get(f-1,g),n.set(f,g,0),n.set(g,f,0);else{for(h=0;h<f;h++)e[h]/=s,c+=e[h]*e[h];for(a=e[f-1],l=Math.sqrt(c),a>0&&(l=-l),t[f]=s*l,c=c-a*l,e[f-1]=a-l,g=0;g<f;g++)t[g]=0;for(g=0;g<f;g++){for(a=e[g],n.set(g,f,a),l=t[g]+n.get(g,g)*a,h=g+1;h<=f-1;h++)l+=n.get(h,g)*e[h],t[h]+=n.get(h,g)*a;t[g]=l}for(a=0,g=0;g<f;g++)t[g]/=c,a+=t[g]*e[g];for(p=a/(c+c),g=0;g<f;g++)t[g]-=p*e[g];for(g=0;g<f;g++){for(a=e[g],l=t[g],h=g;h<=f-1;h++)n.set(h,g,n.get(h,g)-(a*t[h]+l*e[h]));e[g]=n.get(f-1,g),n.set(f,g,0)}}e[f]=c}for(f=0;f<o-1;f++){if(n.set(o-1,f,n.get(f,f)),n.set(f,f,1),c=e[f+1],c!==0){for(h=0;h<=f;h++)e[h]=n.get(h,f+1)/c;for(g=0;g<=f;g++){for(l=0,h=0;h<=f;h++)l+=n.get(h,f+1)*n.get(h,g);for(h=0;h<=f;h++)n.set(h,g,n.get(h,g)-l*e[h])}}for(h=0;h<=f;h++)n.set(h,f+1,0)}for(g=0;g<o;g++)e[g]=n.get(o-1,g),n.set(o-1,g,0);n.set(o-1,o-1,1),t[0]=0}function tql2(o,t,e,n){let a,l,c,f,g,h,p,s,r,u,d,m,b,y,w,x;for(c=1;c<o;c++)t[c-1]=t[c];t[o-1]=0;let _=0,v=0,E=Number.EPSILON;for(h=0;h<o;h++){for(v=Math.max(v,Math.abs(e[h])+Math.abs(t[h])),p=h;p<o&&!(Math.abs(t[p])<=E*v);)p++;if(p>h)do{for(a=e[h],s=(e[h+1]-a)/(2*t[h]),r=hypotenuse$1(s,1),s<0&&(r=-r),e[h]=t[h]/(s+r),e[h+1]=t[h]*(s+r),u=e[h+1],l=a-e[h],c=h+2;c<o;c++)e[c]-=l;for(_=_+l,s=e[p],d=1,m=d,b=d,y=t[h+1],w=0,x=0,c=p-1;c>=h;c--)for(b=m,m=d,x=w,a=d*t[c],l=d*s,r=hypotenuse$1(s,t[c]),t[c+1]=w*r,w=t[c]/r,d=s/r,s=d*e[c]-w*a,e[c+1]=l+w*(d*a+w*e[c]),g=0;g<o;g++)l=n.get(g,c+1),n.set(g,c+1,w*n.get(g,c)+d*l),n.set(g,c,d*n.get(g,c)-w*l);s=-w*x*b*y*t[h]/u,t[h]=w*s,e[h]=d*s}while(Math.abs(t[h])>E*v);e[h]=e[h]+_,t[h]=0}for(c=0;c<o-1;c++){for(g=c,s=e[c],f=c+1;f<o;f++)e[f]<s&&(g=f,s=e[f]);if(g!==c)for(e[g]=e[c],e[c]=s,f=0;f<o;f++)s=n.get(f,c),n.set(f,c,n.get(f,g)),n.set(f,g,s)}}function orthes(o,t,e,n){let a=0,l=o-1,c,f,g,h,p,s,r;for(s=a+1;s<=l-1;s++){for(r=0,h=s;h<=l;h++)r=r+Math.abs(t.get(h,s-1));if(r!==0){for(g=0,h=l;h>=s;h--)e[h]=t.get(h,s-1)/r,g+=e[h]*e[h];for(f=Math.sqrt(g),e[s]>0&&(f=-f),g=g-e[s]*f,e[s]=e[s]-f,p=s;p<o;p++){for(c=0,h=l;h>=s;h--)c+=e[h]*t.get(h,p);for(c=c/g,h=s;h<=l;h++)t.set(h,p,t.get(h,p)-c*e[h])}for(h=0;h<=l;h++){for(c=0,p=l;p>=s;p--)c+=e[p]*t.get(h,p);for(c=c/g,p=s;p<=l;p++)t.set(h,p,t.get(h,p)-c*e[p])}e[s]=r*e[s],t.set(s,s-1,r*f)}}for(h=0;h<o;h++)for(p=0;p<o;p++)n.set(h,p,h===p?1:0);for(s=l-1;s>=a+1;s--)if(t.get(s,s-1)!==0){for(h=s+1;h<=l;h++)e[h]=t.get(h,s-1);for(p=s;p<=l;p++){for(f=0,h=s;h<=l;h++)f+=e[h]*n.get(h,p);for(f=f/e[s]/t.get(s,s-1),h=s;h<=l;h++)n.set(h,p,n.get(h,p)+f*e[h])}}}function hqr2(o,t,e,n,a){let l=o-1,c=0,f=o-1,g=Number.EPSILON,h=0,p=0,s=0,r=0,u=0,d=0,m=0,b=0,y,w,x,_,v,E,I,S,T,A,O,$,D,M,F;for(y=0;y<o;y++)for((y<c||y>f)&&(e[y]=a.get(y,y),t[y]=0),w=Math.max(y-1,0);w<o;w++)p=p+Math.abs(a.get(y,w));for(;l>=c;){for(_=l;_>c&&(d=Math.abs(a.get(_-1,_-1))+Math.abs(a.get(_,_)),d===0&&(d=p),!(Math.abs(a.get(_,_-1))<g*d));)_--;if(_===l)a.set(l,l,a.get(l,l)+h),e[l]=a.get(l,l),t[l]=0,l--,b=0;else if(_===l-1){if(I=a.get(l,l-1)*a.get(l-1,l),s=(a.get(l-1,l-1)-a.get(l,l))/2,r=s*s+I,m=Math.sqrt(Math.abs(r)),a.set(l,l,a.get(l,l)+h),a.set(l-1,l-1,a.get(l-1,l-1)+h),S=a.get(l,l),r>=0){for(m=s>=0?s+m:s-m,e[l-1]=S+m,e[l]=e[l-1],m!==0&&(e[l]=S-I/m),t[l-1]=0,t[l]=0,S=a.get(l,l-1),d=Math.abs(S)+Math.abs(m),s=S/d,r=m/d,u=Math.sqrt(s*s+r*r),s=s/u,r=r/u,w=l-1;w<o;w++)m=a.get(l-1,w),a.set(l-1,w,r*m+s*a.get(l,w)),a.set(l,w,r*a.get(l,w)-s*m);for(y=0;y<=l;y++)m=a.get(y,l-1),a.set(y,l-1,r*m+s*a.get(y,l)),a.set(y,l,r*a.get(y,l)-s*m);for(y=c;y<=f;y++)m=n.get(y,l-1),n.set(y,l-1,r*m+s*n.get(y,l)),n.set(y,l,r*n.get(y,l)-s*m)}else e[l-1]=S+s,e[l]=S+s,t[l-1]=m,t[l]=-m;l=l-2,b=0}else{if(S=a.get(l,l),T=0,I=0,_<l&&(T=a.get(l-1,l-1),I=a.get(l,l-1)*a.get(l-1,l)),b===10){for(h+=S,y=c;y<=l;y++)a.set(y,y,a.get(y,y)-S);d=Math.abs(a.get(l,l-1))+Math.abs(a.get(l-1,l-2)),S=T=.75*d,I=-.4375*d*d}if(b===30&&(d=(T-S)/2,d=d*d+I,d>0)){for(d=Math.sqrt(d),T<S&&(d=-d),d=S-I/((T-S)/2+d),y=c;y<=l;y++)a.set(y,y,a.get(y,y)-d);h+=d,S=T=I=.964}for(b=b+1,v=l-2;v>=_&&(m=a.get(v,v),u=S-m,d=T-m,s=(u*d-I)/a.get(v+1,v)+a.get(v,v+1),r=a.get(v+1,v+1)-m-u-d,u=a.get(v+2,v+1),d=Math.abs(s)+Math.abs(r)+Math.abs(u),s=s/d,r=r/d,u=u/d,!(v===_||Math.abs(a.get(v,v-1))*(Math.abs(r)+Math.abs(u))<g*(Math.abs(s)*(Math.abs(a.get(v-1,v-1))+Math.abs(m)+Math.abs(a.get(v+1,v+1))))));)v--;for(y=v+2;y<=l;y++)a.set(y,y-2,0),y>v+2&&a.set(y,y-3,0);for(x=v;x<=l-1&&(M=x!==l-1,x!==v&&(s=a.get(x,x-1),r=a.get(x+1,x-1),u=M?a.get(x+2,x-1):0,S=Math.abs(s)+Math.abs(r)+Math.abs(u),S!==0&&(s=s/S,r=r/S,u=u/S)),S!==0);x++)if(d=Math.sqrt(s*s+r*r+u*u),s<0&&(d=-d),d!==0){for(x!==v?a.set(x,x-1,-d*S):_!==v&&a.set(x,x-1,-a.get(x,x-1)),s=s+d,S=s/d,T=r/d,m=u/d,r=r/s,u=u/s,w=x;w<o;w++)s=a.get(x,w)+r*a.get(x+1,w),M&&(s=s+u*a.get(x+2,w),a.set(x+2,w,a.get(x+2,w)-s*m)),a.set(x,w,a.get(x,w)-s*S),a.set(x+1,w,a.get(x+1,w)-s*T);for(y=0;y<=Math.min(l,x+3);y++)s=S*a.get(y,x)+T*a.get(y,x+1),M&&(s=s+m*a.get(y,x+2),a.set(y,x+2,a.get(y,x+2)-s*u)),a.set(y,x,a.get(y,x)-s),a.set(y,x+1,a.get(y,x+1)-s*r);for(y=c;y<=f;y++)s=S*n.get(y,x)+T*n.get(y,x+1),M&&(s=s+m*n.get(y,x+2),n.set(y,x+2,n.get(y,x+2)-s*u)),n.set(y,x,n.get(y,x)-s),n.set(y,x+1,n.get(y,x+1)-s*r)}}}if(p!==0){for(l=o-1;l>=0;l--)if(s=e[l],r=t[l],r===0)for(_=l,a.set(l,l,1),y=l-1;y>=0;y--){for(I=a.get(y,y)-s,u=0,w=_;w<=l;w++)u=u+a.get(y,w)*a.get(w,l);if(t[y]<0)m=I,d=u;else if(_=y,t[y]===0?a.set(y,l,I!==0?-u/I:-u/(g*p)):(S=a.get(y,y+1),T=a.get(y+1,y),r=(e[y]-s)*(e[y]-s)+t[y]*t[y],E=(S*d-m*u)/r,a.set(y,l,E),a.set(y+1,l,Math.abs(S)>Math.abs(m)?(-u-I*E)/S:(-d-T*E)/m)),E=Math.abs(a.get(y,l)),g*E*E>1)for(w=y;w<=l;w++)a.set(w,l,a.get(w,l)/E)}else if(r<0)for(_=l-1,Math.abs(a.get(l,l-1))>Math.abs(a.get(l-1,l))?(a.set(l-1,l-1,r/a.get(l,l-1)),a.set(l-1,l,-(a.get(l,l)-s)/a.get(l,l-1))):(F=cdiv(0,-a.get(l-1,l),a.get(l-1,l-1)-s,r),a.set(l-1,l-1,F[0]),a.set(l-1,l,F[1])),a.set(l,l-1,0),a.set(l,l,1),y=l-2;y>=0;y--){for(A=0,O=0,w=_;w<=l;w++)A=A+a.get(y,w)*a.get(w,l-1),O=O+a.get(y,w)*a.get(w,l);if(I=a.get(y,y)-s,t[y]<0)m=I,u=A,d=O;else if(_=y,t[y]===0?(F=cdiv(-A,-O,I,r),a.set(y,l-1,F[0]),a.set(y,l,F[1])):(S=a.get(y,y+1),T=a.get(y+1,y),$=(e[y]-s)*(e[y]-s)+t[y]*t[y]-r*r,D=(e[y]-s)*2*r,$===0&&D===0&&($=g*p*(Math.abs(I)+Math.abs(r)+Math.abs(S)+Math.abs(T)+Math.abs(m))),F=cdiv(S*u-m*A+r*O,S*d-m*O-r*A,$,D),a.set(y,l-1,F[0]),a.set(y,l,F[1]),Math.abs(S)>Math.abs(m)+Math.abs(r)?(a.set(y+1,l-1,(-A-I*a.get(y,l-1)+r*a.get(y,l))/S),a.set(y+1,l,(-O-I*a.get(y,l)-r*a.get(y,l-1))/S)):(F=cdiv(-u-T*a.get(y,l-1),-d-T*a.get(y,l),m,r),a.set(y+1,l-1,F[0]),a.set(y+1,l,F[1]))),E=Math.max(Math.abs(a.get(y,l-1)),Math.abs(a.get(y,l))),g*E*E>1)for(w=y;w<=l;w++)a.set(w,l-1,a.get(w,l-1)/E),a.set(w,l,a.get(w,l)/E)}for(y=0;y<o;y++)if(y<c||y>f)for(w=y;w<o;w++)n.set(y,w,a.get(y,w));for(w=o-1;w>=c;w--)for(y=c;y<=f;y++){for(m=0,x=c;x<=Math.min(w,f);x++)m=m+n.get(y,x)*a.get(x,w);n.set(y,w,m)}}}function cdiv(o,t,e,n){let a,l;return Math.abs(e)>Math.abs(n)?(a=n/e,l=e+a*n,[(o+a*t)/l,(t-a*o)/l]):(a=e/n,l=n+a*e,[(a*o+t)/l,(a*t-o)/l])}class CholeskyDecomposition{constructor(t){if(t=WrapperMatrix2D.checkMatrix(t),!t.isSymmetric())throw new Error("Matrix is not symmetric");let e=t,n=e.rows,a=new Matrix$2(n,n),l=!0,c,f,g;for(f=0;f<n;f++){let h=0;for(g=0;g<f;g++){let p=0;for(c=0;c<g;c++)p+=a.get(g,c)*a.get(f,c);p=(e.get(f,g)-p)/a.get(g,g),a.set(f,g,p),h=h+p*p}for(h=e.get(f,f)-h,l&=h>0,a.set(f,f,Math.sqrt(Math.max(h,0))),g=f+1;g<n;g++)a.set(f,g,0)}this.L=a,this.positiveDefinite=!!l}isPositiveDefinite(){return this.positiveDefinite}solve(t){t=WrapperMatrix2D.checkMatrix(t);let e=this.L,n=e.rows;if(t.rows!==n)throw new Error("Matrix dimensions do not match");if(this.isPositiveDefinite()===!1)throw new Error("Matrix is not positive definite");let a=t.columns,l=t.clone(),c,f,g;for(g=0;g<n;g++)for(f=0;f<a;f++){for(c=0;c<g;c++)l.set(g,f,l.get(g,f)-l.get(c,f)*e.get(g,c));l.set(g,f,l.get(g,f)/e.get(g,g))}for(g=n-1;g>=0;g--)for(f=0;f<a;f++){for(c=g+1;c<n;c++)l.set(g,f,l.get(g,f)-l.get(c,f)*e.get(c,g));l.set(g,f,l.get(g,f)/e.get(g,g))}return l}get lowerTriangularMatrix(){return this.L}}class nipals{constructor(t,e={}){t=WrapperMatrix2D.checkMatrix(t);let{Y:n}=e;const{scaleScores:a=!1,maxIterations:l=1e3,terminationCriteria:c=1e-10}=e;let f;if(n){if(isAnyArray(n)&&typeof n[0]=="number"?n=Matrix$2.columnVector(n):n=WrapperMatrix2D.checkMatrix(n),n.rows!==t.rows)throw new Error("Y should have the same number of rows as X");f=n.getColumnVector(0)}else f=t.getColumnVector(0);let g=1,h,p,s,r;for(let u=0;u<l&&g>c;u++)s=t.transpose().mmul(f).div(f.transpose().mmul(f).get(0,0)),s=s.div(s.norm()),h=t.mmul(s).div(s.transpose().mmul(s).get(0,0)),u>0&&(g=h.clone().sub(r).pow(2).sum()),r=h.clone(),n?(p=n.transpose().mmul(h).div(h.transpose().mmul(h).get(0,0)),p=p.div(p.norm()),f=n.mmul(p).div(p.transpose().mmul(p).get(0,0))):f=h;if(n){let u=t.transpose().mmul(h).div(h.transpose().mmul(h).get(0,0));u=u.div(u.norm());let d=t.clone().sub(h.clone().mmul(u.transpose())),m=f.transpose().mmul(h).div(h.transpose().mmul(h).get(0,0)),b=n.clone().sub(h.clone().mulS(m.get(0,0)).mmul(p.transpose()));this.t=h,this.p=u.transpose(),this.w=s.transpose(),this.q=p,this.u=f,this.s=h.transpose().mmul(h),this.xResidual=d,this.yResidual=b,this.betas=m}else this.w=s.transpose(),this.s=h.transpose().mmul(h).sqrt(),a?this.t=h.clone().div(this.s.get(0,0)):this.t=h,this.xResidual=t.sub(h.mmul(s.transpose()))}}var src$1=Object.freeze({__proto__:null,AbstractMatrix,CHO:CholeskyDecomposition,CholeskyDecomposition,EVD:EigenvalueDecomposition,EigenvalueDecomposition,LU:LuDecomposition,LuDecomposition,Matrix:Matrix$2,MatrixColumnSelectionView,MatrixColumnView,MatrixFlipColumnView,MatrixFlipRowView,MatrixRowSelectionView,MatrixRowView,MatrixSelectionView,MatrixSubView,MatrixTransposeView:MatrixTransposeView$1,NIPALS:nipals,Nipals:nipals,QR:QrDecomposition,QrDecomposition,SVD:SingularValueDecomposition,SingularValueDecomposition,WrapperMatrix1D,WrapperMatrix2D,correlation,covariance,default:Matrix$2,determinant,inverse,linearDependencies,pseudoInverse,solve,wrap});function getSeparatedKernel(o){const t=new SingularValueDecomposition(o,{autoTranspose:!0});if(t.rank!==1)return null;const e=Math.sqrt(t.s[0]),n=t.U.to2DArray().map(l=>l[0]*e),a=t.V.to2DArray().map(l=>l[0]*e);return[n,a]}function convolution(o,t={}){let{channels:e,bitDepth:n,normalize:a=!1,divisor:l=1,border:c="copy",algorithm:f="auto"}=t,g={};n&&(g.bitDepth=n);let h=Image$1.createFrom(this,g);if(e=validateArrayOfChannels(this,e),f!=="separable")({kernel:o}=validateKernel(o));else if(!Array.isArray(o)||o.length!==2)throw new RangeError("separable convolution requires two arrays of numbers to represent the kernel");if(f==="auto"){let _=getSeparatedKernel(o);_!==null?(f="separable",o=_):(o.length>9||o[0].length>9)&&this.width<=4096&&this.height<=4096?f="fft":f="direct"}let p,s;f==="separable"?(p=Math.floor(o[0].length/2),s=Math.floor(o[1].length/2)):(p=Math.floor(o.length/2),s=Math.floor(o[0].length/2));let r=h.isClamped,u=new Array(this.height*this.width),d,m,b,y,w,x;for(y=0;y<e.length;y++){for(w=e[y],b=0;b<this.height;b++)for(m=0;m<this.width;m++)d=b*this.width+m,u[d]=this.data[d*this.channels+w];if(f==="direct")x=src$2.direct(u,o,{rows:this.height,cols:this.width,normalize:a,divisor:l});else if(f==="separable"){if(x=convolutionSeparable(u,o,this.width,this.height),a){l=0;for(let _=0;_<o[0].length;_++)for(let v=0;v<o[1].length;v++)l+=o[0][_]*o[1][v]}if(l!==1)for(let _=0;_<x.length;_++)x[_]/=l}else x=src$2.fft(u,o,{rows:this.height,cols:this.width,normalize:a,divisor:l});for(b=0;b<this.height;b++)for(m=0;m<this.width;m++)d=b*this.width+m,r?h.data[d*this.channels+w]=clamp(x[d],h):h.data[d*this.channels+w]=x[d]}if(this.alpha&&!e.includes(this.channels))for(m=this.components;m<this.data.length;m=m+this.channels)h.data[m]=this.data[m];return c!=="periodic"&&h.setBorder({size:[s,p],algorithm:c}),h}function gradientFilter(o={}){let{direction:t="xy",border:e="copy",kernelX:n,kernelY:a,channels:l,bitDepth:c=this.bitDepth}=o;switch(this.checkProcessable("gradientFilter",{bitDepth:[8,16]}),t){case"x":if(!n)throw new Error("kernelX option is missing");return convolution.call(this,n,{channels:l,border:e,bitDepth:c});case"y":if(!a)throw new Error("kernelY option is missing");return convolution.call(this,a,{channels:l,border:e,bitDepth:c});case"xy":{if(!n)throw new Error("kernelX option is missing");if(!a)throw new Error("kernelY option is missing");const f=convolution.call(this,n,{channels:l,border:e,bitDepth:32}),g=convolution.call(this,a,{channels:l,border:e,bitDepth:32});return f.hypotenuse(g,{bitDepth:c,channels:l})}default:throw new Error(`Unknown parameter direction: ${t}`)}}function sobelFilter(o){return gradientFilter.call(this,Object.assign({},o,{kernelX:SOBEL_X,kernelY:SOBEL_Y}))}function scharrFilter(o){return gradientFilter.call(this,Object.assign({},o,{kernelX:SCHARR_X,kernelY:SCHARR_Y}))}var newArray_1=newArray;function newArray(o,t){o=o||0;for(var e=new Array(o),n=0;n<o;n++)e[n]=t;return e}var newArray$1=getDefaultExportFromCjs(newArray_1);function level(o={}){let{algorithm:t="range",channels:e,min:n=this.min,max:a=this.max}=o;switch(this.checkProcessable("level",{bitDepth:[8,16,32]}),e=validateArrayOfChannels(this,{channels:e}),e.length!==this.channel&&(Array.isArray(n)&&n.length===this.channels&&(n=n.filter((l,c)=>e.includes(c))),Array.isArray(a)&&a.length===this.channels&&(a=a.filter((l,c)=>e.includes(c)))),t){case"range":n<0&&(n=0),a>this.maxValue&&(a=this.maxValue),Array.isArray(n)||(n=newArray$1(e.length,n)),Array.isArray(a)||(a=newArray$1(e.length,a)),processImage(this,n,a,e);break;default:throw new Error(`level: algorithm not implement: ${t}`)}return this}function processImage(o,t,e,n){let a=1e-5,l=new Array(n.length);for(let c=0;c<n.length;c++)t[c]===0&&e[c]===o.maxValue||e[c]===t[c]?l[c]=0:l[c]=(o.maxValue+1-a)/(e[c]-t[c]),t[c]+=(.5-a/2)/l[c];for(let c=0;c<n.length;c++){let f=n[c];if(l[c]!==0)for(let g=0;g<o.data.length;g+=o.channels)o.data[g+f]=Math.min(Math.max(0,(o.data[g+f]-t[c])*l[c]+.5|0),o.maxValue)}}var toString=Object.prototype.toString,isArrayType=function o(t){return toString.call(t).substr(-6,5)==="Array"},isArray=getDefaultExportFromCjs(isArrayType);function checkNumberArray(o){if(isNaN(o)){if(o instanceof Image$1)return o.data;if(!isArray(o))throw new Error("checkNumberArray: the value should be either a number, array or Image");return o}else{if(o<=0)throw new Error("checkNumberArray: the value must be greater than 0");return o}}function add(o,t={}){let{channels:e}=t;if(this.checkProcessable("add",{bitDepth:[8,16]}),e=validateArrayOfChannels(this,{channels:e}),o=checkNumberArray(o),isNaN(o)){if(this.data.length!==o.length)throw new Error("add: the data size is different");for(let n=0;n<e.length;n++){let a=e[n];for(let l=0;l<this.data.length;l+=this.channels)this.data[l+a]=Math.max(0,Math.min(this.maxValue,this.data[l+a]+o[l+a]>>0))}}else for(let n=0;n<e.length;n++){let a=e[n];for(let l=0;l<this.data.length;l+=this.channels)this.data[l+a]=Math.min(this.maxValue,this.data[l+a]+o>>0)}return this}function subtract(o,t={}){let{channels:e}=t;if(this.checkProcessable("subtract",{bitDepth:[8,16]}),e=validateArrayOfChannels(this,{channels:e}),o=checkNumberArray(o),isNaN(o)){if(this.data.length!==o.length)throw new Error("subtract: the data size is different");for(let n=0;n<e.length;n++){let a=e[n];for(let l=0;l<this.data.length;l+=this.channels)this.data[l+a]=Math.max(0,Math.min(this.maxValue,this.data[l+a]-o[l+a]>>0))}}else for(let n=0;n<e.length;n++){let a=e[n];for(let l=0;l<this.data.length;l+=this.channels)this.data[l+a]=Math.max(0,this.data[l+a]-o>>0)}return this}function subtractImage(o,t={}){let{channels:e,absolute:n=!1}=t;if(this.checkProcessable("subtractImage",{bitDepth:[8,16]}),this.width!==o.width||this.height!==o.height)throw new Error("subtractImage: both images must have the same size");if(this.alpha!==o.alpha||this.bitDepth!==o.bitDepth)throw new Error("subtractImage: both images must have the same alpha and bitDepth");if(this.channels!==o.channels)throw new Error("subtractImage: both images must have the same number of channels");let a=this.clone();e=validateArrayOfChannels(this,{channels:e});for(let l=0;l<e.length;l++){let c=e[l];for(let f=c;f<this.data.length;f+=this.channels){let g=this.data[f]-o.data[f];n?a.data[f]=Math.abs(g):a.data[f]=Math.max(g,0)}}return a}function hypotenuse(o,t={}){let{bitDepth:e=this.bitDepth,channels:n}=t;if(this.checkProcessable("hypotenuse",{bitDepth:[8,16,32]}),this.width!==o.width||this.height!==o.height)throw new Error("hypotenuse: both images must have the same size");if(this.alpha!==o.alpha||this.bitDepth!==o.bitDepth)throw new Error("hypotenuse: both images must have the same alpha and bitDepth");if(this.channels!==o.channels)throw new Error("hypotenuse: both images must have the same number of channels");let a=Image$1.createFrom(this,{bitDepth:e});n=validateArrayOfChannels(this,{channels:n});let l=a.isClamped;for(let c=0;c<n.length;c++){let f=n[c];for(let g=f;g<this.data.length;g+=this.channels){let h=Math.hypot(this.data[g],o.data[g]);l?a.data[g]=Math.min(Math.max(Math.round(h),0),a.maxValue):a.data[g]=h}}return a}function multiply(o,t={}){let{channels:e}=t;if(this.checkProcessable("multiply",{bitDepth:[8,16]}),o<=0)throw new Error("multiply: the value must be greater than 0");if(e=validateArrayOfChannels(this,{channels:e}),o=checkNumberArray(o),isNaN(o)){if(this.data.length!==o.length)throw new Error("multiply: the data size is different");for(let n=0;n<e.length;n++){let a=e[n];for(let l=0;l<this.data.length;l+=this.channels)this.data[l+a]=Math.max(0,Math.min(this.maxValue,this.data[l+a]*o[l+a]>>0))}}else for(let n=0;n<e.length;n++){let a=e[n];for(let l=0;l<this.data.length;l+=this.channels)this.data[l+a]=Math.min(this.maxValue,this.data[l+a]*o>>0)}return this}function divide(o,t={}){let{channels:e}=t;if(this.checkProcessable("divide",{bitDepth:[8,16]}),e=validateArrayOfChannels(this,{channels:e}),o=checkNumberArray(o),isNaN(o)){if(this.data.length!==o.length)throw new Error("divide: the: the data size is different");for(let n=0;n<e.length;n++){let a=e[n];for(let l=0;l<this.data.length;l+=this.channels)this.data[l+a]=Math.max(0,Math.min(this.maxValue,this.data[l+a]/o[l+a]>>0))}}else for(let n=0;n<e.length;n++){let a=e[n];for(let l=0;l<this.data.length;l+=this.channels)this.data[l+a]=Math.min(this.maxValue,this.data[l+a]/o>>0)}return this}class BaseRegression{constructor(){if(new.target===BaseRegression)throw new Error("BaseRegression must be subclassed")}predict(t){if(typeof t=="number")return this._predict(t);if(isAnyArray(t)){const e=[];for(let n=0;n<t.length;n++)e.push(this._predict(t[n]));return e}else throw new TypeError("x must be a number or array")}_predict(){throw new Error("_predict must be implemented")}train(){}toString(){return""}toLaTeX(){return""}score(t,e){if(!isAnyArray(t)||!isAnyArray(e)||t.length!==e.length)throw new Error("x and y must be arrays of the same length");const n=t.length,a=new Array(n);for(let u=0;u<n;u++)a[u]=this._predict(t[u]);let l=0,c=0,f=0,g=0,h=0,p=0,s=0;for(let u=0;u<n;u++)l+=a[u],c+=e[u],h+=a[u]*a[u],p+=e[u]*e[u],s+=a[u]*e[u],e[u]!==0&&(f+=(e[u]-a[u])*(e[u]-a[u])/e[u]),g+=(e[u]-a[u])*(e[u]-a[u]);const r=(n*s-l*c)/Math.sqrt((n*h-l*l)*(n*p-c*c));return{r,r2:r*r,chi2:f,rmsd:Math.sqrt(g/n)}}}var require$$0$1=getAugmentedNamespace(src$1);function squaredEuclidean$4(o,t){let e=0;for(let n=0;n<o.length;n++)e+=(o[n]-t[n])*(o[n]-t[n]);return e}function euclidean$2(o,t){return Math.sqrt(squaredEuclidean$4(o,t))}var euclidean$3=Object.freeze({__proto__:null,euclidean:euclidean$2,squaredEuclidean:squaredEuclidean$4}),require$$0=getAugmentedNamespace(euclidean$3);const{squaredEuclidean:squaredEuclidean$3}=require$$0,defaultOptions$b={sigma:1};let GaussianKernel$1=class{constructor(t){t=Object.assign({},defaultOptions$b,t),this.sigma=t.sigma,this.divisor=2*t.sigma*t.sigma}compute(t,e){const n=squaredEuclidean$3(t,e);return Math.exp(-n/this.divisor)}};var gaussianKernel=GaussianKernel$1;const defaultOptions$a={degree:1,constant:1,scale:1};let PolynomialKernel$1=class{constructor(t){t=Object.assign({},defaultOptions$a,t),this.degree=t.degree,this.constant=t.constant,this.scale=t.scale}compute(t,e){for(var n=0,a=0;a<t.length;a++)n+=t[a]*e[a];return Math.pow(this.scale*n+this.constant,this.degree)}};var polynomialKernel=PolynomialKernel$1;const defaultOptions$9={alpha:.01,constant:-Math.E};let SigmoidKernel$1=class{constructor(t){t=Object.assign({},defaultOptions$9,t),this.alpha=t.alpha,this.constant=t.constant}compute(t,e){for(var n=0,a=0;a<t.length;a++)n+=t[a]*e[a];return Math.tanh(this.alpha*n+this.constant)}};var sigmoidKernel=SigmoidKernel$1;const defaultOptions$8={sigma:1,degree:1};let ANOVAKernel$1=class{constructor(t){t=Object.assign({},defaultOptions$8,t),this.sigma=t.sigma,this.degree=t.degree}compute(t,e){for(var n=0,a=Math.min(t.length,e.length),l=1;l<=a;++l)n+=Math.pow(Math.exp(-this.sigma*Math.pow(Math.pow(t[l-1],l)-Math.pow(e[l-1],l),2)),this.degree);return n}};var anovaKernel=ANOVAKernel$1;const{squaredEuclidean:squaredEuclidean$2}=require$$0,defaultOptions$7={sigma:1};let CauchyKernel$1=class{constructor(t){t=Object.assign({},defaultOptions$7,t),this.sigma=t.sigma}compute(t,e){return 1/(1+squaredEuclidean$2(t,e)/(this.sigma*this.sigma))}};var cauchyKernel=CauchyKernel$1;const{euclidean:euclidean$1}=require$$0,defaultOptions$6={sigma:1};let ExponentialKernel$1=class{constructor(t){t=Object.assign({},defaultOptions$6,t),this.sigma=t.sigma,this.divisor=2*t.sigma*t.sigma}compute(t,e){const n=euclidean$1(t,e);return Math.exp(-n/this.divisor)}};var exponentialKernel=ExponentialKernel$1;class HistogramIntersectionKernel{compute(t,e){for(var n=Math.min(t.length,e.length),a=0,l=0;l<n;++l)a+=Math.min(t[l],e[l]);return a}}var histogramIntersectionKernel=HistogramIntersectionKernel;const{euclidean}=require$$0,defaultOptions$5={sigma:1};let LaplacianKernel$1=class{constructor(t){t=Object.assign({},defaultOptions$5,t),this.sigma=t.sigma}compute(t,e){const n=euclidean(t,e);return Math.exp(-n/this.sigma)}};var laplacianKernel=LaplacianKernel$1;const{squaredEuclidean:squaredEuclidean$1}=require$$0,defaultOptions$4={constant:1};let MultiquadraticKernel$1=class{constructor(t){t=Object.assign({},defaultOptions$4,t),this.constant=t.constant}compute(t,e){return Math.sqrt(squaredEuclidean$1(t,e)+this.constant*this.constant)}};var multiquadraticKernel=MultiquadraticKernel$1;const{squaredEuclidean}=require$$0,defaultOptions$3={constant:1};class RationalQuadraticKernel{constructor(t){t=Object.assign({},defaultOptions$3,t),this.constant=t.constant}compute(t,e){const n=squaredEuclidean(t,e);return 1-n/(n+this.constant)}}var rationalQuadraticKernel=RationalQuadraticKernel;const{Matrix:Matrix$1,MatrixTransposeView}=require$$0$1,GaussianKernel=gaussianKernel,PolynomialKernel=polynomialKernel,SigmoidKernel=sigmoidKernel,ANOVAKernel=anovaKernel,CauchyKernel=cauchyKernel,ExponentialKernel=exponentialKernel,HistogramKernel=histogramIntersectionKernel,LaplacianKernel=laplacianKernel,MultiquadraticKernel=multiquadraticKernel,RationalKernel=rationalQuadraticKernel,kernelType={gaussian:GaussianKernel,rbf:GaussianKernel,polynomial:PolynomialKernel,poly:PolynomialKernel,anova:ANOVAKernel,cauchy:CauchyKernel,exponential:ExponentialKernel,histogram:HistogramKernel,min:HistogramKernel,laplacian:LaplacianKernel,multiquadratic:MultiquadraticKernel,rational:RationalKernel,sigmoid:SigmoidKernel,mlp:SigmoidKernel};class Kernel{constructor(t,e){if(this.kernelType=t,t!=="linear")if(typeof t=="string"){t=t.toLowerCase();var n=kernelType[t];if(n)this.kernelFunction=new n(e);else throw new Error(`unsupported kernel type: ${t}`)}else if(typeof t=="object"&&typeof t.compute=="function")this.kernelFunction=t;else throw new TypeError("first argument must be a valid kernel type or instance")}compute(t,e){if(t=Matrix$1.checkMatrix(t),e===void 0?e=t:e=Matrix$1.checkMatrix(e),this.kernelType==="linear")return t.mmul(new MatrixTransposeView(e));const n=new Matrix$1(t.rows,e.rows);if(t===e)for(let a=0;a<t.rows;a++)for(let l=a;l<t.rows;l++){const c=this.kernelFunction.compute(t.getRow(a),t.getRow(l));n.set(a,l,c),n.set(l,a,c)}else for(let a=0;a<t.rows;a++)for(let l=0;l<e.rows;l++)n.set(a,l,this.kernelFunction.compute(t.getRow(a),e.getRow(l)));return n}}var kernel=Kernel,Kernel$1=getDefaultExportFromCjs(kernel);const defaultOptions$2={lambda:.1,kernelType:"gaussian",kernelOptions:{},computeCoefficient:!1};class KernelRidgeRegression extends BaseRegression{constructor(t,e,n){if(super(),t===!0)this.alpha=e.alpha,this.inputs=e.inputs,this.kernelType=e.kernelType,this.kernelOptions=e.kernelOptions,this.kernel=new Kernel$1(e.kernelType,e.kernelOptions);else{t=Matrix$2.checkMatrix(t),n=Object.assign({},defaultOptions$2,n);const a=new Kernel$1(n.kernelType,n.kernelOptions),l=a.compute(t),c=t.rows;l.add(Matrix$2.eye(c,c).mul(n.lambda)),this.alpha=solve(l,e),this.inputs=t,this.kernelType=n.kernelType,this.kernelOptions=n.kernelOptions,this.kernel=a}}_predict(t){return this.kernel.compute([t],this.inputs).mmul(this.alpha).getRow(0)}toJSON(){return{name:"kernelRidgeRegression",alpha:this.alpha,inputs:this.inputs,kernelType:this.kernelType,kernelOptions:this.kernelOptions}}static load(t){if(t.name!=="kernelRidgeRegression")throw new TypeError("not a KRR model");return new KernelRidgeRegression(!0,t)}}function background$1(o,t,e){const n=new KernelRidgeRegression(o,t,e),a=new Array(this.size);for(let f=0;f<this.width;f++)for(let g=0;g<this.height;g++)a[g*this.width+f]=[f,g];const l=n.predict(a),c=Image$1.createFrom(this);for(let f=0;f<this.size;f++)c.data[f]=Math.min(this.maxValue,Math.max(0,l[f][0]));return c}function dilate(o={}){let{kernel:t=[[1,1,1],[1,1,1],[1,1,1]],iterations:e=1}=o;if(this.checkProcessable("dilate",{bitDepth:[1,8,16],components:1,alpha:0}),t.columns%2===0||t.rows%2===0)throw new TypeError("dilate: The number of rows and columns of the kernel must be odd");let n=!0;t:for(const l of t)for(const c of l)if(c!==1){n=!1;break t}let a=this;for(let l=0;l<e;l++)if(this.bitDepth===1)if(n){const c=a.clone();a=dilateOnceBinaryOnlyOnes(a,c,t.length,t[0].length)}else{const c=Image$1.createFrom(a);a=dilateOnceBinary(a,c,t)}else if(n){const c=Image$1.createFrom(a);a=dilateOnceGreyOnlyOnes(a,c,t.length,t[0].length)}else{const c=Image$1.createFrom(a);a=dilateOnceGrey(a,c,t)}return a}function dilateOnceGrey(o,t,e){const n=e.length,a=e[0].length;let l=(n-1)/2,c=(a-1)/2;for(let f=0;f<o.height;f++)for(let g=0;g<o.width;g++){let h=0;for(let p=0;p<a;p++)for(let s=0;s<n;s++){if(e[s][p]!==1)continue;let r=s-l+g,u=p-c+f;if(r<0||u<0||r>=o.width||u>=o.height)continue;const d=o.getValueXY(r,u,0);d>h&&(h=d)}t.setValueXY(g,f,0,h)}return t}function dilateOnceGreyOnlyOnes(o,t,e,n){const a=(e-1)/2,l=(n-1)/2,c=[];for(let f=0;f<o.width;f++)c.push(0);for(let f=0;f<o.height;f++){for(let g=0;g<o.width;g++){let h=0;for(let p=Math.max(0,f-l);p<Math.min(o.height,f+l+1);p++){const s=o.getValueXY(g,p,0);s>h&&(h=s)}c[g]=h}for(let g=0;g<o.width;g++){let h=0;for(let p=Math.max(0,g-a);p<Math.min(o.width,g+a+1);p++)c[p]>h&&(h=c[p]);t.setValueXY(g,f,0,h)}}return t}function dilateOnceBinary(o,t,e){const n=e.length,a=e[0].length;let l=(n-1)/2,c=(a-1)/2;for(let f=0;f<o.height;f++)for(let g=0;g<o.width;g++){let h=0;t:for(let p=0;p<a;p++)for(let s=0;s<n;s++){if(e[s][p]!==1)continue;let r=s-l+g,u=p-c+f;if(u<0||r<0||r>=o.width||u>=o.height)continue;if(o.getBitXY(r,u)===1){h=1;break t}}h===1&&t.setBitXY(g,f)}return t}function dilateOnceBinaryOnlyOnes(o,t,e,n){const a=(e-1)/2,l=(n-1)/2,c=[];for(let f=0;f<o.width;f++)c.push(1);for(let f=0;f<o.height;f++){for(let g=0;g<o.width;g++){c[g]=0;for(let h=Math.max(0,f-l);h<Math.min(o.height,f+l+1);h++)if(o.getBitXY(g,h)===1){c[g]=1;break}}for(let g=0;g<o.width;g++)if(t.getBitXY(g,f)!==1){for(let h=Math.max(0,g-a);h<Math.min(o.width,g+a+1);h++)if(c[h]===1){t.setBitXY(g,f);break}}}return t}function erode(o={}){let{kernel:t=[[1,1,1],[1,1,1],[1,1,1]],iterations:e=1}=o;if(this.checkProcessable("erode",{bitDepth:[1,8,16],components:1,alpha:0}),t.columns%2===0||t.rows%2===0)throw new TypeError("erode: The number of rows and columns of the kernel must be odd");let n=!0;t:for(const l of t)for(const c of l)if(c!==1){n=!1;break t}let a=this;for(let l=0;l<e;l++)if(this.bitDepth===1)if(n){const c=a.clone();a=erodeOnceBinaryOnlyOnes(a,c,t.length,t[0].length)}else{const c=Image$1.createFrom(a);a=erodeOnceBinary(a,c,t)}else if(n){const c=Image$1.createFrom(a);a=erodeOnceGreyOnlyOnes(a,c,t.length,t[0].length)}else{const c=Image$1.createFrom(a);a=erodeOnceGrey(a,c,t)}return a}function erodeOnceGrey(o,t,e){const n=e.length,a=e[0].length;let l=(n-1)/2,c=(a-1)/2;for(let f=0;f<o.height;f++)for(let g=0;g<o.width;g++){let h=o.maxValue;for(let p=0;p<a;p++)for(let s=0;s<n;s++){if(e[s][p]!==1)continue;let r=s-l+g,u=p-c+f;if(r<0||u<0||r>=o.width||u>=o.height)continue;const d=o.getValueXY(r,u,0);d<h&&(h=d)}t.setValueXY(g,f,0,h)}return t}function erodeOnceGreyOnlyOnes(o,t,e,n){const a=(e-1)/2,l=(n-1)/2,c=[];for(let f=0;f<o.width;f++)c.push(0);for(let f=0;f<o.height;f++){for(let g=0;g<o.width;g++){let h=o.maxValue;for(let p=Math.max(0,f-l);p<Math.min(o.height,f+l+1);p++){const s=o.getValueXY(g,p,0);s<h&&(h=s)}c[g]=h}for(let g=0;g<o.width;g++){let h=o.maxValue;for(let p=Math.max(0,g-a);p<Math.min(o.width,g+a+1);p++)c[p]<h&&(h=c[p]);t.setValueXY(g,f,0,h)}}return t}function erodeOnceBinary(o,t,e){const n=e.length,a=e[0].length;let l=(n-1)/2,c=(a-1)/2;for(let f=0;f<o.height;f++)for(let g=0;g<o.width;g++){let h=1;t:for(let p=0;p<a;p++)for(let s=0;s<n;s++){if(e[s][p]!==1)continue;let r=s-l+g,u=p-c+f;if(u<0||r<0||r>=o.width||u>=o.height)continue;if(o.getBitXY(r,u)===0){h=0;break t}}h===1&&t.setBitXY(g,f)}return t}function erodeOnceBinaryOnlyOnes(o,t,e,n){const a=(e-1)/2,l=(n-1)/2,c=[];for(let f=0;f<o.width;f++)c.push(0);for(let f=0;f<o.height;f++){for(let g=0;g<o.width;g++){c[g]=1;for(let h=Math.max(0,f-l);h<Math.min(o.height,f+l+1);h++)if(o.getBitXY(g,h)===0){c[g]=0;break}}for(let g=0;g<o.width;g++)if(t.getBitXY(g,f)!==0){for(let h=Math.max(0,g-a);h<Math.min(o.width,g+a+1);h++)if(c[h]===0){t.clearBitXY(g,f);break}}}return t}function open(o={}){let{kernel:t=[[1,1,1],[1,1,1],[1,1,1]],iterations:e=1}=o;if(this.checkProcessable("open",{bitDepth:[8,16],components:1,alpha:0}),t.columns%2===0||t.rows%2===0)throw new TypeError("open: The number of rows and columns of the kernel must be odd");let n=this;for(let a=0;a<e;a++)n=n.erode({kernel:t}),n=n.dilate({kernel:t});return n}function close(o={}){let{kernel:t=[[1,1,1],[1,1,1],[1,1,1]],iterations:e=1}=o;if(this.checkProcessable("close",{bitDepth:[1,8,16],components:1,alpha:0}),t.columns%2===0||t.rows%2===0)throw new TypeError("close: The number of rows and columns of the kernel must be odd");let n=this;for(let a=0;a<e;a++)n=n.dilate({kernel:t}).erode({kernel:t});return n}function topHat(o={}){let{kernel:t=[[1,1,1],[1,1,1],[1,1,1]],iterations:e=1}=o;if(this.checkProcessable("topHat",{bitDepth:[8,16],components:1,alpha:0}),t.length%2===0||t[0].length%2===0)throw new TypeError("topHat: The number of rows and columns of the kernel must be odd");let n=this;for(let a=0;a<e;a++)n=n.open({kernel:t}).subtractImage(n,{absolute:!0});return n}function blackHat(o={}){let{kernel:t=[[1,1,1],[1,1,1],[1,1,1]],iterations:e=1}=o;if(this.checkProcessable("blackHat",{bitDepth:[8,16],components:1,alpha:0}),t.columns%2===0||t.rows%2===0)throw new TypeError("blackHat: The number of rows and columns of the kernel must be odd");let n=this;for(let a=0;a<e;a++)n=n.close({kernel:t}).subtractImage(n,{absolute:!0});return n}function morphologicalGradient(o={}){let{kernel:t=[[1,1,1],[1,1,1],[1,1,1]],iterations:e=1}=o;if(this.checkProcessable("morphologicalGradient",{bitDepth:[8,16],components:1,alpha:0}),t.columns%2===0||t.rows%2===0)throw new TypeError("morphologicalGradient: The number of rows and columns of the kernel must be odd");let n=this;for(let a=0;a<e;a++){let l=n.dilate({kernel:t}),c=n.erode({kernel:t});n=l.subtractImage(c,{absolute:!0})}return n}function order4Points(o){let t=0,e=0,n=0,a=0,l=o[0][0],c=0;for(let h=1;h<o.length;h++)o[h][0]<l&&(l=o[h][0],c=h);let f=o[(c+1)%o.length][0],g=(c+1)%o.length;for(let h=1;h<o.length;h++)o[h][0]<f&&h!==c&&(f=o[h][0],g=h);return o[g][1]<o[c][1]?(t=o[g],a=o[c],c!==(g+1)%4?(e=o[(g+1)%4],n=o[(g+2)%4]):(e=o[(g+2)%4],n=o[(g+3)%4])):(a=o[g],t=o[c],g!==(c+1)%4?(e=o[(c+1)%4],n=o[(c+2)%4]):(e=o[(c+2)%4],n=o[(c+3)%4])),[t,e,n,a]}function distance2Points(o,t){return Math.sqrt(Math.pow(o[0]-t[0],2)+Math.pow(o[1]-t[1],2))}function crossVect(o,t){return[o[1]*t[2]-o[2]*t[1],o[2]*t[0]-o[0]*t[2],o[0]*t[1]-o[1]*t[0]]}function dotVect(o,t){return o[0]*t[0]+o[1]*t[1]+o[2]*t[2]}function computeWidthAndHeigth(o,t,e,n,a,l){let c=Math.max(distance2Points(o,t),distance2Points(n,e)),f=Math.max(distance2Points(o,n),distance2Points(t,e)),g=0,h=0,p=Math.ceil(a/2),s=Math.ceil(l/2),r=c/f,u=[o[0],o[1],1],d=[t[0],t[1],1],m=[n[0],n[1],1],b=[e[0],e[1],1],y=dotVect(crossVect(u,b),m)/dotVect(crossVect(d,b),m),w=dotVect(crossVect(u,b),d)/dotVect(crossVect(m,b),d),x=[y*d[0]-u[0],y*d[1]-u[1],y*d[2]-u[2]],_=[w*m[0]-u[0],w*m[1]-u[1],w*m[2]-u[2]],v=x[0],E=x[1],I=x[2],S=_[0],T=_[1],A=_[2],O=1/(I*A)*(v*S-(v*A+I*S)*p+I*A*p*p+(E*T-(E*A+I*T)*s+I*A*s*s));O>=0?O=Math.sqrt(O):O=Math.sqrt(-O);let $=new Matrix$2([[O,0,p],[0,O,s],[0,0,1]]),D=$.transpose(),M=inverse(D),F=inverse($),C=Matrix$2.rowVector(x),R=Matrix$2.rowVector(_),j=Math.sqrt(dotVect(C.mmul(M).mmul(F).to1DArray(),x)/dotVect(R.mmul(M).mmul(F).to1DArray(),_));return j===0||r===0?(g=Math.ceil(c),h=Math.ceil(f)):j<r?(g=Math.ceil(c),h=Math.ceil(g/j)):(h=Math.ceil(f),g=Math.ceil(j*h)),[g,h]}function projectionPoint(o,t,e,n,a,l,c,f,g,h,p,s){let[r,u]=[(e*o+n*t+a)/(g*o+h*t+1),(l*o+c*t+f)/(g*o+h*t+1)];return p.getValueXY(Math.floor(r),Math.floor(u),s)}function warpingFourPoints(o,t={}){let{calculateRatio:e=!0}=t;if(o.length!==4)throw new Error(`The array pts must have four elements, which are the four corners. Currently, pts have ${o.length} elements`);let[n,a,l,c]=o,f=[n,a,l,c],[g,h,p,s]=order4Points(f),r,u;e?[r,u]=computeWidthAndHeigth(g,h,p,s,this.width,this.height):(r=Math.ceil(Math.max(distance2Points(g,h),distance2Points(s,p))),u=Math.ceil(Math.max(distance2Points(g,s),distance2Points(h,p))));let d=Image$1.createFrom(this,{width:r,height:u}),[m,b]=g,[y,w]=h,[x,_]=p,[v,E]=s,[I,S]=[0,0],[T,A]=[0,r-1],[O,$]=[u-1,r-1],[D,M]=[u-1,0],F=new Matrix$2([[I,S,1,0,0,0,-I*m,-S*m],[T,A,1,0,0,0,-T*y,-A*y],[O,$,1,0,0,0,-O*x,-S*x],[D,M,1,0,0,0,-D*v,-M*v],[0,0,0,I,S,1,-I*b,-S*b],[0,0,0,T,A,1,-T*w,-A*w],[0,0,0,O,$,1,-O*_,-$*_],[0,0,0,D,M,1,-D*E,-M*E]]),C=Matrix$2.columnVector([m,y,x,v,b,w,_,E]),j=new SingularValueDecomposition(F).solve(C),[G,W,Z,at,J,Y,K,it]=j.to1DArray(),rt=new Matrix$2(u,r);for(let yt=0;yt<this.channels;yt++){for(let ut=0;ut<u;ut++)for(let St=0;St<r;St++)rt.set(ut,St,projectionPoint(ut,St,G,W,Z,at,J,Y,K,it,this,yt));d.setMatrix(rt,{channel:yt})}return d}function crop(o={}){let{x:t=0,y:e=0,width:n=this.width-t,height:a=this.height-e}=o;if(this.checkProcessable("crop",{bitDepth:[1,8,16]}),t=Math.round(t),e=Math.round(e),n=Math.round(n),a=Math.round(a),t>this.width-1||e>this.height-1)throw new RangeError(`crop: origin (x:${t}, y:${e}) out of range (${this.width-1}; ${this.height-1})`);if(n<=0||a<=0)throw new RangeError(`crop: width and height (width:${n}; height:${a}) must be positive numbers`);if(t<0||e<0)throw new RangeError(`crop: x and y (x:${t}, y:${e}) must be positive numbers`);if(n>this.width-t||a>this.height-e)throw new RangeError(`crop: (x: ${t}, y:${e}, width:${n}, height:${a}) size is out of range`);let l=this;if(this.bitDepth===1){const c=new Image$1(n,a,{kind:"BINARY",parent:this});l=cropBinary(this,c,t,e,n,a)}else{const c=Image$1.createFrom(this,{width:n,height:a,position:[t,e]});l=cropDefault(this,c,t,e,n,a)}return l}function cropDefault(o,t,e,n,a,l){let c=a*o.channels,f=n+l,g=0,h=e*o.channels;for(let p=n;p<f;p++){let s=p*o.width*o.channels+h,r=s+c;for(;s<r;s++)t.data[g++]=o.data[s]}return t}function cropBinary(o,t,e,n,a,l){let c=a*o.channels,f=n+l,g=0,h=e*o.channels;for(let p=n;p<f;p++){let s=p*o.width*o.channels+h,r=s+c;for(;s<r;s++)o.getBit(s)&&t.setBit(g),++g}return t}function cropAlpha(o={}){this.checkProcessable("cropAlpha",{alpha:1});const{threshold:t=this.maxValue}=o;let e=findLeft(this,t,this.components);if(e===-1)throw new Error("Could not find new dimensions. Threshold may be too high.");let n=findTop(this,t,this.components,e),a=findBottom(this,t,this.components,e),l=findRight(this,t,this.components,e,n,a);return this.crop({x:e,y:n,width:l-e+1,height:a-n+1})}function findLeft(o,t,e){for(let n=0;n<o.width;n++)for(let a=0;a<o.height;a++)if(o.getValueXY(n,a,e)>=t)return n;return-1}function findTop(o,t,e,n){for(let a=0;a<o.height;a++)for(let l=n;l<o.width;l++)if(o.getValueXY(l,a,e)>=t)return a;return-1}function findBottom(o,t,e,n){for(let a=o.height-1;a>=0;a--)for(let l=n;l<o.width;l++)if(o.getValueXY(l,a,e)>=t)return a;return-1}function findRight(o,t,e,n,a,l){for(let c=o.width-1;c>=n;c--)for(let f=a;f<=l;f++)if(o.getValueXY(c,f,e)>=t)return c;return-1}function getFactor(o){if(typeof o=="string"){const t=o[o.length-1];o=parseFloat(o),t==="%"&&(o/=100)}return o}function getThreshold$1(o,t){if(!t)throw Error("getThreshold : the maxValue should be specified");if(typeof o=="string"){if(o[o.length-1]!=="%")throw Error("getThreshold : if the value is a string it must finish by %");return parseFloat(o)/100*t}else{if(typeof o=="number")return o<1?o*t:o;throw Error("getThreshold : the value is not valid")}}function factorDimensions(o,t,e){o=getFactor(o);let n=Math.round(o*t),a=Math.round(o*e);return n<=0&&(n=1),a<=0&&(a=1),{width:n,height:a}}function checkRow(o,t){if(t<0||t>=o.height)throw new RangeError(`row must be included between 0 and ${o.height-1}. Current value: ${t}`)}function checkColumn(o,t){if(t<0||t>=o.width)throw new RangeError(`column must be included between 0 and ${o.width-1}. Current value: ${t}`)}function checkChannel(o,t){if(t<0||t>=o.channels)throw new RangeError(`channel must be included between 0 and ${o.channels-1}. Current value: ${t}`)}const validInterpolations={nearestneighbor:"nearestNeighbor",nearestneighbour:"nearestNeighbor",bilinear:"bilinear"};function checkInterpolation(o){if(typeof o!="string")throw new TypeError("interpolation must be a string");if(o=o.toLowerCase(),!validInterpolations[o])throw new RangeError(`invalid interpolation algorithm: ${o}`);return validInterpolations[o]}function nearestNeighbor(o,t,e){const n=this.width/t,a=this.height/e;if(this.bitDepth>1)for(let l=0;l<t;l++){const c=Math.floor((l+.5)*n);for(let f=0;f<e;f++){const g=Math.floor((f+.5)*a);for(let h=0;h<this.channels;h++)o.setValueXY(l,f,h,this.getValueXY(c,g,h))}}else for(let l=0;l<t;l++){const c=Math.floor((l+.5)*n);for(let f=0;f<e;f++){const g=Math.floor((f+.5)*a);this.getBitXY(c,g)&&o.setBitXY(l,f)}}}function resize(o={}){const{factor:t=1,interpolation:e=validInterpolations.nearestneighbor,preserveAspectRatio:n=!0}=o,a=checkInterpolation(e);let l=o.width,c=o.height;if(l||(c&&n?l=Math.round(c*(this.width/this.height)):l=this.width),c||(n?c=Math.round(l*(this.height/this.width)):c=this.height),{width:l,height:c}=factorDimensions(t,l,c),l===this.width&&c===this.height){const p=this.clone();return p.position=[0,0],p}let f=Math.round((this.width-l)/2),g=Math.round((this.height-c)/2);const h=Image$1.createFrom(this,{width:l,height:c,position:[f,g]});switch(a){case validInterpolations.nearestneighbor:nearestNeighbor.call(this,h,l,c);break;default:throw new Error(`unsupported resize interpolation: ${a}`)}return h}function hsv(){this.checkProcessable("hsv",{bitDepth:[8,16],alpha:[0,1],colorModel:[RGB$1]});let o=Image$1.createFrom(this,{colorModel:HSV}),t=0,e=this.data;for(let n=0;n<e.length;n+=this.channels){let a=e[n],l=e[n+1],c=e[n+2],f=Math.min(a,l,c),g=Math.max(a,l,c),h=g-f,p=0,s=g===0?0:h/g,r=g;if(g!==f){switch(g){case a:p=(l-c)/h+(l<c?6:0);break;case l:p=(c-a)/h+2;break;case c:p=(a-l)/h+4;break;default:throw new Error("unreachable")}p/=6}o.data[t++]=p*this.maxValue,o.data[t++]=s*this.maxValue,o.data[t++]=r,this.alpha&&(o.data[t++]=e[n+3])}return o}function hsl$1(){this.checkProcessable("hsl",{bitDepth:[8,16],alpha:[0,1],colorModel:[RGB$1]});let o=Image$1.createFrom(this,{colorModel:HSL}),t=Math.floor(this.maxValue/2),e=0,n=this.data;for(let a=0;a<n.length;a+=this.channels){let l=n[a],c=n[a+1],f=n[a+2],g=Math.max(l,c,f),h=Math.min(l,c,f),p=0,s=0,r=(g+h)/2;if(g!==h){let u=g-h;switch(s=r>t?u/(2-g-h):u/(g+h),g){case l:p=(c-f)/u+(c<f?6:0);break;case c:p=(f-l)/u+2;break;case f:p=(l-c)/u+4;break;default:throw new Error("unreachable")}p/=6}o.data[e++]=p*this.maxValue,o.data[e++]=s*this.maxValue,o.data[e++]=r,this.alpha&&(o.data[e++]=n[a+3])}return o}function cmyk(){this.checkProcessable("cmyk",{bitDepth:[8,16],alpha:[0,1],colorModel:[RGB$1]});let o=Image$1.createFrom(this,{components:4,colorModel:CMYK$1}),t=0,e=this.data;for(let n=0;n<e.length;n+=this.channels){let a=e[n],l=e[n+1],c=e[n+2],f=Math.min(this.maxValue-a,this.maxValue-l,this.maxValue-c),g=(this.maxValue-a-f)/(1-f/this.maxValue),h=(this.maxValue-l-f)/(1-f/this.maxValue),p=(this.maxValue-c-f)/(1-f/this.maxValue);o.data[t++]=Math.round(g),o.data[t++]=Math.round(h),o.data[t++]=Math.round(p),o.data[t++]=Math.round(f),this.alpha&&(o.data[t++]=e[n+3])}return o}function rgba8(){return new Image$1(this.width,this.height,this.getRGBAData(),{kind:"RGBA",parent:this})}const methods$1={luma709(o,t,e){return o*6966+t*23436+e*2366>>15},luma601(o,t,e){return o*9798+t*19235+e*3735>>15},maximum(o,t,e){return Math.max(o,t,e)},minimum(o,t,e){return Math.min(o,t,e)},average(o,t,e){return(o+t+e)/3>>0},minmax(o,t,e){return(Math.max(o,t,e)+Math.min(o,t,e))/2},red(o){return o},green(o,t){return t},blue(o,t,e){return e},cyan(o,t,e,n){let a=methods$1.black(o,t,e,n);return(n.maxValue-o-a)/(1-a/n.maxValue)>>0},magenta(o,t,e,n){let a=methods$1.black(o,t,e,n);return(n.maxValue-t-a)/(1-a/n.maxValue)>>0},yellow(o,t,e,n){let a=methods$1.black(o,t,e,n);return(n.maxValue-e-a)/(1-a/n.maxValue)>>0},black(o,t,e,n){return Math.min(n.maxValue-o,n.maxValue-t,n.maxValue-e)},hue(o,t,e,n){let a=methods$1.min(o,t,e),l=methods$1.max(o,t,e);if(l===a)return 0;let c=0,f=l-a;switch(l){case o:c=(t-e)/f+(t<e?6:0);break;case t:c=(e-o)/f+2;break;case e:c=(o-t)/f+4;break;default:throw new Error("unreachable")}return c/6*n.maxValue>>0},saturation(o,t,e,n){let a=methods$1.min(o,t,e),l=methods$1.max(o,t,e),c=l-a;return l===0?0:c/l*n.maxValue},lightness(o,t,e){let n=methods$1.min(o,t,e);return(methods$1.max(o,t,e)+n)/2}};Object.defineProperty(methods$1,"luminosity",{enumerable:!1,value:methods$1.lightness}),Object.defineProperty(methods$1,"luminance",{enumerable:!1,value:methods$1.lightness}),Object.defineProperty(methods$1,"min",{enumerable:!1,value:methods$1.minimum}),Object.defineProperty(methods$1,"max",{enumerable:!1,value:methods$1.maximum}),Object.defineProperty(methods$1,"brightness",{enumerable:!1,value:methods$1.maximum}),Object.keys(methods$1).forEach(o=>{});function grey(o={}){let{algorithm:t="luma709",keepAlpha:e=!1,mergeAlpha:n=!0}=o;if(typeof t!="string"&&typeof t!="function")throw new TypeError("algorithm must be a string or a function");this.checkProcessable("grey",{bitDepth:[8,16],alpha:[0,1]}),this.components===1&&(t="red"),e&=this.alpha,n&=this.alpha,e&&(n=!1);let a=getOutputImage(this,o,{components:1,alpha:e,colorModel:GREY$1}),l;if(typeof t=="function")l=t;else if(l=methods$1[t.toLowerCase()],!l)throw new Error(`unsupported grey algorithm: ${t}`);let c=0;for(let f=0;f<this.data.length;f+=this.channels)n?a.data[c++]=clamp(l(this.data[f],this.data[f+1],this.data[f+2],this)*this.data[f+this.components]/this.maxValue,this):(a.data[c++]=clamp(l(this.data[f],this.data[f+1],this.data[f+2],this),this),a.alpha&&(a.data[c++]=this.data[f+this.components]));return a}function huang(o){let t=0;for(let p=0;p<o.length;p++)if(o[p]!==0){t=p;break}let e=o.length-1;for(let p=o.length-1;p>=t;p--)if(o[p]!==0){e=p;break}let n=1/(e-t),a=new Array(o.length),l=0,c=0;for(let p=t;p<o.length;p++)l+=p*o[p],c+=o[p],a[p]=l/c;let f=new Array(o.length);l=c=0;for(let p=e;p>0;p--)l+=p*o[p],c+=o[p],f[p-1]=l/c;let g=-1,h=Number.MAX_VALUE;for(let p=0;p<o.length;p++){let s=0,r;for(let u=0;u<=p;u++)r=1/(1+n*Math.abs(u-a[p])),r<1e-6||r>.999999||(s+=o[u]*(-r*Math.log(r)-(1-r)*Math.log(1-r)));for(let u=p+1;u<o.length;u++)r=1/(1+n*Math.abs(u-f[p])),r<1e-6||r>.999999||(s+=o[u]*(-r*Math.log(r)-(1-r)*Math.log(1-r)));s<h&&(h=s,g=p)}return g}function intermodes(o){let t=o.slice(),e=0;for(;!bimodalTest$1(t);){let a=0,l=0,c=t[0];for(let f=0;f<o.length-1;f++)a=l,l=c,c=t[f+1],t[f]=(a+l+c)/3;if(t[o.length-1]=(l+c)/3,e++,e>1e4)throw new Error("Intermodes Threshold not found after 10000 iterations")}let n=0;for(let a=1;a<o.length-1;a++)t[a-1]<t[a]&&t[a+1]<t[a]&&(n+=a);return Math.floor(n/2)}function bimodalTest$1(o){let t=!1,e=0;for(let n=1;n<o.length-1;n++)if(o[n-1]<o[n]&&o[n+1]<o[n]&&(e++,e>2))return!1;return e===2&&(t=!0),t}function isodata(o){let t,e,n,a,l=0;for(let c=1;c<o.length;c++)if(o[c]>0){l=c+1;break}for(;;){t=0,n=0;for(let c=0;c<l;c++)n=n+o[c],t=t+o[c]*c;a=0,e=0;for(let c=l+1;c<o.length;c++)e+=o[c],a+=o[c]*c;if(n>0&&e>0&&(t/=n,a/=e,l===Math.round((t+a)/2)))break;if(l++,l>o.length-2)throw new Error("Threshold not found")}return l}function li(o,t){let e,n,a,l,c,f,g,h,p,s,r,u;r=.5,s=0;for(let d=0;d<o.length;d++)s+=d*o[d];s/=t,g=s;do{f=g,e=f+.5|0,n=0,l=0;for(let d=0;d<=e;d++)n+=d*o[d],l+=o[d];h=l===0?0:n/l,a=0,c=0;for(let d=e+1;d<o.length;d++)a+=d*o[d],c+=o[d];p=c===0?0:a/c,u=(h-p)/(Math.log(h)-Math.log(p)),u<-Number.EPSILON?g=u-.5|0:g=u+.5|0}while(Math.abs(g-f)>r);return e}function maxEntropy(o,t){let e=new Array(o.length);for(let r=0;r<o.length;r++)e[r]=o[r]/t;let n=new Array(o.length),a=new Array(o.length);n[0]=e[0],a[0]=1-n[0];for(let r=1;r<o.length;r++)n[r]=n[r-1]+e[r],a[r]=1-n[r];let l=0;for(let r=0;r<o.length;r++)if(Math.abs(n[r])>=Number.EPSILON){l=r;break}let c=o.length-1;for(let r=o.length-1;r>=l;r--)if(Math.abs(a[r])>=Number.EPSILON){c=r;break}let f=-1,g,h=Number.MIN_VALUE,p,s;for(let r=l;r<=c;r++){p=0;for(let u=0;u<=r;u++)o[u]!==0&&(p-=e[u]/n[r]*Math.log(e[u]/n[r]));s=0;for(let u=r+1;u<o.length;u++)o[u]!==0&&(s-=e[u]/a[r]*Math.log(e[u]/a[r]));g=p+s,h<g&&(h=g,f=r)}return f}function mean$1(o,t){let e=0;for(let n=0;n<o.length;n++)e+=n*o[n];return Math.floor(e/t)}function minError(o,t){let e,n=-2,a,l,c,f,g,h,p,s,r,u,d,m=0;for(let b=0;b<o.length;b++)m+=b*o[b];for(m/=t,e=m;e!==n;){let b=sumA(o,e),y=sumA(o,o.length-1),w=sumB(o,e),x=sumB(o,o.length-1),_=sumC(o,e),v=sumC(o,o.length-1);if(a=w/b,l=(x-w)/(y-b),c=b/y,f=(y-b)/y,g=_/b-a*a,h=(v-_)/(y-b)-l*l,p=1/g-1/h,s=a/g-l/h,r=a*a/g-l*l/h+Math.log10(g*(f*f)/(h*(c*c))),u=s*s-p*r,u<0)return e;n=e,d=(s+Math.sqrt(u))/p,isNaN(d)?e=n:e=Math.floor(d)}return e}function sumA(o,t){let e=0;for(let n=0;n<=t;n++)e+=o[n];return e}function sumB(o,t){let e=0;for(let n=0;n<=t;n++)e+=n*o[n];return e}function sumC(o,t){let e=0;for(let n=0;n<=t;n++)e+=n*n*o[n];return e}function minimum(o){if(o.length<2)return 0;let t=0,e=-1,n=-1,a=new Array(o.length);for(let l=0;l<o.length;l++)a[l]=o[l],o[l]>0&&(n=l);for(;!bimodalTest(a);)if(a=smoothed(a),t++,t>1e4)return e;return e=minimumBetweenPeeks(a,n),e}function smoothed(o){let t=new Array(o.length);for(let e=1;e<o.length-1;e++)t[e]=(o[e-1]+o[e]+o[e+1])/3;return t[0]=(o[0]+o[1])/3,t[o.length-1]=(o[o.length-2]+o[o.length-1])/3,t}function minimumBetweenPeeks(o,t){let e;for(let n=1;n<t;n++)if(o[n-1]>o[n]&&o[n+1]>=o[n]){e=n;break}return e}function bimodalTest(o){let t=o.length,e=!1,n=0;for(let a=1;a<t-1;a++)if(o[a-1]<o[a]&&o[a+1]<o[a]&&(n++,n>2))return!1;return n===2&&(e=!0),e}function moments(o,t){let e=1,n=0,a=0,l=0,c=0,f,g,h,p,s,r,u=-1,d=o.length,m=new Array(d);for(let b=0;b<d;b++)m[b]=o[b]/t;for(let b=0;b<d;b++)n+=b*m[b],a+=b*b*m[b],l+=b*b*b*m[b];g=e*a-n*n,h=(-a*a+n*l)/g,p=(e*-l+a*n)/g,s=.5*(-p-Math.sqrt(p*p-4*h)),r=.5*(-p+Math.sqrt(p*p-4*h)),f=(r-n)/(r-s);for(let b=0;b<d;b++)if(c+=m[b],c>f){u=b;break}return u}function otsu(o,t){let e=0,n=0,a=0,l=0,c=0;for(let f=0;f<o.length;f++)c+=f*o[f];for(let f=0;f<o.length;f++){n=n+o[f];const g=t-n;if(n===0||g===0)continue;e=e+f*o[f];const h=(c-e)/g,p=n*g*(e/n-h)*(e/n-h);p>=a&&(l=f,a=p)}return l}function percentile(o){let t=-1,e=.5,n=new Array(o.length),a=partialSum(o,o.length-1),l=1;for(let c=0;c<o.length;c++)n[c]=Math.abs(partialSum(o,c)/a-e),n[c]<l&&(l=n[c],t=c);return t}function partialSum(o,t){let e=0;for(let n=0;n<=t;n++)e+=o[n];return e}function renyiEntropy(o,t){let e,n,a,l=new Array(o.length),c=new Array(o.length),f=new Array(o.length),g=0,h=0,p=0,s=0,r=0,u=0,m=1/(1-.5),y=1/(1-2);for(let v=0;v<o.length;v++)l[v]=o[v]/t;c[0]=l[0],f[0]=1-c[0];for(let v=1;v<o.length;v++)c[v]=c[v-1]+l[v],f[v]=1-c[v];n=0;for(let v=0;v<o.length;v++)if(Math.abs(c[v])>=Number.EPSILON){n=v;break}a=o.length-1;for(let v=o.length-1;v>=n;v--)if(Math.abs(f[v])>=Number.EPSILON){a=v;break}for(let v=n;v<=a;v++){let E=0,I=0,S=0;for(let F=0;F<=v;F++)o[F]!==0&&(E-=l[F]/c[v]*Math.log(l[F]/c[v])),I+=Math.sqrt(l[F]/c[v]),S+=l[F]*l[F]/(c[v]*c[v]);let T=0,A=0,O=0;for(let F=v+1;F<o.length;F++)o[F]!==0&&(T-=l[F]/f[v]*Math.log(l[F]/f[v])),A+=Math.sqrt(l[F]/f[v]),O+=l[F]*l[F]/(f[v]*f[v]);let $=E+T,D=m*(I*A>0?Math.log(I*A):0),M=y*(S*O>0?Math.log(S*O):0);$>s&&(s=$,g=v),D>r&&(r=D,h=v),M>u&&(u=M,p=v)}let w=[g,h,p];w.sort((v,E)=>v-E);let x;Math.abs(w[0]-w[1])<=5?Math.abs(w[1]-w[2])<=5?x=[1,2,1]:x=[0,1,3]:Math.abs(w[1]-w[2])<=5?x=[3,1,0]:x=[1,2,1];let _=c[w[2]]-c[w[0]];return e=Math.round(w[0]*(c[w[0]]+.25*_*x[0])+.25*w[1]*_*x[1]+w[2]*(f[w[2]]+.25*_*x[2])),e}function shanbhag(o,t){let e=new Array(o.length);for(let u=0;u<o.length;u++)e[u]=o[u]/t;let n=new Array(o.length),a=new Array(o.length);n[0]=e[0],a[0]=1-n[0];for(let u=1;u<o.length;u++)n[u]=n[u-1]+e[u],a[u]=1-n[u];let l=0;for(let u=0;u<o.length;u++)if(Math.abs(n[u])>=Number.EPSILON){l=u;break}let c=o.length-1;for(let u=o.length-1;u>=l;u--)if(Math.abs(a[u])>=Number.EPSILON){c=u;break}let f=-1,g=Number.MAX_VALUE,h,p,s,r;for(let u=l;u<=c;u++){s=0,h=.5/n[u];for(let d=1;d<=u;d++)s-=e[d]*Math.log(1-h*n[d-1]);s*=h,r=0,h=.5/a[u];for(let d=u+1;d<o.length;d++)r-=e[d]*Math.log(1-h*a[d]);r*=h,p=Math.abs(s-r),p<g&&(g=p,f=u)}return f}function triangle$1(o){let t=0,e=0,n=0,a=0;for(let s=0;s<o.length;s++)if(o[s]>0){t=s;break}t>0&&t--;for(let s=o.length-1;s>0;s--)if(o[s]>0){a=s;break}a<o.length-1&&a++;for(let s=0;s<o.length;s++)o[s]>e&&(n=s,e=o[s]);let l=!1;if(n-t<a-n){l=!0;let s=0,r=o.length-1;for(;s<r;){let u=o[s];o[s]=o[r],o[r]=u,s++,r--}t=o.length-1-a,n=o.length-1-n}if(t===n)return t;let c,f,g;c=o[n],f=t-n,g=Math.sqrt(c*c+f*f),c/=g,f/=g,g=c*t+f*o[t];let h=t,p=0;for(let s=t+1;s<=n;s++){let r=c*s+f*o[s]-g;r>p&&(h=s,p=r)}if(h--,l){let s=0,r=o.length-1;for(;s<r;){let u=o[s];o[s]=o[r],o[r]=u,s++,r--}return o.length-1-h}else return h}function yen(o,t){let e=new Array(o.length);for(let h=0;h<o.length;h++)e[h]=o[h]/t;let n=new Array(o.length);n[0]=e[0];for(let h=1;h<o.length;h++)n[h]=n[h-1]+e[h];let a=new Array(o.length);a[0]=e[0]*e[0];for(let h=1;h<o.length;h++)a[h]=a[h-1]+e[h]*e[h];let l=new Array(o.length);l[o.length-1]=0;for(let h=o.length-2;h>=0;h--)l[h]=l[h+1]+e[h+1]*e[h+1];let c=-1,f=Number.MIN_VALUE,g;for(let h=0;h<o.length;h++)g=-1*(a[h]*l[h]>0?Math.log(a[h]*l[h]):0)+2*(n[h]*(1-n[h])>0?Math.log(n[h]*(1-n[h])):0),g>f&&(f=g,c=h);return c}const methods={huang,intermodes,isodata,li,maxentropy:maxEntropy,mean:mean$1,minerror:minError,minimum,moments,otsu,percentile,renyientropy:renyiEntropy,shanbhag,triangle:triangle$1,yen},names={};Object.keys(methods).forEach(o=>{names[o]=o});function getThreshold(o={}){let{algorithm:t=names.otsu}=o;this.checkProcessable("getThreshold",{components:1,bitDepth:[8,16]});let e=methods[t.toLowerCase()];if(e){let n=this.getHistogram();return e(n,this.size)}else throw new Error(`unknown thresholding algorithm: ${t}`)}const THRESHOLD="threshold";function mask(o={}){let{algorithm:t=THRESHOLD,threshold:e=.5,useAlpha:n=!0,invert:a=!1}=o;this.checkProcessable("mask",{components:1,bitDepth:[8,16]}),t===THRESHOLD?e=getThreshold$1(e,this.maxValue):e=getThreshold.call(this,o);let l=new Image$1(this.width,this.height,{kind:"BINARY",parent:this}),c=0;if(this.alpha&&n)for(let f=0;f<this.data.length;f+=this.channels){let g=this.data[f]+(this.maxValue-this.data[f])*(this.maxValue-this.data[f+1])/this.maxValue;(a&&g<=e||!a&&g>=e)&&l.setBit(c),c++}else for(let f=0;f<this.data.length;f+=this.channels)(a&&this.data[f]<=e||!a&&this.data[f]>=e)&&l.setBit(c),c++;return l}function copyImage(o,t,e,n){let a=o.width,l=o.height,c=t.width,f=o.channels;for(let g=0;g<a;g++)for(let h=0;h<l;h++)for(let p=0;p<f;p++){let s=(h*a+g)*f+p,r=((n+h)*c+e+g)*f+p;t.data[r]=o.data[s]}}function pad(o={}){let{size:t=0,algorithm:e="copy",color:n}=o;if(this.checkProcessable("pad",{bitDepth:[8,16]}),e==="set"){if(n.length!==this.channels)throw new Error(`pad: the color array must have the same length as the number of channels. Here: ${this.channels}`);for(let g=0;g<n.length;g++)n[g]===0&&(n[g]=.001)}else n=newArray$1(this.channels,null);Array.isArray(t)||(t=[t,t]);let a=this.width+t[0]*2,l=this.height+t[1]*2,c=this.channels,f=Image$1.createFrom(this,{width:a,height:l});copyImage(this,f,t[0],t[1]);for(let g=t[0];g<a-t[0];g++)for(let h=0;h<c;h++){let p=n[h]||f.data[(t[1]*a+g)*c+h];for(let s=0;s<t[1];s++)f.data[(s*a+g)*c+h]=p;p=n[h]||f.data[((l-t[1]-1)*a+g)*c+h];for(let s=l-t[1];s<l;s++)f.data[(s*a+g)*c+h]=p}for(let g=0;g<l;g++)for(let h=0;h<c;h++){let p=n[h]||f.data[(g*a+t[0])*c+h];for(let s=0;s<t[0];s++)f.data[(g*a+s)*c+h]=p;p=n[h]||f.data[(g*a+a-t[0]-1)*c+h];for(let s=a-t[0];s<a;s++)f.data[(g*a+s)*c+h]=p}return f}function colorDepth(o=8){if(this.checkProcessable("colorDepth",{bitDepth:[1,8,16]}),![8,16].includes(o))throw Error("You need to specify the new colorDepth as 8 or 16");if(this.bitDepth===o)return this.clone();let t=Image$1.createFrom(this,{bitDepth:o});switch(o){case 8:if(this.bitDepth===1)for(let e=0;e<this.size;e++)this.getBit(e)&&(t.data[e]=255);else for(let e=0;e<this.data.length;e++)t.data[e]=this.data[e]>>8;break;case 16:if(this.bitDepth===1)for(let e=0;e<this.size;e++)this.getBit(e)&&(t.data[e]=65535);else for(let e=0;e<this.data.length;e++)t.data[e]=this.data[e]<<8|this.data[e];break;default:throw new Error("colorDepth conversion unexpected case")}return t}function rotateFree(o,t={}){const{interpolation:e=validInterpolations.nearestneighbor,width:n=this.width,height:a=this.height}=t;if(typeof o!="number")throw new TypeError("degrees must be a number");const l=checkInterpolation(e),c=o*Math.PI/180,f=Math.floor(Math.abs(n*Math.cos(c))+Math.abs(a*Math.sin(c))),g=Math.floor(Math.abs(a*Math.cos(c))+Math.abs(n*Math.sin(c))),h=Math.cos(-c),p=Math.sin(-c);let s=f/2,r=g/2;f%2===0?(s=s-.5,g%2===0?r=r-.5:r=Math.floor(r)):(s=Math.floor(s),g%2===0?r=r-.5:r=Math.floor(r));const u=Math.floor(n/2-s),d=Math.floor(a/2-r);if(this.bitDepth===1){const m=new Image$1(f,g,{kind:"BINARY",parent:this});switch(l){case validInterpolations.nearestneighbor:return rotateBinaryNearestNeighbor(this,m,u,d,s,r,h,p);case validInterpolations.bilinear:return rotateBinaryBilinear(this,m,u,d,s,r,h,p);default:throw new Error(`unsupported rotate interpolation: ${l}`)}}else{const m=Image$1.createFrom(this,{width:f,height:g});switch(l){case validInterpolations.nearestneighbor:return rotateNearestNeighbor(this,m,u,d,s,r,h,p);case validInterpolations.bilinear:return rotateBilinear(this,m,u,d,s,r,h,p);default:throw new Error(`unsupported rotate interpolation: ${l}`)}}}function rotateNearestNeighbor(o,t,e,n,a,l,c,f){for(let g=0;g<t.width;g+=1)for(let h=0;h<t.height;h+=1)for(let p=0;p<o.channels;p++){let s=Math.round((g-a)*c-(h-l)*f+a)+e,r=Math.round((h-l)*c+(g-a)*f+l)+n;s<0||s>=o.width||r<0||r>=o.height?o.alpha===1&&p===o.channels-1?t.setValueXY(g,h,p,0):t.setValueXY(g,h,p,o.maxValue):t.setValueXY(g,h,p,o.getValueXY(s,r,p))}return t}function rotateBinaryNearestNeighbor(o,t,e,n,a,l,c,f){for(let g=0;g<t.width;g+=1)for(let h=0;h<t.height;h+=1){let p=Math.round((g-a)*c-(h-l)*f+a)+e,s=Math.round((h-l)*c+(g-a)*f+l)+n;(p<0||p>=o.width||s<0||s>=o.height||o.getBitXY(p,s))&&t.setBitXY(g,h)}return t}function rotateBilinear(o,t,e,n,a,l,c,f){let g=o.width*o.channels;for(let h=0;h<t.height;h++)for(let p=0;p<t.width;p++){let s=(p-a)*c-(h-l)*f+a+e,r=(h-l)*c+(p-a)*f+l+n,u=s|0,d=r|0,m=s-u,b=r-d;for(let y=0;y<o.channels;y++)if(s<0||s>=o.width||r<0||r>=o.height)o.alpha===1&&y===o.channels-1?t.setValueXY(p,h,y,0):t.setValueXY(p,h,y,o.maxValue);else{let w=(d*o.width+u)*o.channels+y,x=o.data[w],_=o.data[w+o.channels],v=o.data[w+g],E=o.data[w+g+o.channels],I=x+m*(_-x)+b*(v-x)+m*b*(x-_-v+E)|0;t.setValueXY(p,h,y,I)}}return t}function rotateBinaryBilinear(o,t,e,n,a,l,c,f){let g=o.width;for(let h=0;h<t.height;h++)for(let p=0;p<t.width;p++){let s=(p-a)*c-(h-l)*f+a+e,r=(h-l)*c+(p-a)*f+l+n,u=s|0,d=r|0,m=s-u,b=r-d;if(s<0||s>=o.width||r<0||r>=o.height)t.setBitXY(p,h);else{let y=d*o.width+u,w=o.getBit(y),x=o.getBit(y+1),_=o.getBit(y+g),v=o.getBit(y+1+g);(w|m&x-w|b&_-w|m&b&w-x-_+v)>0&&t.setBitXY(p,h)}}return t}function rotate$1(o,t){if(this.checkProcessable("rotate",{bitDepth:[1,8,16]}),typeof o!="number")throw new TypeError("angle must be a number");switch(o<0&&(o=Math.ceil(-o/360)*360+o),o%360){case 0:return this.clone();case 90:return rotateRight.call(this);case 180:return rotate180.call(this);case 270:return rotateLeft.call(this);default:return rotateFree.call(this,o,t)}}function rotateLeft(){if(this.bitDepth===1){const o=new Image$1(this.height,this.width,{kind:"BINARY",parent:this}),t=o.height-1;for(let e=0;e<this.height;e++)for(let n=0;n<this.width;n++)this.getBitXY(n,e)&&o.setBitXY(e,t-n);return o}else{const o=Image$1.createFrom(this,{width:this.height,height:this.width}),t=o.height-1;for(let e=0;e<this.height;e++)for(let n=0;n<this.width;n++)for(let a=0;a<this.channels;a++)o.setValueXY(e,t-n,a,this.getValueXY(n,e,a));return o}}function rotateRight(){if(this.bitDepth===1){const o=new Image$1(this.height,this.width,{kind:"BINARY",parent:this}),t=o.width-1;for(let e=0;e<this.height;e++)for(let n=0;n<this.width;n++)this.getBitXY(n,e)&&o.setBitXY(t-e,n);return o}else{const o=Image$1.createFrom(this,{width:this.height,height:this.width}),t=o.width-1;for(let e=0;e<this.height;e++)for(let n=0;n<this.width;n++)for(let a=0;a<this.channels;a++)o.setValueXY(t-e,n,a,this.getValueXY(n,e,a));return o}}function rotate180(){if(this.bitDepth===1){const o=new Image$1(this.width,this.height,{kind:"BINARY",parent:this}),t=o.width-1,e=o.height-1;for(let n=0;n<this.height;n++)for(let a=0;a<this.width;a++)this.getBitXY(a,n)&&o.setBitXY(t-a,e-n);return o}else{const o=Image$1.createFrom(this),t=o.width-1,e=o.height-1;for(let n=0;n<this.height;n++)for(let a=0;a<this.width;a++)for(let l=0;l<this.channels;l++)o.setValueXY(t-a,e-n,l,this.getValueXY(a,n,l));return o}}function insert(o,t={}){const e=getImageParameters(o);this.checkProcessable("insert",e);let{x:n=0,y:a=0}=t;const l=getOutputImageOrInPlace(this,t,{copy:!0}),c=Math.min(l.height,a+o.height),f=Math.min(l.width,n+o.width);if(l.bitDepth===1)for(let g=a;g<c;g++)for(let h=n;h<f;h++)o.getBitXY(h-n,g-a)?l.setBitXY(h,g):l.clearBitXY(h,g);else for(let g=a;g<c;g++)for(let h=n;h<f;h++)l.setPixelXY(h,g,o.getPixelXY(h-n,g-a));return l}function setBorder(o={}){let{size:t=0,algorithm:e="copy",color:n}=o;if(this.checkProcessable("setBorder",{bitDepth:[8,16,32,64]}),e==="set"){if(n.length!==this.channels)throw new Error(`setBorder: the color array must have the same length as the number of channels. Here: ${this.channels}`);for(let f=0;f<n.length;f++)n[f]===0&&(n[f]=.001)}else n=newArray$1(this.channels,null);Array.isArray(t)||(t=[t,t]);let a=t[0],l=t[1],c=this.channels;for(let f=a;f<this.width-a;f++)for(let g=0;g<c;g++){let h=n[g]||this.data[(f+this.width*l)*c+g];for(let p=0;p<l;p++)this.data[(p*this.width+f)*c+g]=h;h=n[g]||this.data[(f+this.width*(this.height-l-1))*c+g];for(let p=this.height-l;p<this.height;p++)this.data[(p*this.width+f)*c+g]=h}for(let f=0;f<this.height;f++)for(let g=0;g<c;g++){let h=n[g]||this.data[(f*this.width+a)*c+g];for(let p=0;p<a;p++)this.data[(f*this.width+p)*c+g]=h;h=n[g]||this.data[(f*this.width+this.width-a-1)*c+g];for(let p=this.width-a;p<this.width;p++)this.data[(f*this.width+p)*c+g]=h}return this}function split(o={}){let{preserveAlpha:t=!0}=o;if(this.checkProcessable("split",{bitDepth:[8,16]}),this.components===1)return new Stack([this.clone()]);let e=new Stack,n=this.data;if(this.alpha&&t)for(let a=0;a<this.components;a++){let l=Image$1.createFrom(this,{components:1,alpha:!0,colorModel:GREY$1}),c=0;for(let f=0;f<n.length;f+=this.channels)l.data[c++]=n[f+a],l.data[c++]=n[f+this.components];e.push(l)}else for(let a=0;a<this.channels;a++){let l=Image$1.createFrom(this,{components:1,alpha:!1,colorModel:GREY$1}),c=0;for(let f=0;f<n.length;f+=this.channels)l.data[c++]=n[f+a];e.push(l)}return e}function getChannel(o,t={}){let{keepAlpha:e=!1,mergeAlpha:n=!1}=t;e&=this.alpha,n&=this.alpha,this.checkProcessable("getChannel",{bitDepth:[8,16]}),o=validateChannel(this,o);let a=Image$1.createFrom(this,{components:1,alpha:e,colorModel:GREY$1}),l=0;for(let c=0;c<this.data.length;c+=this.channels)n?a.data[l++]=this.data[c+o]*this.data[c+this.components]/this.maxValue:(a.data[l++]=this.data[c+o],e&&(a.data[l++]=this.data[c+this.components]));return a}function combineChannels(o=defaultCombineMethod,t={}){let{mergeAlpha:e=!1,keepAlpha:n=!1}=t;e&=this.alpha,n&=this.alpha,this.checkProcessable("combineChannels",{bitDepth:[8,16]});let a=Image$1.createFrom(this,{components:1,alpha:n,colorModel:GREY$1}),l=0;for(let c=0;c<this.size;c++){let f=o(this.getPixel(c));e?a.data[l++]=f*this.data[c*this.channels+this.components]/this.maxValue:(a.data[l++]=f,n&&(a.data[l++]=this.data[c*this.channels+this.components]))}return a}function defaultCombineMethod(o){return(o[0]+o[1]+o[2])/3}function setChannel(o,t){if(this.checkProcessable("setChannel",{bitDepth:[8,16]}),t.checkProcessable("setChannel (image parameter check)",{bitDepth:[this.bitDepth],alpha:[0],components:[1]}),t.width!==this.width||t.height!==this.height)throw new Error("Images must have exactly the same width and height");o=validateChannel(this,o);let e=o;for(let n=0;n<t.data.length;n++)this.data[e]=t.data[n],e+=this.channels;return this}function getSimilarity(o,t={}){let{shift:e=[0,0],average:n,channels:a,defaultAlpha:l,normalize:c,border:f=[0,0]}=t;if(this.checkProcessable("getSimilarity",{bitDepth:[8,16]}),Array.isArray(f)||(f=[f,f]),a=validateArrayOfChannels(this,{channels:a,defaultAlpha:l}),this.bitDepth!==o.bitDepth)throw new Error("Both images must have the same bitDepth");if(this.channels!==o.channels)throw new Error("Both images must have the same number of channels");if(this.colorModel!==o.colorModel)throw new Error("Both images must have the same colorModel");typeof n>"u"&&(n=!0);let g=Math.max(f[0],-e[0]),h=Math.min(this.width-f[0],this.width-e[0]),p=Math.max(f[1],-e[1]),s=Math.min(this.height-f[1],this.height-e[1]),r=newArray$1(a.length,0);for(let u=0;u<a.length;u++){let d=a[u],m=c?this.sum[d]:Math.max(this.sum[d],o.sum[d]),b=c?o.sum[d]:Math.max(this.sum[d],o.sum[d]);if(m!==0&&b!==0)for(let y=g;y<h;y++)for(let w=p;w<s;w++){let x=y*this.multiplierX+w*this.multiplierY+d,_=x+e[0]*this.multiplierX+e[1]*this.multiplierY;r[u]+=Math.min(this.data[x]/m,o.data[_]/b)}}return n?r.reduce((u,d)=>u+d)/r.length:r}function getPixelsGrid(o={}){let{sampling:t=[10,10],painted:e=!1,mask:n}=o;this.checkProcessable("getPixelsGrid",{bitDepth:[8,16],channels:1}),Array.isArray(t)||(t=[t,t]);const a=t[0],l=t[1],c=[],f=[],g=this.width/a,h=this.height/l;let p=Math.floor(g/2);for(let r=0;r<a;r++){let u=Math.floor(h/2);for(let d=0;d<l;d++){let m=Math.round(p),b=Math.round(u);(!n||n.getBitXY(m,b))&&(c.push([m,b]),f.push(this.getPixelXY(m,b))),u+=h}p+=g}const s={xyS:c,zS:f};return e&&(s.painted=this.rgba8().paintPoints(c)),s}function Matrix(o,t,e){const n=new Array(o);for(let a=0;a<o;a++)n[a]=new Array(t);if(e)for(let a=0;a<o;a++)for(let l=0;l<t;l++)n[a][l]=e;return n.width=o,n.height=t,Object.setPrototypeOf(n,Matrix.prototype),n}Matrix.prototype.localMin=function(o,t){let e=this[o][t],n=[o,t];for(let a=Math.max(0,o-1);a<Math.min(this.length,o+2);a++)for(let l=Math.max(0,t-1);l<Math.min(this[0].length,t+2);l++)this[a][l]<e&&(e=this[a][l],n=[a,l]);return{position:n,value:e}},Matrix.prototype.localMax=function(o,t){let e=this[o][t],n=[o,t];for(let a=Math.max(0,o-1);a<Math.min(this.length,o+2);a++)for(let l=Math.max(0,t-1);l<Math.min(this[0].length,t+2);l++)this[a][l]>e&&(e=this[a][l],n=[a,l]);return{position:n,value:e}},Matrix.prototype.localSearch=function(o,t,e){let n=[];for(let a=Math.max(0,o-1);a<Math.min(this.length,o+2);a++)for(let l=Math.max(0,t-1);l<Math.min(this[0].length,t+2);l++)this[a][l]===e&&n.push([a,l]);return n};function getBestMatch(o,t={}){let{border:e}=t;if(this.checkProcessable("getChannel",{bitDepth:[8,16]}),this.bitDepth!==o.bitDepth)throw new Error("Both images must have the same bitDepth");if(this.channels!==o.channels)throw new Error("Both images must have the same number of channels");if(this.colorModel!==o.colorModel)throw new Error("Both images must have the same colorModel");let n=new Matrix(o.width,o.height,-1/0),a=Math.floor(o.width/2),l=Math.floor(o.height/2),c=a,f=l,g=!1;for(;!g;){let h=n.localSearch(a,l,-1/0);for(let s=0;s<h.length;s++){let r=h[s],u=this.getSimilarity(o,{border:e,shift:[c-r[0],f-r[1]]});n[r[0]][r[1]]=u}let p=n.localMax(a,l);p.position[0]!==a||p.position[1]!==l?(a=p.position[0],l=p.position[1]):g=!0}return[a-c,l-f]}function getRow(o,t=0){this.checkProcessable("getRow",{bitDepth:[8,16]}),checkRow(this,o),checkChannel(this,t);let e=new Array(this.width),n=0,a=o*this.width*this.channels+t,l=a+this.width*this.channels;for(let c=a;c<l;c+=this.channels)e[n++]=this.data[c];return e}function getColumn(o,t=0){this.checkProcessable("getColumn",{bitDepth:[8,16]}),checkColumn(this,o),checkChannel(this,t);let e=new Array(this.height),n=0,a=this.width*this.channels;for(let l=t+o*this.channels;l<this.data.length;l+=a)e[n++]=this.data[l];return e}function getMatrix(o={}){let{channel:t}=o;if(this.checkProcessable("getMatrix",{bitDepth:[8,16]}),t===void 0){if(this.components>1)throw new RangeError("You need to define the channel for an image that contains more than one channel");t=0}let e=new Matrix$2(this.height,this.width);for(let n=0;n<this.height;n++)for(let a=0;a<this.width;a++)e.set(n,a,this.getValueXY(a,n,t));return e}function setMatrix(o,t={}){o=new Matrix$2(o);let{channel:e}=t;if(this.checkProcessable("getMatrix",{bitDepth:[8,16]}),e===void 0){if(this.components>1)throw new RangeError("You need to define the channel for an image that contains more than one channel");e=0}if(this.width!==o.columns||this.height!==o.rows)throw new RangeError("The size of the matrix must be equal to the size of the image");for(let n=0;n<this.height;n++)for(let a=0;a<this.width;a++)this.setValueXY(a,n,e,o.get(n,a))}function getPixelsArray(){this.checkProcessable("getPixelsArray",{bitDepth:[8,16,32]});let o=new Array(this.size),t=0;for(let e=0;e<this.data.length;e+=this.channels){let n=new Array(this.components);for(let a=0;a<this.components;a++)n[a]=this.data[e+a];o[t++]=n}return o}function getIntersection(o){let t=this,e=t.getClosestCommonParent(o),n=t.getRelativePosition(e,{defaultFurther:!0}),a=getRelativePositionForAllPixels(t,n),l=o.getRelativePosition(e,{defaultFurther:!0}),c=getRelativePositionForAllPixels(o,l),f=getCommonSurface(a,c),g={whitePixelsMask1:[],whitePixelsMask2:[],commonWhitePixels:[]};for(let h=0;h<f.length;h++){let p=f[h],s=[p[0]-n[0],p[1]-n[1]],r=[p[0]-l[0],p[1]-l[1]],u=t.getBitXY(s[0],s[1]),d=o.getBitXY(r[0],r[1]);u===1&&d===1&&g.commonWhitePixels.push(p)}for(let h=0;h<a.length;h++){let p,s;h!==0&&(p=Math.floor(h/t.width),s=h%t.width),t.getBitXY(p,s)===1&&g.whitePixelsMask1.push(a[h])}for(let h=0;h<c.length;h++){let p=0,s=0;h!==0&&(p=Math.floor(h/o.width),s=h%o.width),o.getBitXY(p,s)===1&&g.whitePixelsMask2.push(c[h])}return g}function getRelativePositionForAllPixels(o,t){let e=[];for(let n=0;n<o.height;n++)for(let a=0;a<o.width;a++){let l=[n,a];e.push([l[0]+t[0],l[1]+t[1]])}return e}function getCommonSurface(o,t){let e=0,n=0,a=[];for(;e<o.length&&n<t.length;)o[e][0]===t[n][0]&&o[e][1]===t[n][1]?(a.push(o[e]),e++,n++):o[e][0]<t[n][0]||o[e][0]===t[n][0]&&o[e][1]<t[n][1]?e++:n++;return a}function getClosestCommonParent(o){let t=getDepth(this),e=getDepth(o),n;if(t>=e?n=getFurthestParent(this,t):n=getFurthestParent(o,e),t===0||e===0)return n;let a=this,l=o;for(;t!==e;)if(t>e){if(a=a.parent,a===null)return n;t=t-1}else{if(l=l.parent,l===null)return n;e=e-1}for(;a!==l&&a!==null&&l!==null;)if(a=a.parent,l=l.parent,a===null||l===null)return n;return a!==l?n:a}function getDepth(o){let t=0,e=o;for(;e.parent!=null;)e=e.parent,t++;return t}function getFurthestParent(o,t){let e=o;for(;t>0;)e=e.parent,t=t-1;return e}const defaultOptions$1={lowThreshold:10,highThreshold:30,gaussianBlur:1.1},Gx=[[-1,0,1],[-2,0,2],[-1,0,1]],Gy=[[-1,-2,-1],[0,0,0],[1,2,1]],convOptions={bitDepth:32,mode:"periodic"};function cannyEdgeDetector(o,t){o.checkProcessable("Canny edge detector",{bitDepth:8,channels:1,components:1}),t=Object.assign({},defaultOptions$1,t);const e=o.width,n=o.height,a=o.maxValue,l={sigma:t.gaussianBlur,radius:3},c=o.gaussianFilter(l),f=c.convolution(Gy,convOptions),g=c.convolution(Gx,convOptions),h=g.hypotenuse(f),p=o.constructor,s=new p(e,n,{kind:"GREY",bitDepth:32}),r=new p(e,n,{kind:"GREY",bitDepth:32}),u=new p(e,n,{kind:"GREY"});for(var d=1;d<e-1;d++)for(var m=1;m<n-1;m++){var b=(Math.round(Math.atan2(g.getValueXY(d,m,0),f.getValueXY(d,m,0))*(5/Math.PI))+5)%5;b===0&&(h.getValueXY(d,m,0)<=h.getValueXY(d,m-1,0)||h.getValueXY(d,m,0)<=h.getValueXY(d,m+1,0))||b===1&&(h.getValueXY(d,m,0)<=h.getValueXY(d-1,m+1,0)||h.getValueXY(d,m,0)<=h.getValueXY(d+1,m-1,0))||b===2&&(h.getValueXY(d,m,0)<=h.getValueXY(d-1,m,0)||h.getValueXY(d,m,0)<=h.getValueXY(d+1,m,0))||b===3&&(h.getValueXY(d,m,0)<=h.getValueXY(d-1,m-1,0)||h.getValueXY(d,m,0)<=h.getValueXY(d+1,m+1,0))||s.setValueXY(d,m,0,h.getValueXY(d,m,0))}for(d=0;d<e*n;++d){var y=s.data[d],w=0;y>t.highThreshold&&(w++,u.data[d]=a),y>t.lowThreshold&&w++,r.data[d]=w}var x=[];for(d=1;d<e-1;++d)for(m=1;m<n-1;++m)if(r.getValueXY(d,m,0)===1){t:for(var _=d-1;_<d+2;++_)for(var v=m-1;v<m+2;++v)if(r.getValueXY(_,v,0)===2){x.push([d,m]),u.setValueXY(d,m,0,a);break t}}for(;x.length>0;){var E=[];for(d=0;d<x.length;++d)for(m=-1;m<2;++m)for(_=-1;_<2;++_)if(!(m===0&&_===0)){var I=x[d][0]+m,S=x[d][1]+_;r.getValueXY(I,S,0)===1&&u.getValueXY(I,S,0)===0&&(E.push([I,S]),u.setValueXY(I,S,0,a))}x=E}return u}function cannyEdge(o){return cannyEdgeDetector(this,o)}function extract(o,t={}){let{position:e}=t;if(this.checkProcessable("extract",{bitDepth:[1,8,16]}),!e&&(e=o.getRelativePosition(this),!e))throw new Error("extract : can not extract an image because the relative position can not be determined, try to specify manually the position as an array of 2 elements [x,y].");if(this.bitDepth>1){let n=Image$1.createFrom(this,{width:o.width,height:o.height,alpha:1,position:e,parent:this});for(let a=0;a<o.width;a++)for(let l=0;l<o.height;l++){for(let c=0;c<this.channels;c++){let f=this.getValueXY(a+e[0],l+e[1],c);n.setValueXY(a,l,c,f)}o.getBitXY(a,l)||n.setValueXY(a,l,this.components,0)}return n}else{let n=Image$1.createFrom(this,{width:o.width,height:o.height,position:e,parent:this});for(let a=0;a<o.height;a++)for(let l=0;l<o.width;l++)o.getBitXY(l,a)&&this.getBitXY(l+e[0],a+e[1])&&n.setBitXY(l,a);return n}}var fastList={exports:{}};(function(o,t){(function(){function e(a,l,c){this.next=c,c&&(c.prev=this),this.prev=l,l&&(l.next=this),this.data=a}function n(){if(!(this instanceof n))return new n;this._head=null,this._tail=null,this.length=0}n.prototype={push:function(a){this._tail=new e(a,this._tail,null),this._head||(this._head=this._tail),this.length++},pop:function(){if(this.length!==0){var a=this._tail;return this._tail=a.prev,a.prev&&(a.prev=this._tail.next=null),this.length--,this.length===1?this._head=this._tail:this.length===0&&(this._head=this._tail=null),a.data}},unshift:function(a){this._head=new e(a,null,this._head),this._tail||(this._tail=this._head),this.length++},shift:function(){if(this.length!==0){var a=this._head;return this._head=a.next,a.next&&(a.next=this._head.prev=null),this.length--,this.length===1?this._tail=this._head:this.length===0&&(this._head=this._tail=null),a.data}},item:function(a){a<0&&(a=this.length+a);for(var l=this._head;a-- >0&&l;)l=l.next;return l?l.data:void 0},slice:function(a,l){if(a||(a=0),l||(l=this.length),l<0&&(l=this.length+l),a<0&&(a=this.length+a),l===a)return[];if(l<a)throw new Error("invalid offset: "+a+","+l+" (length="+this.length+")");for(var c=l-a,f=new Array(c),g=0,h=this._head;a-- >0&&h;)h=h.next;for(;g<c&&h;)f[g++]=h.data,h=h.next;return f},drop:function(){n.call(this)},forEach:function(a,l){for(var c=this._head,f=0,g=this.length;f<g&&c;)a.call(l||this,c.data,f,this),c=c.next,f++},map:function(a,l){var c=new n;return this.forEach(function(f,g,h){c.push(a.call(l||h,f,g,h))}),c},filter:function(a,l){var c=new n;return this.forEach(function(f,g,h){a.call(l||h,f,g,h)&&c.push(f)}),c},reduce:function(a,l,c){var f=0,g=this._head,h=this.length;for(l||(f=1,l=g&&g.data,g=g&&g.next);f<h&&g;)l=a.call(c||this,l,g.data,this),f++,g=g.next;return l}},o.exports=n})()})(fastList);var fastListExports=fastList.exports,LinkedList=getDefaultExportFromCjs(fastListExports);function floodFill(o={}){const{x:t=0,y:e=0,inPlace:n=!0}=o,a=n?this:Image$1.createFrom(this);if(this.checkProcessable("floodFill",{bitDepth:1}),this.getBitXY(t,e))return a;const c=new LinkedList;for(c.push(new Node(t,e));c.length>0;){const f=c.shift();a.setBitXY(f.x,f.y);for(let g=f.x+1;g<this.width&&(!a.getBitXY(g,f.y)&&!this.getBitXY(g,f.y));g++)a.setBitXY(g,f.y),f.y+1<this.height&&!this.getBitXY(g,f.y+1)&&c.push(new Node(g,f.y+1)),f.y-1>=0&&!this.getBitXY(g,f.y-1)&&c.push(new Node(g,f.y-1));for(let g=f.x-1;g>=0&&(!a.getBitXY(g,f.y)&&!this.getBitXY(g,f.y));g++)a.setBitXY(g,f.y),f.y+1<this.height&&!this.getBitXY(g,f.y+1)&&c.push(new Node(g,f.y+1)),f.y-1>=0&&!this.getBitXY(g,f.y-1)&&c.push(new Node(g,f.y-1))}return a}function Node(o,t){this.x=o,this.y=t}function _extends(){return _extends=Object.assign?Object.assign.bind():function(o){for(var t=1;t<arguments.length;t++){var e=arguments[t];for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(o[n]=e[n])}return o},_extends.apply(this,arguments)}function hsv2rgb(o,t,e){t=t/100,e=e/100;var n=[],a=e*t,l=o/60,c=a*(1-Math.abs(l%2-1)),f=e-a;return l>=0&&l<1?n=[a,c,0]:l>=1&&l<2?n=[c,a,0]:l>=2&&l<3?n=[0,a,c]:o>=3&&l<4?n=[0,c,a]:o>=4&&l<5?n=[c,0,a]:o>=5&&l<=6?n=[a,0,c]:n=[0,0,0],{r:Math.round(255*(n[0]+f)),g:Math.round(255*(n[1]+f)),b:Math.round(255*(n[2]+f))}}function hsl2hsv(o,t,e){return t*=(e<50?e:100-e)/100,{h:o,s:2*t/(e+t)*100,v:e+t}}function hsl2rgb$1(o,t,e){var n=hsl2hsv(o,t,e);return hsv2rgb(n.h,n.s,n.v)}var colors={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,132,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,255,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,203],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[119,128,144],slategrey:[119,128,144],snow:[255,255,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,5]};function parse(o){return named(o)||hex3(o)||hex6(o)||rgb(o)||rgba$1(o)||hsl(o)||hsla(o)}function named(o){var t=colors[o.toLowerCase()];if(t)return{r:t[0],g:t[1],b:t[2],a:100}}function rgb(o){var t=o.match(/rgb\(([^)]+)\)/);if(t){var e=t[1].split(/ *, */).map(Number);return{r:e[0],g:e[1],b:e[2],a:100}}}function rgba$1(o){var t=o.match(/rgba\(([^)]+)\)/);if(t){var e=t[1].split(/ *, */).map(Number);return{r:e[0],g:e[1],b:e[2],a:e[3]*100}}}function hex6(o){if(o[0]==="#"&&o.length===7)return{r:parseInt(o.slice(1,3),16),g:parseInt(o.slice(3,5),16),b:parseInt(o.slice(5,7),16),a:100}}function hex3(o){if(o[0]==="#"&&o.length===4)return{r:parseInt(o[1]+o[1],16),g:parseInt(o[2]+o[2],16),b:parseInt(o[3]+o[3],16),a:100}}function hsl(o){var t=o.match(/hsl\(([^)]+)\)/);if(t){var e=t[1].split(/ *, */),n=parseInt(e[0],10),a=parseInt(e[1],10),l=parseInt(e[2],10),c=hsl2rgb$1(n,a,l);return _extends({},c,{a:100})}}function hsla(o){var t=o.match(/hsla\(([^)]+)\)/);if(t){var e=t[1].split(/ *, */),n=parseInt(e[0],10),a=parseInt(e[1],10),l=parseInt(e[2],10),c=parseInt(parseFloat(e[3])*100,10),f=hsl2rgb$1(n,a,l);return _extends({},f,{a:c})}}function css2array(o){let t=parse(o);return[t.r,t.g,t.b,Math.round(t.a*255/100)]}function hue2rgb(o,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?o+(t-o)*6*e:e<1/2?t:e<2/3?o+(t-o)*(2/3-e)*6:o}function hsl2rgb(o,t,e){let n,a,l,c,f,g;return t/=100,e/=100,t===0?c=f=g=e*255:(e<=.5?a=e*(t+1):a=e+t-e*t,n=e*2-a,l=o/360,c=hue2rgb(n,a,l+1/3),f=hue2rgb(n,a,l),g=hue2rgb(n,a,l-1/3)),{r:c,g:f,b:g}}function getDistinctColors(o){let t=new Array(o),e=0;for(let n=0;n<360;n+=360/o){e++;let a=hsl2rgb(n,100,30+e%4*15);t[e-1]=[Math.round(a.r*255),Math.round(a.g*255),Math.round(a.b*255)]}return t}function getRandomColor(){return[Math.floor(Math.random()*256),Math.floor(Math.random()*256),Math.floor(Math.random()*256)]}function getColors(o){let{color:t,colors:e,randomColors:n,numberColors:a=50}=o;if(t&&!Array.isArray(t)&&(t=css2array(t)),t)return[t];if(e)return e=e.map(function(l){return Array.isArray(l)?l:css2array(l)}),e;if(n){e=new Array(a);for(let l=0;l<a;l++)e[l]=getRandomColor()}return getDistinctColors(a)}function paintLabels(o,t,e={}){let{color:n="blue",colors:a,font:l="12px Helvetica",rotate:c=0}=e;if(this.checkProcessable("paintMasks",{channels:[3,4],bitDepth:[8,16],colorModel:RGB$1}),!Array.isArray(o))throw Error("paintLabels: labels must be an array");if(!Array.isArray(t))throw Error("paintLabels: positions must be an array");if(n&&!Array.isArray(n)&&(n=css2array(n)),a?a=a.map(function(h){return Array.isArray(h)?h:css2array(h)}):a=[n],o.length!==t.length)throw Error("paintLabels: positions and labels must be arrays from the same size");Array.isArray(l)||(l=[l]),Array.isArray(c)||(c=[c]);let g=this.getCanvas().getContext("2d");for(let h=0;h<o.length;h++){g.save();let p=a[h%a.length];g.fillStyle=`rgba(${p[0]},${p[1]},${p[2]},${p[3]/this.maxValue})`,g.font=l[h%l.length];let s=t[h];g.translate(s[0],s[1]),g.rotate(c[h%c.length]/180*Math.PI),g.fillText(o[h],0,0),g.restore()}return this.data=Uint8Array.from(g.getImageData(0,0,this.width,this.height).data),this}function paintMasks(o,t={}){let{alpha:e=255,labels:n=[],labelsPosition:a=[],labelColor:l="blue",labelFont:c="12px Helvetica"}=t;this.checkProcessable("paintMasks",{channels:[3,4],bitDepth:[8,16],colorModel:RGB$1});let f=getColors(Object.assign({},t,{numberColors:o.length}));Array.isArray(o)||(o=[o]);for(let g=0;g<o.length;g++){let h=o[g],p=f[g%f.length];for(let s=0;s<h.width;s++)for(let r=0;r<h.height;r++)if(h.getBitXY(s,r))for(let u=0;u<Math.min(this.components,p.length);u++)if(e===255)this.setValueXY(s+h.position[0],r+h.position[1],u,p[u]);else{let d=this.getValueXY(s+h.position[0],r+h.position[1],u);d=Math.round((d*(255-e)+p[u]*e)/255),this.setValueXY(s+h.position[0],r+h.position[1],u,d)}}if(Array.isArray(n)&&n.length>0){let h=this.getCanvas().getContext("2d");h.fillStyle=l,h.font=c;for(let p=0;p<Math.min(o.length,n.length);p++){let s=a[p]?a[p]:o[p].position;h.fillText(n[p],s[0],s[1])}this.data=Uint8Array.from(h.getImageData(0,0,this.width,this.height).data)}return this}function zerosMatrix(o,t){let e=new Array(o);for(let n=0;n<o;n++)e[n]=new Array(t).fill(0);return e}const cross=[[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0]],smallCross=[[0,1,0],[1,1,1],[0,1,0]];class Shape{constructor(t={}){let{kind:e="cross",shape:n,size:a,width:l,height:c,filled:f=!0}=t;if(a&&(l=a,c=a),n)switch(n.toLowerCase()){case"square":case"rectangle":this.matrix=rectangle(l,c,{filled:f});break;case"circle":case"ellipse":this.matrix=ellipse(l,c,{filled:f});break;case"triangle":this.matrix=triangle(l,c,{filled:f});break;default:throw new Error(`Shape: unexpected shape: ${n}`)}else if(e)switch(e.toLowerCase()){case"cross":this.matrix=cross;break;case"smallcross":this.matrix=smallCross;break;default:throw new Error(`Shape: unexpected kind: ${e}`)}else throw new Error("Shape: expected a kind or a shape option");this.height=this.matrix.length,this.width=this.matrix[0].length,this.halfHeight=this.height/2>>0,this.halfWidth=this.width/2>>0}getPoints(){let t=this.matrix,e=[];for(let n=0;n<t.length;n++)for(let a=0;a<t[0].length;a++)t[n][a]&&e.push([a-this.halfWidth,n-this.halfHeight]);return e}getMask(){let t=new Image$1(this.width,this.height,{kind:BINARY});for(let e=0;e<this.matrix.length;e++)for(let n=0;n<this.matrix[0].length;n++)this.matrix[e][n]&&t.setBitXY(n,e);return t}}function rectangle(o,t,e){const n=zerosMatrix(t,o);if(e.filled)for(let a=0;a<t;a++)for(let l=0;l<o;l++)n[a][l]=1;else{for(let a of[0,t-1])for(let l=0;l<o;l++)n[a][l]=1;for(let a=0;a<t;a++)for(let l of[0,o-1])n[a][l]=1}return n}function ellipse(o,t,e){const n=zerosMatrix(t,o);let a=1-t%2,l=1-o%2,c=Math.floor((o-1)/2),f=Math.floor((t-1)/2),g=c*c,h=f*f;if(e.filled)for(let p=0;p<=f;p++){let s=Math.floor(Math.sqrt(g-g*p*p/h));for(let r=c-s;r<=c;r++)n[f-p][r]=1,n[f+p+a][r]=1,n[f-p][o-r-1]=1,n[f+p+a][o-r-1]=1}else{for(let p=0;p<=f;p++){let s=Math.floor(Math.sqrt(g-g*p*p/h)),r=c-s;n[f-p][r]=1,n[f+p+a][r]=1,n[f-p][o-r-1]=1,n[f+p+a][o-r-1]=1}for(let p=0;p<=c;p++){let s=Math.floor(Math.sqrt(h-h*p*p/g)),r=f-s;n[r][c-p]=1,n[r][c+p+l]=1,n[t-r-1][c-p]=1,n[t-r-1][c+p+l]=1}}return n}function triangle(o,t,e){if(!e.filled)throw new Error("Non filled triangle is not implemented");const n=zerosMatrix(t,o);for(let a=0;a<t;a++){let l=Math.floor((1-a/t)*o/2);for(let c=l;c<o-l;c++)n[a][c]=1}return n}function paintPoints(o,t={}){let{shape:e}=t;this.checkProcessable("paintPoints",{bitDepth:[8,16]});let n=getColors(Object.assign({},t,{numberColors:o.length})),a=new Shape(e).getPoints(),l=Math.min(this.channels,n[0].length);for(let c=0;c<o.length;c++){let f=n[c%n.length],g=o[c][0],h=o[c][1];for(let p=0;p<a.length;p++){let s=a[p][0],r=a[p][1];if(g+s>=0&&h+r>=0&&g+s<this.width&&h+r<this.height){let u=(g+s+(h+r)*this.width)*this.channels;for(let d=0;d<l;d++)this.data[u+d]=f[d]}}}return this}function paintPolyline(o,t={}){let{color:e=[this.maxValue,0,0],closed:n=!1}=t;this.checkProcessable("paintPoints",{bitDepth:[1,8,16]});let a=Math.min(this.channels,e.length);for(let l=0;l<o.length-1+n;l++){let c=o[l],f=o[(l+1)%o.length],g=f[0]-c[0],h=f[1]-c[1],p=Math.max(Math.abs(g),Math.abs(h)),s=g/p,r=h/p,u=c[0],d=c[1];for(let m=0;m<=p;m++){let b=Math.round(u),y=Math.round(d);if(b>=0&&y>=0&&b<this.width&&y<this.height)if(this.bitDepth===1)this.setBitXY(b,y);else{let w=(b+y*this.width)*this.channels;for(let x=0;x<a;x++)this.data[w+x]=e[x]}u=u+s,d=d+r}}return this}function paintPolylines(o,t={}){let e=Object.assign({},t);this.checkProcessable("paintPolylines",{bitDepth:[8,16]});let n=getColors(Object.assign({},t,{numberColors:o.length}));for(let a=0;a<o.length;a++)e.color=n[a%n.length],this.paintPolyline(o[a],e);return this}function paintPolygon(o,t={}){let{color:e=[this.maxValue,0,0],filled:n=!1}=t;this.checkProcessable("paintPoints",{bitDepth:[1,8,16]}),t.closed=!0;let a=deleteDouble(o);if(n===!1)return this.paintPolyline(o,t);{let l=Array(this.height);for(let c=0;c<this.height;c++){l[c]=[];for(let f=0;f<this.width;f++)l[c].push(0)}for(let c=0;c<a.length;c++){const f=lineBetweenTwoPoints(a[c],a[(c+1)%a.length]);for(let g=0;g<this.height;g++)for(let h=0;h<this.width;h++)isAtTheRightOfTheLine(h,g,f,this.height)&&(l[g][h]=l[g][h]===0?1:0)}for(let c=0;c<this.height;c++)for(let f=0;f<this.width;f++)if(l[c][f]===1)if(this.bitDepth===1)this.setBitXY(f,c);else{let g=Math.min(this.channels,e.length),h=(f+c*this.width)*this.channels;for(let p=0;p<g;p++)this.data[h+p]=e[p]}return this.paintPolyline(o,t)}}function deleteDouble(o){let t=[];for(let e=0;e<o.length;e++)if(!(o[e][0]===o[(e+1)%o.length][0]&&o[e][1]===o[(e+1)%o.length][1])){if(o[e][0]===o[(e-1+o.length)%o.length][0]&&o[e][1]===o[(e-1+o.length)%o.length][1])continue;if(o[(e+1)%o.length][0]===o[(e-1+o.length)%o.length][0]&&o[(e-1+o.length)%o.length][1]===o[(e+1)%o.length][1])continue;t.push(o[e])}return t}function lineBetweenTwoPoints(o,t){if(o[0]===t[0])return{a:0,b:o[0],vertical:!0};{const e=(t[1]-o[1])/(t[0]-o[0]),n=o[1]-e*o[0];return{a:e,b:n,vertical:!1}}}function isAtTheRightOfTheLine(o,t,e,n){if(e.vertical===!0)return e.b<=o;if(e.a===0)return!1;{const a=(t-e.b)/e.a;return a<o&&a>=0&&a<=n}}function paintPolygons(o,t={}){let e=Object.assign({},t);this.checkProcessable("paintPolygons",{bitDepth:[8,16]});let n=getColors(Object.assign({},t,{numberColors:o.length}));for(let a=0;a<o.length;a++)e.color=n[a%n.length],this.paintPolygon(o[a],e);return this}function getHistogram(o={}){let{maxSlots:t=256,channel:e,useAlpha:n=!0}=o;if(this.checkProcessable("getHistogram",{bitDepth:[1,8,16]}),e===void 0){if(this.components>1)throw new RangeError("You need to define the channel for an image that contains more than one channel");e=0}return getChannelHistogram.call(this,e,{useAlpha:n,maxSlots:t})}function getHistograms(o={}){const{maxSlots:t=256,useAlpha:e=!0}=o;this.checkProcessable("getHistograms",{bitDepth:[8,16]});let n=new Array(e?this.components:this.channels);for(let a=0;a<n.length;a++)n[a]=getChannelHistogram.call(this,a,{useAlpha:e,maxSlots:t});return n}function getChannelHistogram(o,t){let{useAlpha:e,maxSlots:n}=t;if(this.bitDepth===1){let g=[0,0];for(let h=0;h<this.height;h++)for(let p=0;p<this.width;p++){let s=this.getBitXY(h,p);s===0?g[0]+=1:s===1&&(g[1]+=1)}return g}let a=Math.log2(n);if(!isInteger$1(a))throw new RangeError("maxSlots must be a power of 2, for example: 64, 256, 1024");let l=0;this.bitDepth>a&&(l=this.bitDepth-a);let c=this.data,f=newArray$1(Math.pow(2,Math.min(this.bitDepth,a)),0);if(e&&this.alpha){let g=this.channels-o-1;for(let h=o;h<c.length;h+=this.channels)f[c[h]>>l]+=c[h+g]/this.maxValue}else for(let g=o;g<c.length;g+=this.channels)f[c[g]>>l]++;return f}function getColorHistogram(o={}){let{useAlpha:t=!0,nbSlots:e=512}=o;this.checkProcessable("getColorHistogram",{bitDepth:[8,16],components:[3]});let n=Math.log(e)/Math.log(8);if(n!==Math.floor(n))throw new RangeError("nbSlots must be a power of 8. Usually 8, 64, 512 or 4096");let a=this.bitDepth-n,l=this.data,c=newArray$1(Math.pow(8,n),0),f=Math.pow(2,n*2),g=Math.pow(2,n);for(let h=0;h<l.length;h+=this.channels){let p=(l[h]>>a)*f+(l[h+1]>>a)*g+(l[h+2]>>a);t&&this.alpha?c[p]+=l[h+this.channels-1]/this.maxValue:c[p]++}return c}function min(){this.checkProcessable("min",{bitDepth:[8,16,32]});let o=newArray$1(this.channels,1/0);for(let t=0;t<this.data.length;t+=this.channels)for(let e=0;e<this.channels;e++)this.data[t+e]<o[e]&&(o[e]=this.data[t+e]);return o}function max(){this.checkProcessable("max",{bitDepth:[8,16,32]});let o=newArray$1(this.channels,-1/0);for(let t=0;t<this.data.length;t+=this.channels)for(let e=0;e<this.channels;e++)this.data[t+e]>o[e]&&(o[e]=this.data[t+e]);return o}function sum(){this.checkProcessable("sum",{bitDepth:[8,16]});let o=newArray$1(this.channels,0);for(let t=0;t<this.data.length;t+=this.channels)for(let e=0;e<this.channels;e++)o[e]+=this.data[t+e];return o}function getMoment(o=0,t=0){this.checkProcessable("getMoment",{bitDepth:[1]});let e=0;for(let n=0;n<this.width;n++)for(let a=0;a<this.height;a++)this.getBitXY(n,a)===1&&(e+=n**o*a**t);return e}function localMaxima(o={}){let{mask:t,region:e=3,removeClosePoints:n=0,invert:a=!1,maxEquals:l=2}=o,c=this;this.checkProcessable("localMaxima",{bitDepth:[8,16],components:1}),e*=4;let f=a?0:1,g=[1,0,-1,0,1,1,-1,-1,2,0,-2,0,2,2,-2,-2],h=[0,1,0,-1,1,-1,1,-1,0,2,0,-2,2,-2,2,-2],p=e<=8?1:2,s=[];for(let r=p;r<c.height-p;r++)for(let u=p;u<c.width-p;u++){if(t&&t.getBitXY(u,r)!==f)continue;let d=0,m=0,b=c.data[u+r*c.width];for(let y=0;y<e;y++)a?c.data[u+g[y]+(r+h[y])*c.width]>b&&d++:c.data[u+g[y]+(r+h[y])*c.width]<b&&d++,c.data[u+g[y]+(r+h[y])*c.width]===b&&m++;d+m===e&&m<=l&&s.push([u,r])}if(n>0)for(let r=0;r<s.length;r++)for(let u=r+1;u<s.length;u++)Math.sqrt(Math.pow(s[r][0]-s[u][0],2)+Math.pow(s[r][1]-s[u][1],2))<n&&(s[r][0]=s[r][0]+s[u][0]>>1,s[r][1]=s[r][1]+s[u][1]>>1,s.splice(u,1),u--);return s}function mean(){let o=this.getHistograms({maxSlots:this.maxValue+1}),t=new Array(o.length);for(let e=0;e<o.length;e++){let n=o[e];t[e]=mean$2(n)}return t}function median(){let o=this.getHistograms({maxSlots:this.maxValue+1}),t=new Array(o.length);for(let e=0;e<o.length;e++){let n=o[e];t[e]=median$2(n)}return t}function points(){this.checkProcessable("points",{bitDepth:[1]});const o=[];for(let t=0;t<this.width;t++)for(let e=0;e<this.height;e++)this.getBitXY(t,e)===1&&o.push([t,e]);return o}function extendedPoints(){this.checkProcessable("extendedPoints",{bitDepth:[1]});const o=[];for(let t=0;t<this.height;t++)for(let e=0;e<this.width;e++)if(this.getBitXY(e,t)===1)for(o.push([e,t]),this.getBitXY(e+1,t)!==1?(o.push([e+1,t]),o.push([e+1,t+1]),this.getBitXY(e,t+1)!==1&&o.push([e,t+1])):this.getBitXY(e,t+1)!==1&&(o.push([e,t+1]),o.push([e+1,t+1]));e<this.width-2&&this.getBitXY(e+1,t)===1&&this.getBitXY(e+2,t)===1;)e++;return o}function getRelativePosition(o,t={}){if(this===o)return[0,0];let e=[0,0],n=this;for(;n;){if(n===o)return e;n.position&&(e[0]+=n.position[0],e[1]+=n.position[1]),n=n.parent}return t.defaultFurther?e:!1}function countAlphaPixels(o={}){let{alpha:t=1}=o;this.checkProcessable("countAlphaPixels",{bitDepth:[8,16],alpha:1});let e=0;if(t!==void 0){for(let n=this.components;n<this.data.length;n+=this.channels)this.data[n]===t&&e++;return e}else return this.size}function monotoneChainConvexHull$1(o,t={}){const{sorted:e}=t;e||(o=o.slice().sort(byXThenY));const n=o.length,a=new Array(n*2);let l=0;for(let f=0;f<n;f++){const g=o[f];for(;l>=2&&cw(a[l-2],a[l-1],g)<=0;)l--;a[l++]=g}const c=l+1;for(let f=n-2;f>=0;f--){const g=o[f];for(;l>=c&&cw(a[l-2],a[l-1],g)<=0;)l--;a[l++]=g}return a.slice(0,l-1)}function cw(o,t,e){return(t[1]-o[1])*(e[0]-o[0])-(t[0]-o[0])*(e[1]-o[1])}function byXThenY(o,t){return o[0]===t[0]?o[1]-t[1]:o[0]-t[0]}function monotoneChainConvexHull(){return monotoneChainConvexHull$1(this.extendedPoints,{sorted:!1})}function round(o){for(let t=0;t<o.length;t++)o[t][0]=Math.round(o[t][0]),o[t][1]=Math.round(o[t][1]);return o}function difference(o,t){return[o[0]-t[0],o[1]-t[1]]}function normalize(o){let t=Math.sqrt(o[0]**2+o[1]**2);return[o[0]/t,o[1]/t]}function rotate(o,t,e){e===void 0&&(e=new Array(t.length));let n=Math.cos(o),a=Math.sin(o);for(let l=0;l<e.length;++l)e[l]=[n*t[l][0]-a*t[l][1],a*t[l][0]+n*t[l][1]];return e}function perimeter(o){let t=0;for(let e=0;e<o.length;e++){let n=o[e][0],a=o[e][1],l=o[e===o.length-1?0:e+1][0],c=o[e===o.length-1?0:e+1][1];t+=Math.sqrt((l-n)**2+(c-a)**2)}return t}function surface(o){let t=0;for(let e=0;e<o.length;e++){let n=o[e][0],a=o[e===o.length-1?0:e+1][1],l=o[e===o.length-1?0:e+1][0],c=o[e][1];t+=n*a*.5,t-=l*c*.5}return Math.abs(t)}function minMax(o){let t=1/0,e=1/0,n=-1/0,a=-1/0;for(let l=0;l<o.length;l++)o[l][0]<t&&(t=o[l][0]),o[l][0]>n&&(n=o[l][0]),o[l][1]<e&&(e=o[l][1]),o[l][1]>a&&(a=o[l][1]);return[[t,e],[n,a]]}function moveToZeroZero(o,t){t===void 0&&(t=new Array(o.length).fill(0).map(()=>[]));let e=minMax(o),n=e[0][0],a=e[0][1];for(let l=0;l<o.length;l++)t[l][0]=o[l][0]-n,t[l][1]=o[l][1]-a;return t}function minimalBoundingRectangle(o={}){const{originalPoints:t=monotoneChainConvexHull.call(this)}=o;if(t.length===0)return[];if(t.length===1)return[t[0],t[0],t[0],t[0]];const e=new Array(t.length);let n=1/0,a=0,l;for(let c=0;c<e.length;c++){let f=getAngle$1(t[c],t[(c+1)%e.length]);rotate(-f,t,e);let g=e[c][0],h=e[c][1],p=e[(c+1)%e.length][0],s=e[(c+1)%e.length][1],r=!0,u=0,d=0,m=0;for(let x=0;x<e.length;x++){let _=e[x][0],v=e[x][1],E=(_-g)/(p-g);r===!0?(r=!1,u=E,d=E):(E<u&&(u=E),E>d&&(d=E));let I=(-(p-g)*v+p*h-s*g)/(p-g);Math.abs(I)>Math.abs(m)&&(m=I)}let b=[g+u*(p-g),h],y=[g+d*(p-g),h],w=Math.abs(m*(u-d)*(p-g));w<n&&(a=f,n=w,l=[b,y,[y[0],y[1]-m],[b[0],b[1]-m]])}return rotate(a,l,l),l}function getAngle$1(o,t){let e=difference(t,o),n=normalize(e),a=Math.acos(n[0]);return n[1]<0?-a:a}function extend$1(o){let t={inPlace:!0};o.extendMethod("invert",invert),o.extendMethod("abs",abs),o.extendMethod("level",level,t),o.extendMethod("add",add,t),o.extendMethod("subtract",subtract,t),o.extendMethod("subtractImage",subtractImage),o.extendMethod("multiply",multiply,t),o.extendMethod("divide",divide,t),o.extendMethod("hypotenuse",hypotenuse),o.extendMethod("background",background$1),o.extendMethod("flipX",flipX),o.extendMethod("flipY",flipY),o.extendMethod("blurFilter",blurFilter),o.extendMethod("medianFilter",medianFilter),o.extendMethod("gaussianFilter",gaussianFilter),o.extendMethod("sobelFilter",sobelFilter),o.extendMethod("gradientFilter",gradientFilter),o.extendMethod("scharrFilter",scharrFilter),o.extendMethod("dilate",dilate),o.extendMethod("erode",erode),o.extendMethod("open",open),o.extendMethod("close",close),o.extendMethod("topHat",topHat),o.extendMethod("blackHat",blackHat),o.extendMethod("morphologicalGradient",morphologicalGradient),o.extendMethod("warpingFourPoints",warpingFourPoints),o.extendMethod("crop",crop),o.extendMethod("cropAlpha",cropAlpha),o.extendMethod("resize",resize).extendMethod("scale",resize),o.extendMethod("hsv",hsv),o.extendMethod("hsl",hsl$1),o.extendMethod("cmyk",cmyk),o.extendMethod("rgba8",rgba8),o.extendMethod("grey",grey).extendMethod("gray",grey),o.extendMethod("mask",mask),o.extendMethod("pad",pad),o.extendMethod("colorDepth",colorDepth),o.extendMethod("setBorder",setBorder,t),o.extendMethod("rotate",rotate$1),o.extendMethod("rotateLeft",rotateLeft),o.extendMethod("rotateRight",rotateRight),o.extendMethod("insert",insert),o.extendMethod("getRow",getRow),o.extendMethod("getColumn",getColumn),o.extendMethod("getMatrix",getMatrix),o.extendMethod("setMatrix",setMatrix),o.extendMethod("getPixelsArray",getPixelsArray),o.extendMethod("getIntersection",getIntersection),o.extendMethod("getClosestCommonParent",getClosestCommonParent),o.extendMethod("getThreshold",getThreshold),o.extendMethod("split",split),o.extendMethod("getChannel",getChannel),o.extendMethod("combineChannels",combineChannels),o.extendMethod("setChannel",setChannel),o.extendMethod("getSimilarity",getSimilarity),o.extendMethod("getPixelsGrid",getPixelsGrid),o.extendMethod("getBestMatch",getBestMatch),o.extendMethod("cannyEdge",cannyEdge),o.extendMethod("convolution",convolution),o.extendMethod("extract",extract),o.extendMethod("floodFill",floodFill),o.extendMethod("paintLabels",paintLabels,t),o.extendMethod("paintMasks",paintMasks,t),o.extendMethod("paintPoints",paintPoints,t),o.extendMethod("paintPolyline",paintPolyline,t),o.extendMethod("paintPolylines",paintPolylines,t),o.extendMethod("paintPolygon",paintPolygon,t),o.extendMethod("paintPolygons",paintPolygons,t),o.extendMethod("countAlphaPixels",countAlphaPixels),o.extendMethod("monotoneChainConvexHull",monotoneChainConvexHull),o.extendMethod("minimalBoundingRectangle",minimalBoundingRectangle),o.extendMethod("getHistogram",getHistogram).extendProperty("histogram",getHistogram),o.extendMethod("getHistograms",getHistograms).extendProperty("histograms",getHistograms),o.extendMethod("getColorHistogram",getColorHistogram).extendProperty("colorHistogram",getColorHistogram),o.extendMethod("getMin",min).extendProperty("min",min),o.extendMethod("getMax",max).extendProperty("max",max),o.extendMethod("getSum",sum).extendProperty("sum",sum),o.extendMethod("getMoment",getMoment).extendProperty("moment",getMoment),o.extendMethod("getLocalMaxima",localMaxima),o.extendMethod("getMedian",median).extendProperty("median",median),o.extendMethod("getMean",mean).extendProperty("mean",mean),o.extendMethod("getPoints",points).extendProperty("points",points),o.extendMethod("getExtendedPoints",extendedPoints).extendProperty("extendedPoints",extendedPoints),o.extendMethod("getRelativePosition",getRelativePosition)}var quantities={exports:{}};(function(o,t){(function(e,n){o.exports=n()})(commonjsGlobal,function(){function e(k){return typeof k=="string"||k instanceof String}var n=Number.isFinite||window.isFinite;function a(k){return n(k)}function l(k){return k}function c(k){var L={};return k.filter(function(V){return L.hasOwnProperty(V)?!1:L[V]=!0})}function f(k,L){if(L.length!==k.length)return!1;for(var V=0;V<k.length;V++)if(L[V].compareArray&&!L[V].compareArray(k[V])||L[V]!==k[V])return!1;return!0}function g(k,L){Object.keys(L).forEach(function(V){k[V]=L[V]})}function h(){for(var k=1,L=0,V=0;V<arguments.length;V++){var nt=arguments[V];L=L+r(nt),k*=nt}return L!==0?s(k,L):k}function p(k,L){if(L===0)throw new Error("Divide by zero");var V=Math.pow(10,r(L)),nt=V/(V*L);return h(k,nt)}function s(k,L){return Math.round(k*Math.pow(10,L))/Math.pow(10,L)}function r(k){if(!isFinite(k))return 0;for(var L=0;k%1!==0;)k*=10,L++;return L}function u(){var k;if(!this)return k=Object.create(u.prototype),u.apply(k,arguments),k;k=Error.apply(this,arguments),this.name="QtyError",this.message=k.message,this.stack=k.stack}u.prototype=Object.create(Error.prototype,{constructor:{value:u}});function d(k,L){throw new u("Incompatible units: "+k+" and "+L)}var m={"<googol>":[["googol"],1e100,"prefix"],"<kibi>":[["Ki","Kibi","kibi"],Math.pow(2,10),"prefix"],"<mebi>":[["Mi","Mebi","mebi"],Math.pow(2,20),"prefix"],"<gibi>":[["Gi","Gibi","gibi"],Math.pow(2,30),"prefix"],"<tebi>":[["Ti","Tebi","tebi"],Math.pow(2,40),"prefix"],"<pebi>":[["Pi","Pebi","pebi"],Math.pow(2,50),"prefix"],"<exi>":[["Ei","Exi","exi"],Math.pow(2,60),"prefix"],"<zebi>":[["Zi","Zebi","zebi"],Math.pow(2,70),"prefix"],"<yebi>":[["Yi","Yebi","yebi"],Math.pow(2,80),"prefix"],"<yotta>":[["Y","Yotta","yotta"],1e24,"prefix"],"<zetta>":[["Z","Zetta","zetta"],1e21,"prefix"],"<exa>":[["E","Exa","exa"],1e18,"prefix"],"<peta>":[["P","Peta","peta"],1e15,"prefix"],"<tera>":[["T","Tera","tera"],1e12,"prefix"],"<giga>":[["G","Giga","giga"],1e9,"prefix"],"<mega>":[["M","Mega","mega"],1e6,"prefix"],"<kilo>":[["k","kilo"],1e3,"prefix"],"<hecto>":[["h","Hecto","hecto"],100,"prefix"],"<deca>":[["da","Deca","deca","deka"],10,"prefix"],"<deci>":[["d","Deci","deci"],.1,"prefix"],"<centi>":[["c","Centi","centi"],.01,"prefix"],"<milli>":[["m","Milli","milli"],.001,"prefix"],"<micro>":[["u","μ","µ","Micro","mc","micro"],1e-6,"prefix"],"<nano>":[["n","Nano","nano"],1e-9,"prefix"],"<pico>":[["p","Pico","pico"],1e-12,"prefix"],"<femto>":[["f","Femto","femto"],1e-15,"prefix"],"<atto>":[["a","Atto","atto"],1e-18,"prefix"],"<zepto>":[["z","Zepto","zepto"],1e-21,"prefix"],"<yocto>":[["y","Yocto","yocto"],1e-24,"prefix"],"<1>":[["1","<1>"],1,""],"<meter>":[["m","meter","meters","metre","metres"],1,"length",["<meter>"]],"<inch>":[["in","inch","inches",'"'],.0254,"length",["<meter>"]],"<foot>":[["ft","foot","feet","'"],.3048,"length",["<meter>"]],"<yard>":[["yd","yard","yards"],.9144,"length",["<meter>"]],"<mile>":[["mi","mile","miles"],1609.344,"length",["<meter>"]],"<naut-mile>":[["nmi","naut-mile"],1852,"length",["<meter>"]],"<league>":[["league","leagues"],4828,"length",["<meter>"]],"<furlong>":[["furlong","furlongs"],201.2,"length",["<meter>"]],"<rod>":[["rd","rod","rods"],5.029,"length",["<meter>"]],"<mil>":[["mil","mils"],254e-7,"length",["<meter>"]],"<angstrom>":[["ang","angstrom","angstroms"],1e-10,"length",["<meter>"]],"<fathom>":[["fathom","fathoms"],1.829,"length",["<meter>"]],"<pica>":[["pica","picas"],.00423333333,"length",["<meter>"]],"<point>":[["pt","point","points"],.000352777778,"length",["<meter>"]],"<redshift>":[["z","red-shift","redshift"],1302773e20,"length",["<meter>"]],"<AU>":[["AU","astronomical-unit"],1495979e5,"length",["<meter>"]],"<light-second>":[["ls","light-second"],299792500,"length",["<meter>"]],"<light-minute>":[["lmin","light-minute"],1798755e4,"length",["<meter>"]],"<light-year>":[["ly","light-year"],9460528e9,"length",["<meter>"]],"<parsec>":[["pc","parsec","parsecs"],3085678e10,"length",["<meter>"]],"<datamile>":[["DM","datamile"],1828.8,"length",["<meter>"]],"<kilogram>":[["kg","kilogram","kilograms"],1,"mass",["<kilogram>"]],"<AMU>":[["u","AMU","amu"],1660538921e-36,"mass",["<kilogram>"]],"<dalton>":[["Da","Dalton","Daltons","dalton","daltons"],1660538921e-36,"mass",["<kilogram>"]],"<slug>":[["slug","slugs"],14.5939029,"mass",["<kilogram>"]],"<short-ton>":[["tn","ton","short-ton"],907.18474,"mass",["<kilogram>"]],"<metric-ton>":[["tonne","metric-ton"],1e3,"mass",["<kilogram>"]],"<carat>":[["ct","carat","carats"],2e-4,"mass",["<kilogram>"]],"<pound>":[["lbs","lb","pound","pounds","#"],.45359237,"mass",["<kilogram>"]],"<ounce>":[["oz","ounce","ounces"],.0283495231,"mass",["<kilogram>"]],"<gram>":[["g","gram","grams","gramme","grammes"],.001,"mass",["<kilogram>"]],"<grain>":[["grain","grains","gr"],6479891e-11,"mass",["<kilogram>"]],"<dram>":[["dram","drams","dr"],.0017718452,"mass",["<kilogram>"]],"<stone>":[["stone","stones","st"],6.35029318,"mass",["<kilogram>"]],"<hectare>":[["hectare"],1e4,"area",["<meter>","<meter>"]],"<acre>":[["acre","acres"],4046.85642,"area",["<meter>","<meter>"]],"<sqft>":[["sqft"],1,"area",["<foot>","<foot>"]],"<liter>":[["l","L","liter","liters","litre","litres"],.001,"volume",["<meter>","<meter>","<meter>"]],"<gallon>":[["gal","gallon","gallons"],.0037854118,"volume",["<meter>","<meter>","<meter>"]],"<gallon-imp>":[["galimp","gallon-imp","gallons-imp"],.00454609,"volume",["<meter>","<meter>","<meter>"]],"<quart>":[["qt","quart","quarts"],.00094635295,"volume",["<meter>","<meter>","<meter>"]],"<pint>":[["pt","pint","pints"],.000473176475,"volume",["<meter>","<meter>","<meter>"]],"<pint-imp>":[["ptimp","pint-imp","pints-imp"],.00056826125,"volume",["<meter>","<meter>","<meter>"]],"<cup>":[["cu","cup","cups"],.000236588238,"volume",["<meter>","<meter>","<meter>"]],"<fluid-ounce>":[["floz","fluid-ounce","fluid-ounces"],295735297e-13,"volume",["<meter>","<meter>","<meter>"]],"<fluid-ounce-imp>":[["flozimp","floz-imp","fluid-ounce-imp","fluid-ounces-imp"],284130625e-13,"volume",["<meter>","<meter>","<meter>"]],"<tablespoon>":[["tb","tbsp","tbs","tablespoon","tablespoons"],147867648e-13,"volume",["<meter>","<meter>","<meter>"]],"<teaspoon>":[["tsp","teaspoon","teaspoons"],492892161e-14,"volume",["<meter>","<meter>","<meter>"]],"<bushel>":[["bu","bsh","bushel","bushels"],.035239072,"volume",["<meter>","<meter>","<meter>"]],"<oilbarrel>":[["bbl","oilbarrel","oilbarrels","oil-barrel","oil-barrels"],.158987294928,"volume",["<meter>","<meter>","<meter>"]],"<beerbarrel>":[["bl","bl-us","beerbarrel","beerbarrels","beer-barrel","beer-barrels"],.1173477658,"volume",["<meter>","<meter>","<meter>"]],"<beerbarrel-imp>":[["blimp","bl-imp","beerbarrel-imp","beerbarrels-imp","beer-barrel-imp","beer-barrels-imp"],.16365924,"volume",["<meter>","<meter>","<meter>"]],"<kph>":[["kph"],.277777778,"speed",["<meter>"],["<second>"]],"<mph>":[["mph"],.44704,"speed",["<meter>"],["<second>"]],"<knot>":[["kt","kn","kts","knot","knots"],.514444444,"speed",["<meter>"],["<second>"]],"<fps>":[["fps"],.3048,"speed",["<meter>"],["<second>"]],"<gee>":[["gee"],9.80665,"acceleration",["<meter>"],["<second>","<second>"]],"<Gal>":[["Gal"],.01,"acceleration",["<meter>"],["<second>","<second>"]],"<kelvin>":[["degK","kelvin"],1,"temperature",["<kelvin>"]],"<celsius>":[["degC","celsius","celsius","centigrade"],1,"temperature",["<kelvin>"]],"<fahrenheit>":[["degF","fahrenheit"],5/9,"temperature",["<kelvin>"]],"<rankine>":[["degR","rankine"],5/9,"temperature",["<kelvin>"]],"<temp-K>":[["tempK","temp-K"],1,"temperature",["<temp-K>"]],"<temp-C>":[["tempC","temp-C"],1,"temperature",["<temp-K>"]],"<temp-F>":[["tempF","temp-F"],5/9,"temperature",["<temp-K>"]],"<temp-R>":[["tempR","temp-R"],5/9,"temperature",["<temp-K>"]],"<second>":[["s","sec","secs","second","seconds"],1,"time",["<second>"]],"<minute>":[["min","mins","minute","minutes"],60,"time",["<second>"]],"<hour>":[["h","hr","hrs","hour","hours"],3600,"time",["<second>"]],"<day>":[["d","day","days"],3600*24,"time",["<second>"]],"<week>":[["wk","week","weeks"],7*3600*24,"time",["<second>"]],"<fortnight>":[["fortnight","fortnights"],1209600,"time",["<second>"]],"<year>":[["y","yr","year","years","annum"],31556926,"time",["<second>"]],"<decade>":[["decade","decades"],315569260,"time",["<second>"]],"<century>":[["century","centuries"],3155692600,"time",["<second>"]],"<pascal>":[["Pa","pascal","Pascal"],1,"pressure",["<kilogram>"],["<meter>","<second>","<second>"]],"<bar>":[["bar","bars"],1e5,"pressure",["<kilogram>"],["<meter>","<second>","<second>"]],"<mmHg>":[["mmHg"],133.322368,"pressure",["<kilogram>"],["<meter>","<second>","<second>"]],"<inHg>":[["inHg"],3386.3881472,"pressure",["<kilogram>"],["<meter>","<second>","<second>"]],"<torr>":[["torr"],133.322368,"pressure",["<kilogram>"],["<meter>","<second>","<second>"]],"<atm>":[["atm","ATM","atmosphere","atmospheres"],101325,"pressure",["<kilogram>"],["<meter>","<second>","<second>"]],"<psi>":[["psi"],6894.76,"pressure",["<kilogram>"],["<meter>","<second>","<second>"]],"<cmh2o>":[["cmH2O","cmh2o"],98.0638,"pressure",["<kilogram>"],["<meter>","<second>","<second>"]],"<inh2o>":[["inH2O","inh2o"],249.082052,"pressure",["<kilogram>"],["<meter>","<second>","<second>"]],"<poise>":[["P","poise"],.1,"viscosity",["<kilogram>"],["<meter>","<second>"]],"<stokes>":[["St","stokes"],1e-4,"viscosity",["<meter>","<meter>"],["<second>"]],"<mole>":[["mol","mole"],1,"substance",["<mole>"]],"<molar>":[["M","molar"],1e3,"concentration",["<mole>"],["<meter>","<meter>","<meter>"]],"<wtpercent>":[["wt%","wtpercent"],10,"concentration",["<kilogram>"],["<meter>","<meter>","<meter>"]],"<katal>":[["kat","katal","Katal"],1,"activity",["<mole>"],["<second>"]],"<unit>":[["U","enzUnit","unit"],16667e-19,"activity",["<mole>"],["<second>"]],"<farad>":[["F","farad","Farad"],1,"capacitance",["<second>","<second>","<second>","<second>","<ampere>","<ampere>"],["<meter>","<meter>","<kilogram>"]],"<coulomb>":[["C","coulomb","Coulomb"],1,"charge",["<ampere>","<second>"]],"<Ah>":[["Ah"],3600,"charge",["<ampere>","<second>"]],"<ampere>":[["A","Ampere","ampere","amp","amps"],1,"current",["<ampere>"]],"<siemens>":[["S","Siemens","siemens"],1,"conductance",["<second>","<second>","<second>","<ampere>","<ampere>"],["<kilogram>","<meter>","<meter>"]],"<henry>":[["H","Henry","henry"],1,"inductance",["<meter>","<meter>","<kilogram>"],["<second>","<second>","<ampere>","<ampere>"]],"<volt>":[["V","Volt","volt","volts"],1,"potential",["<meter>","<meter>","<kilogram>"],["<second>","<second>","<second>","<ampere>"]],"<ohm>":[["Ohm","ohm","Ω","Ω"],1,"resistance",["<meter>","<meter>","<kilogram>"],["<second>","<second>","<second>","<ampere>","<ampere>"]],"<weber>":[["Wb","weber","webers"],1,"magnetism",["<meter>","<meter>","<kilogram>"],["<second>","<second>","<ampere>"]],"<tesla>":[["T","tesla","teslas"],1,"magnetism",["<kilogram>"],["<second>","<second>","<ampere>"]],"<gauss>":[["G","gauss"],1e-4,"magnetism",["<kilogram>"],["<second>","<second>","<ampere>"]],"<maxwell>":[["Mx","maxwell","maxwells"],1e-8,"magnetism",["<meter>","<meter>","<kilogram>"],["<second>","<second>","<ampere>"]],"<oersted>":[["Oe","oersted","oersteds"],250/Math.PI,"magnetism",["<ampere>"],["<meter>"]],"<joule>":[["J","joule","Joule","joules"],1,"energy",["<meter>","<meter>","<kilogram>"],["<second>","<second>"]],"<erg>":[["erg","ergs"],1e-7,"energy",["<meter>","<meter>","<kilogram>"],["<second>","<second>"]],"<btu>":[["BTU","btu","BTUs"],1055.056,"energy",["<meter>","<meter>","<kilogram>"],["<second>","<second>"]],"<calorie>":[["cal","calorie","calories"],4.184,"energy",["<meter>","<meter>","<kilogram>"],["<second>","<second>"]],"<Calorie>":[["Cal","Calorie","Calories"],4184,"energy",["<meter>","<meter>","<kilogram>"],["<second>","<second>"]],"<therm-US>":[["th","therm","therms","Therm","therm-US"],105480400,"energy",["<meter>","<meter>","<kilogram>"],["<second>","<second>"]],"<Wh>":[["Wh"],3600,"energy",["<meter>","<meter>","<kilogram>"],["<second>","<second>"]],"<newton>":[["N","Newton","newton"],1,"force",["<kilogram>","<meter>"],["<second>","<second>"]],"<dyne>":[["dyn","dyne"],1e-5,"force",["<kilogram>","<meter>"],["<second>","<second>"]],"<pound-force>":[["lbf","pound-force"],4.448222,"force",["<kilogram>","<meter>"],["<second>","<second>"]],"<hertz>":[["Hz","hertz","Hertz"],1,"frequency",["<1>"],["<second>"]],"<radian>":[["rad","radian","radians"],1,"angle",["<radian>"]],"<degree>":[["deg","degree","degrees"],Math.PI/180,"angle",["<radian>"]],"<gradian>":[["gon","grad","gradian","grads"],Math.PI/200,"angle",["<radian>"]],"<steradian>":[["sr","steradian","steradians"],1,"solid_angle",["<steradian>"]],"<rotation>":[["rotation"],2*Math.PI,"angle",["<radian>"]],"<rpm>":[["rpm"],2*Math.PI/60,"angular_velocity",["<radian>"],["<second>"]],"<byte>":[["B","byte","bytes"],1,"information",["<byte>"]],"<bit>":[["b","bit","bits"],.125,"information",["<byte>"]],"<Bps>":[["Bps"],1,"information_rate",["<byte>"],["<second>"]],"<bps>":[["bps"],.125,"information_rate",["<byte>"],["<second>"]],"<dollar>":[["USD","dollar"],1,"currency",["<dollar>"]],"<cents>":[["cents"],.01,"currency",["<dollar>"]],"<candela>":[["cd","candela"],1,"luminosity",["<candela>"]],"<lumen>":[["lm","lumen"],1,"luminous_power",["<candela>","<steradian>"]],"<lux>":[["lux"],1,"illuminance",["<candela>","<steradian>"],["<meter>","<meter>"]],"<watt>":[["W","watt","watts"],1,"power",["<kilogram>","<meter>","<meter>"],["<second>","<second>","<second>"]],"<volt-ampere>":[["VA","volt-ampere"],1,"power",["<kilogram>","<meter>","<meter>"],["<second>","<second>","<second>"]],"<volt-ampere-reactive>":[["var","Var","VAr","VAR","volt-ampere-reactive"],1,"power",["<kilogram>","<meter>","<meter>"],["<second>","<second>","<second>"]],"<horsepower>":[["hp","horsepower"],745.699872,"power",["<kilogram>","<meter>","<meter>"],["<second>","<second>","<second>"]],"<gray>":[["Gy","gray","grays"],1,"radiation",["<meter>","<meter>"],["<second>","<second>"]],"<roentgen>":[["R","roentgen"],.00933,"radiation",["<meter>","<meter>"],["<second>","<second>"]],"<sievert>":[["Sv","sievert","sieverts"],1,"radiation",["<meter>","<meter>"],["<second>","<second>"]],"<becquerel>":[["Bq","becquerel","becquerels"],1,"radiation",["<1>"],["<second>"]],"<curie>":[["Ci","curie","curies"],37e9,"radiation",["<1>"],["<second>"]],"<cpm>":[["cpm"],1/60,"rate",["<count>"],["<second>"]],"<dpm>":[["dpm"],1/60,"rate",["<count>"],["<second>"]],"<bpm>":[["bpm"],1/60,"rate",["<count>"],["<second>"]],"<dot>":[["dot","dots"],1,"resolution",["<each>"]],"<pixel>":[["pixel","px"],1,"resolution",["<each>"]],"<ppi>":[["ppi"],1,"resolution",["<pixel>"],["<inch>"]],"<dpi>":[["dpi"],1,"typography",["<dot>"],["<inch>"]],"<cell>":[["cells","cell"],1,"counting",["<each>"]],"<each>":[["each"],1,"counting",["<each>"]],"<count>":[["count"],1,"counting",["<each>"]],"<base-pair>":[["bp","base-pair"],1,"counting",["<each>"]],"<nucleotide>":[["nt","nucleotide"],1,"counting",["<each>"]],"<molecule>":[["molecule","molecules"],1,"counting",["<1>"]],"<dozen>":[["doz","dz","dozen"],12,"prefix_only",["<each>"]],"<percent>":[["%","percent"],.01,"prefix_only",["<1>"]],"<ppm>":[["ppm"],1e-6,"prefix_only",["<1>"]],"<ppt>":[["ppt"],1e-9,"prefix_only",["<1>"]],"<gross>":[["gr","gross"],144,"prefix_only",["<dozen>","<dozen>"]],"<decibel>":[["dB","decibel","decibels"],1,"logarithmic",["<decibel>"]]},b=["<meter>","<kilogram>","<second>","<mole>","<ampere>","<radian>","<kelvin>","<temp-K>","<byte>","<dollar>","<candela>","<each>","<steradian>","<decibel>"],y="<1>",w=[y];function x(k,L){var V=L[1],nt=L[3]||[],wt=L[4]||[];if(!a(V))throw new u(k+": Invalid unit definition. 'scalar' must be a number");nt.forEach(function(Et){if(m[Et]===void 0)throw new u(k+": Invalid unit definition. Unit "+Et+" in 'numerator' is not recognized")}),wt.forEach(function(Et){if(m[Et]===void 0)throw new u(k+": Invalid unit definition. Unit "+Et+" in 'denominator' is not recognized")})}var _={},v={},E={},I={},S={};for(var T in m)if(m.hasOwnProperty(T)){var A=m[T];if(A[2]==="prefix"){_[T]=A[1];for(var O=0;O<A[0].length;O++)v[A[0][O]]=T}else{x(T,A),E[T]={scalar:A[1],numerator:A[3],denominator:A[4]};for(var $=0;$<A[0].length;$++)I[A[0][$]]=T}S[T]=A[0][0]}function D(k){var L,V=[],nt=Object.keys(m);if(typeof k>"u")for(L=0;L<nt.length;L++)["","prefix"].indexOf(m[nt[L]][2])===-1&&V.push(nt[L].substr(1,nt[L].length-2));else{if(this.getKinds().indexOf(k)===-1)throw new u("Kind not recognized");for(L=0;L<nt.length;L++)m[nt[L]][2]===k&&V.push(nt[L].substr(1,nt[L].length-2))}return V.sort(function(wt,Et){return wt.toLowerCase()<Et.toLowerCase()?-1:wt.toLowerCase()>Et.toLowerCase()?1:0})}function M(k){if(!I[k])throw new u("Unit not recognized");return m[I[k]][0]}var F=["length","time","temperature","mass","current","substance","luminosity","currency","information","angle"];function C(){if(this.signature)return this.signature;for(var k=R.call(this),L=0;L<k.length;L++)k[L]*=Math.pow(20,L);return k.reduce(function(V,nt){return V+nt},0)}function R(){if(!this.isBase())return R.call(this.toBase());for(var k=new Array(F.length),L=0;L<k.length;L++)k[L]=0;for(var V,nt,wt=0;wt<this.numerator.length;wt++)(V=m[this.numerator[wt]])&&(nt=F.indexOf(V[2]),nt>=0&&(k[nt]=k[nt]+1));for(var Et=0;Et<this.denominator.length;Et++)(V=m[this.denominator[Et]])&&(nt=F.indexOf(V[2]),nt>=0&&(k[nt]=k[nt]-1));return k}var j="[+-]",G="\\d+",W=j+"?"+G,Z="\\."+G,at="(?:"+G+"(?:"+Z+")?)|(?:"+Z+")",J="[Ee]"+W,Y="(?:"+at+")(?:"+J+")?",K=j+"?\\s*"+Y,it="("+K+")?\\s*([^/]*)(?:/(.+))?",rt=new RegExp("^"+it+"$"),yt="\\^|\\*{2}",ut="[01234]",St=new RegExp("([^ \\*\\d]+?)(?:"+yt+")?(-?"+ut+"(?![a-zA-Z]))"),gt=new RegExp("([^ \\*\\d]+?)(?:"+yt+")?("+ut+"(?![a-zA-Z]))");function Ot(k){e(k)||(k=k.toString()),k=k.trim();var L=rt.exec(k);if(!L)throw new u(k+": Quantity not recognized");var V=L[1];V?(V=V.replace(/\s/g,""),this.scalar=parseFloat(V)):this.scalar=1;for(var nt=L[2],wt=L[3],Et,Gt,Ut;L=St.exec(nt);){if(Et=parseFloat(L[2]),isNaN(Et))throw new u("Unit exponent is not a number");if(Et===0&&!It.test(L[1]))throw new u("Unit not recognized");Gt=L[1]+" ",Ut="";for(var Yt=0;Yt<Math.abs(Et);Yt++)Ut+=Gt;Et>=0?nt=nt.replace(L[0],Ut):(wt=wt?wt+Ut:Ut,nt=nt.replace(L[0],""))}for(;L=gt.exec(wt);){if(Et=parseFloat(L[2]),isNaN(Et))throw new u("Unit exponent is not a number");if(Et===0&&!It.test(L[1]))throw new u("Unit not recognized");Gt=L[1]+" ",Ut="";for(var Zt=0;Zt<Et;Zt++)Ut+=Gt;wt=wt.replace(L[0],Ut)}nt&&(this.numerator=ft(nt.trim())),wt&&(this.denominator=ft(wt.trim()))}var pt=Object.keys(v).sort(function(k,L){return L.length-k.length}).join("|"),ct=Object.keys(I).sort(function(k,L){return L.length-k.length}).join("|"),ot="\\b|$",Mt="("+pt+")??("+ct+")(?:"+ot+")",It=new RegExp("^\\s*("+Mt+"[\\s\\*]*)+$"),Dt=new RegExp(Mt,"g"),H={};function ft(k){var L=H[k];if(L)return L;var V,nt=[];if(!It.test(k))throw new u("Unit not recognized");for(;V=Dt.exec(k);)nt.push(V.slice(1));return nt=nt.map(function(wt){return v[wt[0]]?[v[wt[0]],I[wt[1]]]:[I[wt[1]]]}),nt=nt.reduce(function(wt,Et){return wt.concat(Et)},[]),nt=nt.filter(function(wt){return wt}),H[k]=nt,nt}function xt(k){if(!e(k))throw new u("Argument should be a string");try{return this(k)}catch{return null}}function _t(k){return k instanceof et}function et(k,L){if(Ct.apply(null,arguments),!_t(this))return new et(k,L);if(this.scalar=null,this.baseScalar=null,this.signature=null,this._conversionCache={},this.numerator=w,this.denominator=w,Pt(k)?(this.scalar=k.scalar,this.numerator=k.numerator&&k.numerator.length!==0?k.numerator:w,this.denominator=k.denominator&&k.denominator.length!==0?k.denominator:w):L?(Ot.call(this,L),this.scalar=k):Ot.call(this,k),this.denominator.join("*").indexOf("temp")>=0)throw new u("Cannot divide with temperatures");if(this.numerator.join("*").indexOf("temp")>=0){if(this.numerator.length>1)throw new u("Cannot multiply by temperatures");if(!f(this.denominator,w))throw new u("Cannot divide with temperatures")}if(this.initValue=k,mt.call(this),this.isTemperature()&&this.baseScalar<0)throw new u("Temperatures must not be less than absolute zero")}et.prototype={constructor:et};function Ct(k,L){if(L){if(!(a(k)&&e(L)))throw new u("Only number accepted as initialization value when units are explicitly provided")}else if(!(e(k)||a(k)||_t(k)||Pt(k)))throw new u("Only string, number or quantity accepted as single initialization value")}function Pt(k){return k&&typeof k=="object"&&k.hasOwnProperty("scalar")}function mt(){if(this.baseScalar)return this.baseScalar;if(this.isBase())this.baseScalar=this.scalar,this.signature=C.call(this);else{var k=this.toBase();this.baseScalar=k.scalar,this.signature=k.signature}}var vt={"-312078":"elastance","-312058":"resistance","-312038":"inductance","-152058":"potential","-152040":"magnetism","-152038":"magnetism","-7997":"specific_volume","-79":"snap","-59":"jolt","-39":"acceleration","-38":"radiation","-20":"frequency","-19":"speed","-18":"viscosity","-17":"volumetric_flow","-1":"wavenumber",0:"unitless",1:"length",2:"area",3:"volume",20:"time",400:"temperature",7941:"yank",7942:"power",7959:"pressure",7961:"force",7962:"energy",7979:"viscosity",7981:"momentum",7982:"angular_momentum",7997:"density",7998:"area_density",8e3:"mass",152020:"radiation_exposure",159999:"magnetism",16e4:"current",160020:"charge",312058:"conductance",312078:"capacitance",3199980:"activity",3199997:"molar_concentration",32e5:"substance",63999998:"illuminance",64e6:"luminous_power",128e7:"currency","25599999980":"information_rate","25600000000":"information","511999999980":"angular_velocity","512000000000":"angle"};function $t(){return c(Object.keys(vt).map(function(k){return vt[k]}))}et.prototype.kind=function(){return vt[this.signature.toString()]},g(et.prototype,{isDegrees:function(){return(this.signature===null||this.signature===400)&&this.numerator.length===1&&f(this.denominator,w)&&(this.numerator[0].match(/<temp-[CFRK]>/)||this.numerator[0].match(/<(kelvin|celsius|rankine|fahrenheit)>/))},isTemperature:function(){return this.isDegrees()&&this.numerator[0].match(/<temp-[CFRK]>/)}});function Tt(k,L){var V=k.units(),nt=L.to(V),wt=et(lt(V));return et({scalar:k.scalar-nt.scalar,numerator:wt.numerator,denominator:wt.denominator})}function kt(k,L){var V=L.to(lt(k.units()));return et({scalar:k.scalar-V.scalar,numerator:k.numerator,denominator:k.denominator})}function Rt(k,L){var V=L.to(lt(k.units()));return et({scalar:k.scalar+V.scalar,numerator:k.numerator,denominator:k.denominator})}function lt(k){if(k==="tempK")return"degK";if(k==="tempC")return"degC";if(k==="tempF")return"degF";if(k==="tempR")return"degR";throw new u("Unknown type for temp conversion from: "+k)}function B(k,L){var V=z(k),nt=L.units(),wt;if(nt==="degK")wt=V.scalar;else if(nt==="degC")wt=V.scalar;else if(nt==="degF")wt=V.scalar*9/5;else if(nt==="degR")wt=V.scalar*9/5;else throw new u("Unknown type for degree conversion to: "+nt);return et({scalar:wt,numerator:L.numerator,denominator:L.denominator})}function z(k){var L=k.units(),V;if(L.match(/(deg)[CFRK]/))V=k.baseScalar;else if(L==="tempK")V=k.scalar;else if(L==="tempC")V=k.scalar;else if(L==="tempF")V=k.scalar*5/9;else if(L==="tempR")V=k.scalar*5/9;else throw new u("Unknown type for temp conversion from: "+L);return et({scalar:V,numerator:["<kelvin>"],denominator:w})}function Q(k,L){var V=L.units(),nt;if(V==="tempK")nt=k.baseScalar;else if(V==="tempC")nt=k.baseScalar-273.15;else if(V==="tempF")nt=k.baseScalar*9/5-459.67;else if(V==="tempR")nt=k.baseScalar*9/5;else throw new u("Unknown type for temp conversion to: "+V);return et({scalar:nt,numerator:L.numerator,denominator:L.denominator})}function st(k){var L=k.units(),V;if(L.match(/(deg)[CFRK]/))V=k.baseScalar;else if(L==="tempK")V=k.scalar;else if(L==="tempC")V=k.scalar+273.15;else if(L==="tempF")V=(k.scalar+459.67)*5/9;else if(L==="tempR")V=k.scalar*5/9;else throw new u("Unknown type for temp conversion from: "+L);return et({scalar:V,numerator:["<temp-K>"],denominator:w})}g(et.prototype,{to:function(k){var L,V;if(k==null)return this;if(!e(k))return this.to(k.units());if(L=this._conversionCache[k],L)return L;if(V=et(k),V.units()===this.units())return this;if(!this.isCompatible(V))this.isInverse(V)?V=this.inverse().to(k):d(this.units(),V.units());else if(V.isTemperature())V=Q(this,V);else if(V.isDegrees())V=B(this,V);else{var nt=p(this.baseScalar,V.baseScalar);V=et({scalar:nt,numerator:V.numerator,denominator:V.denominator})}return this._conversionCache[k]=V,V},toBase:function(){if(this.isBase())return this;if(this.isTemperature())return st(this);var k=bt[this.units()];return k||(k=Ft(this.numerator,this.denominator),bt[this.units()]=k),k.mul(this.scalar)},toFloat:function(){if(this.isUnitless())return this.scalar;throw new u("Can't convert to Float unless unitless.  Use Unit#scalar")},toPrec:function(k){if(e(k)&&(k=et(k)),a(k)&&(k=et(k+" "+this.units())),this.isUnitless()?k.isUnitless()||d(this.units(),k.units()):k=k.to(this.units()),k.scalar===0)throw new u("Divide by zero");var L=h(Math.round(this.scalar/k.scalar),k.scalar);return et(L+this.units())}});function ht(k,L){var V=et(k),nt=et(L);if(V.eq(nt))return l;var wt;return V.isTemperature()?wt=function(Et){return V.mul(Et).to(nt).scalar}:wt=function(Et){return Et*V.baseScalar/nt.baseScalar},function(Gt){var Ut,Yt,Zt;if(Array.isArray(Gt)){for(Yt=Gt.length,Zt=[],Ut=0;Ut<Yt;Ut++)Zt.push(wt(Gt[Ut]));return Zt}else return wt(Gt)}}var bt={};function Ft(k,L){for(var V=[],nt=[],wt=1,Et,Gt=0;Gt<k.length;Gt++)Et=k[Gt],_[Et]?wt=h(wt,_[Et]):E[Et]&&(wt*=E[Et].scalar,E[Et].numerator&&V.push(E[Et].numerator),E[Et].denominator&&nt.push(E[Et].denominator));for(var Ut=0;Ut<L.length;Ut++)Et=L[Ut],_[Et]?wt/=_[Et]:E[Et]&&(wt/=E[Et].scalar,E[Et].numerator&&nt.push(E[Et].numerator),E[Et].denominator&&V.push(E[Et].denominator));return V=V.reduce(function(Yt,Zt){return Yt.concat(Zt)},[]),nt=nt.reduce(function(Yt,Zt){return Yt.concat(Zt)},[]),et({scalar:wt,numerator:V,denominator:nt})}et.parse=xt,et.getUnits=D,et.getAliases=M,et.mulSafe=h,et.divSafe=p,et.getKinds=$t,et.swiftConverter=ht,et.Error=u,g(et.prototype,{add:function(k){if(e(k)&&(k=et(k)),this.isCompatible(k)||d(this.units(),k.units()),this.isTemperature()&&k.isTemperature())throw new u("Cannot add two temperatures");return this.isTemperature()?Rt(this,k):k.isTemperature()?Rt(k,this):et({scalar:this.scalar+k.to(this).scalar,numerator:this.numerator,denominator:this.denominator})},sub:function(k){if(e(k)&&(k=et(k)),this.isCompatible(k)||d(this.units(),k.units()),this.isTemperature()&&k.isTemperature())return Tt(this,k);if(this.isTemperature())return kt(this,k);if(k.isTemperature())throw new u("Cannot subtract a temperature from a differential degree unit");return et({scalar:this.scalar-k.to(this).scalar,numerator:this.numerator,denominator:this.denominator})},mul:function(k){if(a(k))return et({scalar:h(this.scalar,k),numerator:this.numerator,denominator:this.denominator});if(e(k)&&(k=et(k)),(this.isTemperature()||k.isTemperature())&&!(this.isUnitless()||k.isUnitless()))throw new u("Cannot multiply by temperatures");var L=this,V=k;L.isCompatible(V)&&L.signature!==400&&(V=V.to(L));var nt=Ht(L.numerator,L.denominator,V.numerator,V.denominator);return et({scalar:h(L.scalar,V.scalar,nt[2]),numerator:nt[0],denominator:nt[1]})},div:function(k){if(a(k)){if(k===0)throw new u("Divide by zero");return et({scalar:this.scalar/k,numerator:this.numerator,denominator:this.denominator})}else e(k)&&(k=et(k));if(k.scalar===0)throw new u("Divide by zero");if(k.isTemperature())throw new u("Cannot divide with temperatures");if(this.isTemperature()&&!k.isUnitless())throw new u("Cannot divide with temperatures");var L=this,V=k;L.isCompatible(V)&&L.signature!==400&&(V=V.to(L));var nt=Ht(L.numerator,L.denominator,V.denominator,V.numerator);return et({scalar:h(L.scalar,nt[2])/V.scalar,numerator:nt[0],denominator:nt[1]})},inverse:function(){if(this.isTemperature())throw new u("Cannot divide with temperatures");if(this.scalar===0)throw new u("Divide by zero");return et({scalar:1/this.scalar,numerator:this.denominator,denominator:this.numerator})}});function Ht(k,L,V,nt){function wt(Bt){return Bt!==y}k=k.filter(wt),V=V.filter(wt),L=L.filter(wt),nt=nt.filter(wt);var Et={};function Gt(Bt,te){for(var Kt,re,ae,ie=0;ie<Bt.length;ie++)if(_[Bt[ie]]?(Kt=Bt[ie+1],re=Bt[ie],ae=_[re],ie++):(Kt=Bt[ie],re=null,ae=1),Kt&&Kt!==y)if(Et[Kt]){Et[Kt][0]+=te;var ue=Et[Kt][2]?_[Et[Kt][2]]:1;Et[Kt][te===1?3:4]*=p(ae,ue)}else Et[Kt]=[te,Kt,re,1,1]}Gt(k,1),Gt(L,-1),Gt(V,1),Gt(nt,-1);var Ut=[],Yt=[],Zt=1;for(var se in Et)if(Et.hasOwnProperty(se)){var qt=Et[se],oe;if(qt[0]>0)for(oe=0;oe<qt[0];oe++)Ut.push(qt[2]===null?qt[1]:[qt[2],qt[1]]);else if(qt[0]<0)for(oe=0;oe<-qt[0];oe++)Yt.push(qt[2]===null?qt[1]:[qt[2],qt[1]]);Zt*=p(qt[3],qt[4])}return Ut.length===0&&(Ut=w),Yt.length===0&&(Yt=w),Ut=Ut.reduce(function(Bt,te){return Bt.concat(te)},[]),Yt=Yt.reduce(function(Bt,te){return Bt.concat(te)},[]),[Ut,Yt,Zt]}g(et.prototype,{eq:function(k){return this.compareTo(k)===0},lt:function(k){return this.compareTo(k)===-1},lte:function(k){return this.eq(k)||this.lt(k)},gt:function(k){return this.compareTo(k)===1},gte:function(k){return this.eq(k)||this.gt(k)},compareTo:function(k){if(e(k))return this.compareTo(et(k));if(this.isCompatible(k)||d(this.units(),k.units()),this.baseScalar<k.baseScalar)return-1;if(this.baseScalar===k.baseScalar)return 0;if(this.baseScalar>k.baseScalar)return 1},same:function(k){return this.scalar===k.scalar&&this.units()===k.units()}}),g(et.prototype,{isUnitless:function(){return[this.numerator,this.denominator].every(function(k){return f(k,w)})},isCompatible:function(k){return e(k)?this.isCompatible(et(k)):_t(k)&&k.signature!==void 0?this.signature===k.signature:!1},isInverse:function(k){return this.inverse().isCompatible(k)},isBase:function(){return this._isBase!==void 0?this._isBase:this.isDegrees()&&this.numerator[0].match(/<(kelvin|temp-K)>/)?(this._isBase=!0,this._isBase):(this.numerator.concat(this.denominator).forEach(function(k){k!==y&&b.indexOf(k)===-1&&(this._isBase=!1)},this),this._isBase===!1?this._isBase:(this._isBase=!0,this._isBase))}});function zt(){}zt.prototype.get=function(k){return arguments.length>1&&(k=Array.apply(null,arguments)),k.reduce(function(L,V,nt){if(L){var wt=L[V];return nt===k.length-1?wt?wt.data:void 0:wt}},this)},zt.prototype.set=function(k,L){return arguments.length>2&&(k=Array.prototype.slice.call(arguments,0,-1),L=arguments[arguments.length-1]),k.reduce(function(V,nt,wt){var Et=V[nt];return Et===void 0&&(Et=V[nt]={}),wt===k.length-1?(Et.data=L,L):Et},this)};function Vt(k,L){return(k+" "+L).trim()}et.formatter=Vt,g(et.prototype,{units:function(){if(this._units!==void 0)return this._units;var k=f(this.numerator,w),L=f(this.denominator,w);if(k&&L)return this._units="",this._units;var V=Xt(this.numerator),nt=Xt(this.denominator);return this._units=V+(L?"":"/"+nt),this._units},toString:function(k,L){var V;if(a(k))V=this.units(),L=k;else if(e(k))V=k;else if(_t(k))return this.toPrec(k).toString(L);var nt=this.to(V),wt=L!==void 0?s(nt.scalar,L):nt.scalar;return nt=(wt+" "+nt.units()).trim(),nt},format:function(k,L){arguments.length===1&&typeof k=="function"&&(L=k,k=void 0),L=L||et.formatter;var V=this.to(k);return L.call(this,V.scalar,V.units())}});var jt=new zt;function Xt(k){var L=jt.get(k);if(L)return L;var V=f(k,w);return V?L="1":L=q(Jt(k)).join("*"),jt.set(k,L),L}function Jt(k){for(var L=[],V,nt,wt=0;wt<k.length;wt++)V=k[wt],nt=k[wt+1],_[V]?(L.push(S[V]+S[nt]),wt++):L.push(S[V]);return L}function q(k){var L=k.reduce(function(V,nt){var wt=V[nt];return wt||V.push(wt=V[nt]=[nt,0]),wt[1]++,V},[]);return L.map(function(V){return V[0]+(V[1]>1?V[1]:"")})}return et.version="1.7.6",et})})(quantities);var quantitiesExports=quantities.exports,Qty=getDefaultExportFromCjs(quantitiesExports);function deepValue(o,t=""){let e=t.split(".");for(let n of e){if(o[n]===void 0)return;o=o[n]}return o}var orientation={exports:{}},twoProduct_1=twoProduct$1,SPLITTER=+(Math.pow(2,27)+1);function twoProduct$1(o,t,e){var n=o*t,a=SPLITTER*o,l=a-o,c=a-l,f=o-c,g=SPLITTER*t,h=g-t,p=g-h,s=t-p,r=n-c*p,u=r-f*p,d=u-c*s,m=f*s-d;return e?(e[0]=m,e[1]=n,e):[m,n]}var robustSum=linearExpansionSum;function scalarScalar$1(o,t){var e=o+t,n=e-o,a=e-n,l=t-n,c=o-a,f=c+l;return f?[f,e]:[e]}function linearExpansionSum(o,t){var e=o.length|0,n=t.length|0;if(e===1&&n===1)return scalarScalar$1(o[0],t[0]);var a=e+n,l=new Array(a),c=0,f=0,g=0,h=Math.abs,p=o[f],s=h(p),r=t[g],u=h(r),d,m;s<u?(m=p,f+=1,f<e&&(p=o[f],s=h(p))):(m=r,g+=1,g<n&&(r=t[g],u=h(r))),f<e&&s<u||g>=n?(d=p,f+=1,f<e&&(p=o[f],s=h(p))):(d=r,g+=1,g<n&&(r=t[g],u=h(r)));for(var b=d+m,y=b-d,w=m-y,x=w,_=b,v,E,I,S,T;f<e&&g<n;)s<u?(d=p,f+=1,f<e&&(p=o[f],s=h(p))):(d=r,g+=1,g<n&&(r=t[g],u=h(r))),m=x,b=d+m,y=b-d,w=m-y,w&&(l[c++]=w),v=_+b,E=v-_,I=v-E,S=b-E,T=_-I,x=T+S,_=v;for(;f<e;)d=p,m=x,b=d+m,y=b-d,w=m-y,w&&(l[c++]=w),v=_+b,E=v-_,I=v-E,S=b-E,T=_-I,x=T+S,_=v,f+=1,f<e&&(p=o[f]);for(;g<n;)d=r,m=x,b=d+m,y=b-d,w=m-y,w&&(l[c++]=w),v=_+b,E=v-_,I=v-E,S=b-E,T=_-I,x=T+S,_=v,g+=1,g<n&&(r=t[g]);return x&&(l[c++]=x),_&&(l[c++]=_),c||(l[c++]=0),l.length=c,l}var twoSum$1=fastTwoSum;function fastTwoSum(o,t,e){var n=o+t,a=n-o,l=n-a,c=t-a,f=o-l;return e?(e[0]=f+c,e[1]=n,e):[f+c,n]}var twoProduct=twoProduct_1,twoSum=twoSum$1,robustScale=scaleLinearExpansion;function scaleLinearExpansion(o,t){var e=o.length;if(e===1){var n=twoProduct(o[0],t);return n[0]?n:[n[1]]}var a=new Array(2*e),l=[.1,.1],c=[.1,.1],f=0;twoProduct(o[0],t,l),l[0]&&(a[f++]=l[0]);for(var g=1;g<e;++g){twoProduct(o[g],t,c);var h=l[1];twoSum(h,c[0],l),l[0]&&(a[f++]=l[0]);var p=c[1],s=l[1],r=p+s,u=r-p,d=s-u;l[1]=r,d&&(a[f++]=d)}return l[1]&&(a[f++]=l[1]),f===0&&(a[f++]=0),a.length=f,a}var robustDiff=robustSubtract;function scalarScalar(o,t){var e=o+t,n=e-o,a=e-n,l=t-n,c=o-a,f=c+l;return f?[f,e]:[e]}function robustSubtract(o,t){var e=o.length|0,n=t.length|0;if(e===1&&n===1)return scalarScalar(o[0],-t[0]);var a=e+n,l=new Array(a),c=0,f=0,g=0,h=Math.abs,p=o[f],s=h(p),r=-t[g],u=h(r),d,m;s<u?(m=p,f+=1,f<e&&(p=o[f],s=h(p))):(m=r,g+=1,g<n&&(r=-t[g],u=h(r))),f<e&&s<u||g>=n?(d=p,f+=1,f<e&&(p=o[f],s=h(p))):(d=r,g+=1,g<n&&(r=-t[g],u=h(r)));for(var b=d+m,y=b-d,w=m-y,x=w,_=b,v,E,I,S,T;f<e&&g<n;)s<u?(d=p,f+=1,f<e&&(p=o[f],s=h(p))):(d=r,g+=1,g<n&&(r=-t[g],u=h(r))),m=x,b=d+m,y=b-d,w=m-y,w&&(l[c++]=w),v=_+b,E=v-_,I=v-E,S=b-E,T=_-I,x=T+S,_=v;for(;f<e;)d=p,m=x,b=d+m,y=b-d,w=m-y,w&&(l[c++]=w),v=_+b,E=v-_,I=v-E,S=b-E,T=_-I,x=T+S,_=v,f+=1,f<e&&(p=o[f]);for(;g<n;)d=r,m=x,b=d+m,y=b-d,w=m-y,w&&(l[c++]=w),v=_+b,E=v-_,I=v-E,S=b-E,T=_-I,x=T+S,_=v,g+=1,g<n&&(r=-t[g]);return x&&(l[c++]=x),_&&(l[c++]=_),c||(l[c++]=0),l.length=c,l}(function(o){var t=twoProduct_1,e=robustSum,n=robustScale,a=robustDiff,l=5,c=11102230246251565e-32,f=(3+16*c)*c,g=(7+56*c)*c;function h(x,_,v,E){return function(S,T,A){var O=x(x(_(T[1],A[0]),_(-A[1],T[0])),x(_(S[1],T[0]),_(-T[1],S[0]))),$=x(_(S[1],A[0]),_(-A[1],S[0])),D=E(O,$);return D[D.length-1]}}function p(x,_,v,E){return function(S,T,A,O){var $=x(x(v(x(_(A[1],O[0]),_(-O[1],A[0])),T[2]),x(v(x(_(T[1],O[0]),_(-O[1],T[0])),-A[2]),v(x(_(T[1],A[0]),_(-A[1],T[0])),O[2]))),x(v(x(_(T[1],O[0]),_(-O[1],T[0])),S[2]),x(v(x(_(S[1],O[0]),_(-O[1],S[0])),-T[2]),v(x(_(S[1],T[0]),_(-T[1],S[0])),O[2])))),D=x(x(v(x(_(A[1],O[0]),_(-O[1],A[0])),S[2]),x(v(x(_(S[1],O[0]),_(-O[1],S[0])),-A[2]),v(x(_(S[1],A[0]),_(-A[1],S[0])),O[2]))),x(v(x(_(T[1],A[0]),_(-A[1],T[0])),S[2]),x(v(x(_(S[1],A[0]),_(-A[1],S[0])),-T[2]),v(x(_(S[1],T[0]),_(-T[1],S[0])),A[2])))),M=E($,D);return M[M.length-1]}}function s(x,_,v,E){return function(S,T,A,O,$){var D=x(x(x(v(x(v(x(_(O[1],$[0]),_(-$[1],O[0])),A[2]),x(v(x(_(A[1],$[0]),_(-$[1],A[0])),-O[2]),v(x(_(A[1],O[0]),_(-O[1],A[0])),$[2]))),T[3]),x(v(x(v(x(_(O[1],$[0]),_(-$[1],O[0])),T[2]),x(v(x(_(T[1],$[0]),_(-$[1],T[0])),-O[2]),v(x(_(T[1],O[0]),_(-O[1],T[0])),$[2]))),-A[3]),v(x(v(x(_(A[1],$[0]),_(-$[1],A[0])),T[2]),x(v(x(_(T[1],$[0]),_(-$[1],T[0])),-A[2]),v(x(_(T[1],A[0]),_(-A[1],T[0])),$[2]))),O[3]))),x(v(x(v(x(_(A[1],O[0]),_(-O[1],A[0])),T[2]),x(v(x(_(T[1],O[0]),_(-O[1],T[0])),-A[2]),v(x(_(T[1],A[0]),_(-A[1],T[0])),O[2]))),-$[3]),x(v(x(v(x(_(O[1],$[0]),_(-$[1],O[0])),T[2]),x(v(x(_(T[1],$[0]),_(-$[1],T[0])),-O[2]),v(x(_(T[1],O[0]),_(-O[1],T[0])),$[2]))),S[3]),v(x(v(x(_(O[1],$[0]),_(-$[1],O[0])),S[2]),x(v(x(_(S[1],$[0]),_(-$[1],S[0])),-O[2]),v(x(_(S[1],O[0]),_(-O[1],S[0])),$[2]))),-T[3])))),x(x(v(x(v(x(_(T[1],$[0]),_(-$[1],T[0])),S[2]),x(v(x(_(S[1],$[0]),_(-$[1],S[0])),-T[2]),v(x(_(S[1],T[0]),_(-T[1],S[0])),$[2]))),O[3]),x(v(x(v(x(_(T[1],O[0]),_(-O[1],T[0])),S[2]),x(v(x(_(S[1],O[0]),_(-O[1],S[0])),-T[2]),v(x(_(S[1],T[0]),_(-T[1],S[0])),O[2]))),-$[3]),v(x(v(x(_(A[1],O[0]),_(-O[1],A[0])),T[2]),x(v(x(_(T[1],O[0]),_(-O[1],T[0])),-A[2]),v(x(_(T[1],A[0]),_(-A[1],T[0])),O[2]))),S[3]))),x(v(x(v(x(_(A[1],O[0]),_(-O[1],A[0])),S[2]),x(v(x(_(S[1],O[0]),_(-O[1],S[0])),-A[2]),v(x(_(S[1],A[0]),_(-A[1],S[0])),O[2]))),-T[3]),x(v(x(v(x(_(T[1],O[0]),_(-O[1],T[0])),S[2]),x(v(x(_(S[1],O[0]),_(-O[1],S[0])),-T[2]),v(x(_(S[1],T[0]),_(-T[1],S[0])),O[2]))),A[3]),v(x(v(x(_(T[1],A[0]),_(-A[1],T[0])),S[2]),x(v(x(_(S[1],A[0]),_(-A[1],S[0])),-T[2]),v(x(_(S[1],T[0]),_(-T[1],S[0])),A[2]))),-O[3]))))),M=x(x(x(v(x(v(x(_(O[1],$[0]),_(-$[1],O[0])),A[2]),x(v(x(_(A[1],$[0]),_(-$[1],A[0])),-O[2]),v(x(_(A[1],O[0]),_(-O[1],A[0])),$[2]))),S[3]),v(x(v(x(_(O[1],$[0]),_(-$[1],O[0])),S[2]),x(v(x(_(S[1],$[0]),_(-$[1],S[0])),-O[2]),v(x(_(S[1],O[0]),_(-O[1],S[0])),$[2]))),-A[3])),x(v(x(v(x(_(A[1],$[0]),_(-$[1],A[0])),S[2]),x(v(x(_(S[1],$[0]),_(-$[1],S[0])),-A[2]),v(x(_(S[1],A[0]),_(-A[1],S[0])),$[2]))),O[3]),v(x(v(x(_(A[1],O[0]),_(-O[1],A[0])),S[2]),x(v(x(_(S[1],O[0]),_(-O[1],S[0])),-A[2]),v(x(_(S[1],A[0]),_(-A[1],S[0])),O[2]))),-$[3]))),x(x(v(x(v(x(_(A[1],$[0]),_(-$[1],A[0])),T[2]),x(v(x(_(T[1],$[0]),_(-$[1],T[0])),-A[2]),v(x(_(T[1],A[0]),_(-A[1],T[0])),$[2]))),S[3]),v(x(v(x(_(A[1],$[0]),_(-$[1],A[0])),S[2]),x(v(x(_(S[1],$[0]),_(-$[1],S[0])),-A[2]),v(x(_(S[1],A[0]),_(-A[1],S[0])),$[2]))),-T[3])),x(v(x(v(x(_(T[1],$[0]),_(-$[1],T[0])),S[2]),x(v(x(_(S[1],$[0]),_(-$[1],S[0])),-T[2]),v(x(_(S[1],T[0]),_(-T[1],S[0])),$[2]))),A[3]),v(x(v(x(_(T[1],A[0]),_(-A[1],T[0])),S[2]),x(v(x(_(S[1],A[0]),_(-A[1],S[0])),-T[2]),v(x(_(S[1],T[0]),_(-T[1],S[0])),A[2]))),-$[3])))),F=E(D,M);return F[F.length-1]}}function r(x){var _=x===3?h:x===4?p:s;return _(e,t,n,a)}var u=r(3),d=r(4),m=[function(){return 0},function(){return 0},function(_,v){return v[0]-_[0]},function(_,v,E){var I=(_[1]-E[1])*(v[0]-E[0]),S=(_[0]-E[0])*(v[1]-E[1]),T=I-S,A;if(I>0){if(S<=0)return T;A=I+S}else if(I<0){if(S>=0)return T;A=-(I+S)}else return T;var O=f*A;return T>=O||T<=-O?T:u(_,v,E)},function(_,v,E,I){var S=_[0]-I[0],T=v[0]-I[0],A=E[0]-I[0],O=_[1]-I[1],$=v[1]-I[1],D=E[1]-I[1],M=_[2]-I[2],F=v[2]-I[2],C=E[2]-I[2],R=T*D,j=A*$,G=A*O,W=S*D,Z=S*$,at=T*O,J=M*(R-j)+F*(G-W)+C*(Z-at),Y=(Math.abs(R)+Math.abs(j))*Math.abs(M)+(Math.abs(G)+Math.abs(W))*Math.abs(F)+(Math.abs(Z)+Math.abs(at))*Math.abs(C),K=g*Y;return J>K||-J>K?J:d(_,v,E,I)}];function b(x){var _=m[x.length];return _||(_=m[x.length]=r(x.length)),_.apply(void 0,x)}function y(x,_,v,E,I,S,T){return function(O,$,D,M,F){switch(arguments.length){case 0:case 1:return 0;case 2:return E(O,$);case 3:return I(O,$,D);case 4:return S(O,$,D,M);case 5:return T(O,$,D,M,F)}for(var C=new Array(arguments.length),R=0;R<arguments.length;++R)C[R]=arguments[R];return x(C)}}function w(){for(;m.length<=l;)m.push(r(m.length));o.exports=y.apply(void 0,[b].concat(m));for(var x=0;x<=l;++x)o.exports[x]=m[x]}w()})(orientation);var orientationExports=orientation.exports,robustPnp=robustPointInPolygon,orient=orientationExports;function robustPointInPolygon(o,t){for(var e=t[0],n=t[1],a=o.length,l=1,c=a,f=0,g=a-1;f<c;g=f++){var h=o[f],p=o[g],s=h[1],r=p[1];if(r<s){if(r<n&&n<s){var u=orient(h,p,t);if(u===0)return 0;l^=0<u|0}else if(n===s){var d=o[(f+1)%a],m=d[1];if(s<m){var u=orient(h,p,t);if(u===0)return 0;l^=0<u|0}}}else if(s<r){if(s<n&&n<r){var u=orient(h,p,t);if(u===0)return 0;l^=u<0|0}else if(n===s){var d=o[(f+1)%a],m=d[1];if(m<s){var u=orient(h,p,t);if(u===0)return 0;l^=u<0|0}}}else if(n===s){var b=Math.min(h[0],p[0]),y=Math.max(h[0],p[0]);if(f===0){for(;g>0;){var w=(g+a-1)%a,x=o[w];if(x[1]!==n)break;var _=x[0];b=Math.min(b,_),y=Math.max(y,_),g=w}if(g===0)return b<=e&&e<=y?0:1;c=g+1}for(var v=o[(g+a-1)%a][1];f+1<c;){var x=o[f+1];if(x[1]!==n)break;var _=x[0];b=Math.min(b,_),y=Math.max(y,_),f+=1}if(b<=e&&e<=y)return 0;var E=o[(f+1)%a][1];e<b&&v<n!=E<n&&(l^=1)}}return 2*l-1}var robustPointInPolygon$1=getDefaultExportFromCjs(robustPnp);function feretDiameters(o={}){const{originalPoints:t=monotoneChainConvexHull.call(this)}=o;if(t.length===0)return{min:0,max:0,minLine:[],maxLine:[],aspectRatio:1};if(t.length===1)return{min:1,max:1,minLine:[t[0],t[0]],maxLine:[t[0],t[0]],aspectRatio:1};const e=new Array(t.length);let n=1/0,a=0,l=[];for(let h=0;h<t.length;h++){let p=getAngle(t[h],t[(h+1)%t.length]);rotate(-p,t,e);let s=0,r=[];for(let u=0;u<t.length;u++){let d=Math.abs(e[h][1]-e[u][1]);d>s&&(s=d,r=[],r.push([e[u][0],e[h][1]],[e[u][0],e[u][1]]))}s<n&&(n=s,a=p,l=r)}rotate(a,l,l);let c=0,f=[],g=0;for(let h=0;h<t.length-1;h++)for(let p=h+1;p<t.length;p++){let s=(t[h][0]-t[p][0])**2+(t[h][1]-t[p][1])**2;s>g&&(g=s,c=Math.sqrt(s),f=[t[h],t[p]])}return{min:n,minLine:l,max:c,maxLine:f,aspectRatio:n/c}}function getAngle(o,t){let e=difference(t,o),n=normalize(e),a=Math.acos(n[0]);return n[1]<0?-a:a}class Roi{constructor(t,e){this.map=t,this.id=e,this.minX=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY,this.meanX=0,this.meanY=0,this.surface=0,this.computed={}}getMask(t={}){const{scale:e=1,kind:n=""}=t;let a;switch(n){case"contour":a=this.contourMask;break;case"box":a=this.boxMask;break;case"filled":a=this.filledMask;break;case"center":a=this.centerMask;break;case"mbr":a=this.mbrFilledMask;break;case"hull":a=this.convexHullFilledMask;break;case"hullContour":a=this.convexHullMask;break;case"mbrContour":a=this.mbrMask;break;case"feret":a=this.feretMask;break;default:a=this.mask}return e<1&&(a=a.resize({factor:e}),a.parent=this.mask.parent,a.position[0]+=this.minX,a.position[1]+=this.minY),a}get mean(){throw new Error("Roi mean not implemented yet")}get center(){return this.computed.center||(this.computed.center=[this.width/2>>0,this.height/2>>0]),this.computed.center}get ratio(){return this.width/this.height}get width(){return this.maxX-this.minX+1}get height(){return this.maxY-this.minY+1}_computExternalIDs(){let t=this.borderIDs,e=this.borderLengths;this.computed.externalIDs=[],this.computed.externalLengths=[];let n=this.internalIDs;for(let a=0;a<t.length;a++)n.includes(t[a])||(this.computed.externalIDs.push(t[a]),this.computed.externalLengths.push(e[a]))}get externalIDs(){return this.computed.externalIDs?this.computed.externalIDs:(this._computExternalIDs(),this.computed.externalIDs)}get externalLengths(){return this.computed.externalLengths?this.computed.externalLengths:(this._computExternalIDs(),this.computed.externalLengths)}_computeBorderIDs(){let t=getBorders(this);this.computed.borderIDs=t.ids,this.computed.borderLengths=t.lengths}get borderIDs(){return this.computed.borderIDs?this.computed.borderIDs:(this._computeBorderIDs(),this.computed.borderIDs)}get borderLengths(){return this.computed.borderLengths?this.computed.borderLengths:(this._computeBorderIDs(),this.computed.borderLengths)}get boxIDs(){return this.computed.boxIDs||(this.computed.boxIDs=getBoxIDs(this)),this.computed.boxIDs}get internalIDs(){return this.computed.internalIDs||(this.computed.internalIDs=getInternalIDs(this)),this.computed.internalIDs}get box(){return this.computed.box||(this.computed.box=getBox(this)),this.computed.box}get external(){return this.computed.external||(this.computed.external=getExternal(this)),this.computed.external}get holesInfo(){return this.computed.holesInfo||(this.computed.holesInfo=getHolesInfo(this)),this.computed.holesInfo}get border(){return this.computed.border||(this.computed.border=getBorder(this)),this.computed.border}get contourMask(){if(!this.computed.contourMask){let t=new Image$1(this.width,this.height,{kind:BINARY,position:[this.minX,this.minY],parent:this.map.parent});for(let e=0;e<this.width;e++)for(let n=0;n<this.height;n++)this.map.data[e+this.minX+(n+this.minY)*this.map.width]===this.id&&(e>0&&e<this.width-1&&n>0&&n<this.height-1?(this.map.data[e-1+this.minX+(n+this.minY)*this.map.width]!==this.id||this.map.data[e+1+this.minX+(n+this.minY)*this.map.width]!==this.id||this.map.data[e+this.minX+(n-1+this.minY)*this.map.width]!==this.id||this.map.data[e+this.minX+(n+1+this.minY)*this.map.width]!==this.id)&&t.setBitXY(e,n):t.setBitXY(e,n));this.computed.contourMask=t}return this.computed.contourMask}get boxMask(){if(!this.computed.boxMask){let t=new Image$1(this.width,this.height,{kind:BINARY,position:[this.minX,this.minY],parent:this.map.parent});for(let e=0;e<this.width;e++)t.setBitXY(e,0),t.setBitXY(e,this.height-1);for(let e=0;e<this.height;e++)t.setBitXY(0,e),t.setBitXY(this.width-1,e);this.computed.boxMask=t}return this.computed.boxMask}get mask(){if(!this.computed.mask){let t=new Image$1(this.width,this.height,{kind:BINARY,position:[this.minX,this.minY],parent:this.map.parent});for(let e=0;e<this.width;e++)for(let n=0;n<this.height;n++)this.map.data[e+this.minX+(n+this.minY)*this.map.width]===this.id&&t.setBitXY(e,n);this.computed.mask=t}return this.computed.mask}get filledMask(){if(!this.computed.filledMask){let t=new Image$1(this.width,this.height,{kind:BINARY,position:[this.minX,this.minY],parent:this.map.parent});for(let e=0;e<this.width;e++)for(let n=0;n<this.height;n++){let a=e+this.minX+(n+this.minY)*this.map.width;this.internalIDs.includes(this.map.data[a])&&t.setBitXY(e,n)}this.computed.filledMask=t}return this.computed.filledMask}get centerMask(){if(!this.computed.centerMask){let t=new Shape({kind:"smallCross"}).getMask();t.parent=this.map.parent,t.position=[this.minX+this.center[0]-1,this.minY+this.center[1]-1],this.computed.centerMask=t}return this.computed.centerMask}get convexHull(){if(!this.computed.convexHull){const t=[];for(let n=0;n<this.width;n++)for(let a=0;a<this.height;a++)this.map.data[n+this.minX+(a+this.minY)*this.map.width]===this.id&&(n>0&&n<this.width-1&&a>0&&a<this.height-1?(this.map.data[n-1+this.minX+(a+this.minY)*this.map.width]!==this.id||this.map.data[n+1+this.minX+(a+this.minY)*this.map.width]!==this.id||this.map.data[n+this.minX+(a-1+this.minY)*this.map.width]!==this.id||this.map.data[n+this.minX+(a+1+this.minY)*this.map.width]!==this.id)&&(t.push([n,a]),t.push([n+1,a]),t.push([n,a+1]),t.push([n+1,a+1])):(t.push([n,a]),t.push([n+1,a]),t.push([n,a+1]),t.push([n+1,a+1])));const e=monotoneChainConvexHull$1(t);this.computed.convexHull={polyline:e,surface:surface(e),perimeter:perimeter(e)}}return this.computed.convexHull}get convexHullMask(){if(!this.computed.convexHullMask){const t=this.convexHull,e=new Image$1(this.width+1,this.height+1,{kind:BINARY,position:[this.minX,this.minY],parent:this.map.parent});e.paintPolyline(t.polyline,{closed:!0}),this.computed.convexHullMask=e}return this.computed.convexHullMask}get convexHullFilledMask(){if(!this.computed.convexHullFilledMask){const t=this.convexHull,e=new Image$1(this.width,this.height,{kind:BINARY,position:[this.minX,this.minY],parent:this.map.parent});for(let n=0;n<this.width;n++)for(let a=0;a<this.height;a++)robustPointInPolygon$1(t.polyline,[n,a])!==1&&e.setBitXY(n,a);this.computed.convexHullFilledMask=e}return this.computed.convexHullFilledMask}get mbr(){if(!this.computed.mbr){let t=minimalBoundingRectangle({originalPoints:this.convexHull.polyline});if(t.length===0)this.computed.mbr={width:0,height:0,surface:0,perimeter:0,rectangle:t};else{let e=t[0],n=t[1],a=t[2],l=Math.sqrt((e[0]-n[0])**2+(e[1]-n[1])**2),c=Math.sqrt((a[0]-n[0])**2+(a[1]-n[1])**2);this.computed.mbr={width:l,height:c,elongation:1-l/c,aspectRatio:l/c,surface:l*c,perimeter:(l+c)*2,rectangle:t}}}return this.computed.mbr}get fillRatio(){return this.surface/(this.surface+this.holesInfo.surface)}get feretDiameters(){return this.computed.feretDiameters||(this.computed.feretDiameters=feretDiameters({originalPoints:this.convexHull.polyline})),this.computed.feretDiameters}get eqpc(){return this.computed.eqpc||(this.computed.eqpc=2*Math.sqrt(this.surface/Math.PI)),this.computed.eqpc}get perimeterInfo(){return this.computed.perimeterInfo||(this.computed.perimeterInfo=getPerimeterInfo(this)),this.computed.perimeterInfo}get perimeter(){let t=this.perimeterInfo,e=2-Math.sqrt(2);return t.one+t.two*2+t.three*3+t.four*4-e*(t.two+t.three*2+t.four)}get ped(){return this.computed.ped||(this.computed.ped=this.perimeter/Math.PI),this.computed.ped}get feretMask(){if(!this.computed.feretMask){const t=new Image$1(this.width+1,this.height+1,{kind:BINARY,position:[this.minX,this.minY],parent:this.map.parent});t.paintPolyline(this.feretDiameters.minLine),t.paintPolyline(this.feretDiameters.maxLine),this.computed.feretMask=t}return this.computed.feretMask}get mbrMask(){if(!this.computed.mbrMask){let t=round(this.mbr.rectangle);if(t.length>0){const e=minMax(t),n=new Image$1(e[1][0]-e[0][0]+1,e[1][1]-e[0][1]+1,{kind:BINARY,position:[this.minX+e[0][0],this.minY+e[0][1]],parent:this.map.parent});t=moveToZeroZero(t),n.paintPolyline(t,{closed:!0}),this.computed.mbrMask=n}else this.computed.mbrMask=new Image$1(1,1,{kind:BINARY,position:[this.minX,this.minY],parent:this.map.parent})}return this.computed.mbrMask}get mbrFilledMask(){if(!this.computed.mbrFilledMask){const t=new Image$1(this.width,this.height,{kind:BINARY,position:[this.minX,this.minY],parent:this.map.parent}),e=this.mask.minimalBoundingRectangle();for(let n=0;n<this.width;n++)for(let a=0;a<this.height;a++)robustPointInPolygon$1(e,[n,a])!==1&&t.setBitXY(n,a);this.computed.mbrFilledMask=t}return this.computed.mbrFilledMask}get points(){if(!this.computed.points){let t=[];for(let e=0;e<this.height;e++)for(let n=0;n<this.width;n++){let a=(e+this.minY)*this.map.width+n+this.minX;this.map.data[a]===this.id&&t.push([n,e])}this.computed.points=t}return this.computed.points}get maxLengthPoints(){if(!this.computed.maxLengthPoints){let t=0,e;const n=this.points;for(let a=0;a<n.length;a++)for(let l=a+1;l<n.length;l++){let c=Math.pow(n[a][0]-n[l][0],2)+Math.pow(n[a][1]-n[l][1],2);c>=t&&(t=c,e=[n[a],n[l]])}this.computed.maxLengthPoints=e}return this.computed.maxLengthPoints}get maxLength(){if(!this.computed.maxLength){let t=Math.sqrt(Math.pow(this.maxLengthPoints[0][0]-this.maxLengthPoints[1][0],2)+Math.pow(this.maxLengthPoints[0][1]-this.maxLengthPoints[1][1],2));this.computed.maxLength=t}return this.computed.maxLength}get roundness(){return 4*this.surface/(Math.PI*this.feretDiameters.max**2)}get sphericity(){return 2*Math.sqrt(this.surface*Math.PI)/this.perimeter}get solidity(){return this.surface/this.convexHull.surface}get angle(){if(!this.computed.angle){let t=this.maxLengthPoints,e=-Math.atan2(t[0][1]-t[1][1],t[0][0]-t[1][0])*180/Math.PI;this.computed.angle=e}return this.computed.angle}toJSON(){return{id:this.id,minX:this.minX,maxX:this.maxX,minY:this.minY,maxY:this.maxY,meanX:this.meanX,meanY:this.meanY,height:this.height,width:this.width,surface:this.surface,mbrWidth:this.mbr.width,mbrHeight:this.mbr.height,mbrSurface:this.mbr.surface,eqpc:this.eqpc,ped:this.ped,feretDiameterMin:this.feretDiameters.min,feretDiameterMax:this.feretDiameters.max,aspectRatio:this.feretDiameters.aspectRatio,fillRatio:this.fillRatio,sphericity:this.sphericity,roundness:this.roundness,solidity:this.solidity,perimeter:this.perimeter}}}function getBorders(o){let t=o.map,e=t.data,n=new Set,a=new Map,l=new Set,c=[1,0,-1,0],f=[0,1,0,-1];for(let p=o.minX;p<=o.maxX;p++)for(let s=o.minY;s<=o.maxY;s++){let r=p+s*t.width;if(e[r]===o.id)for(let u=0;u<4;u++){let d=p+c[u],m=s+f[u];if(d>=0&&m>=0&&d<t.width&&m<t.height){let b=d+m*t.width;if(e[b]!==o.id&&!l.has(b)){l.add(b),n.add(e[b]);let y=a.get(e[b]);y?a.set(e[b],++y):a.set(e[b],1)}}}}let g=Array.from(n),h=g.map(function(p){return a.get(p)});return{ids:g,lengths:h}}function getBoxIDs(o){let t=new Set,e=o.map,n=e.data;for(let a of[0,o.height-1])for(let l=0;l<o.width;l++){let c=(a+o.minY)*e.width+l+o.minX;if(l-o.minX>0&&n[c]===o.id&&n[c-1]!==o.id){let f=n[c-1];t.add(f)}if(e.width-l-o.minX>1&&n[c]===o.id&&n[c+1]!==o.id){let f=n[c+1];t.add(f)}}for(let a of[0,o.width-1])for(let l=0;l<o.height;l++){let c=(l+o.minY)*e.width+a+o.minX;if(l-o.minY>0&&n[c]===o.id&&n[c-e.width]!==o.id){let f=n[c-e.width];t.add(f)}if(e.height-l-o.minY>1&&n[c]===o.id&&n[c+e.width]!==o.id){let f=n[c+e.width];t.add(f)}}return Array.from(t)}function getBox(o){let t=0,e=o.map,n=e.data,a=[0];o.height>1&&(a[1]=o.height-1);for(let c of a)for(let f=1;f<o.width-1;f++){let g=(c+o.minY)*e.width+f+o.minX;n[g]===o.id&&t++}let l=[0];o.width>1&&(l[1]=o.width-1);for(let c of l)for(let f=0;f<o.height;f++){let g=(f+o.minY)*e.width+c+o.minX;n[g]===o.id&&t++}return t}function getBorder(o){let t=0,e=o.map,n=e.data;for(let a=1;a<o.width-1;a++)for(let l=1;l<o.height-1;l++){let c=(l+o.minY)*e.width+a+o.minX;n[c]===o.id&&(n[c-1]!==o.id||n[c+1]!==o.id||n[c-e.width]!==o.id||n[c+e.width]!==o.id)&&t++}return t+o.box}function getPerimeterInfo(o){let t=o.map,e=t.data,n=0,a=0,l=0,c=0;for(let f=0;f<o.width;f++)for(let g=0;g<o.height;g++){let h=(g+o.minY)*t.width+f+o.minX;if(e[h]===o.id){let p=0;switch((f===0||o.externalIDs.includes(e[h-1]))&&p++,(f===o.width-1||o.externalIDs.includes(e[h+1]))&&p++,(g===0||o.externalIDs.includes(e[h-t.width]))&&p++,(g===o.height-1||o.externalIDs.includes(e[h+t.width]))&&p++,p){case 1:n++;break;case 2:a++;break;case 3:l++;break;case 4:c++;break}}}return{one:n,two:a,three:l,four:c}}function getExternal(o){let t=0,e=o.map,n=e.data;for(let a=1;a<o.width-1;a++)for(let l=1;l<o.height-1;l++){let c=(l+o.minY)*e.width+a+o.minX;n[c]===o.id&&(o.externalIDs.includes(n[c-1])||o.externalIDs.includes(n[c+1])||o.externalIDs.includes(n[c-e.width])||o.externalIDs.includes(n[c+e.width]))&&t++}return t+o.box}function getHolesInfo(o){let t=0,e=o.map.width,n=o.map.data;for(let a=1;a<o.width-1;a++)for(let l=1;l<o.height-1;l++){let c=(l+o.minY)*e+a+o.minX;o.internalIDs.includes(n[c])&&n[c]!==o.id&&t++}return{number:o.internalIDs.length-1,surface:t}}function getInternalIDs(o){let t=[o.id],e=o.map,n=e.data;if(o.height>2)for(let l=0;l<o.width;l++){let c=o.minY*e.width+l+o.minX;if(t.includes(n[c])){let f=n[c+e.width];!t.includes(f)&&!o.boxIDs.includes(f)&&t.push(f)}}let a=new Array(4);for(let l=1;l<o.width-1;l++)for(let c=1;c<o.height-1;c++){let f=(c+o.minY)*e.width+l+o.minX;if(t.includes(n[f])){a[0]=n[f-1],a[1]=n[f+1],a[2]=n[f-e.width],a[3]=n[f+e.width];for(let g=0;g<4;g++){let h=a[g];!t.includes(h)&&!o.boxIDs.includes(h)&&t.push(h)}}}return t}class RoiLayer{constructor(t,e){this.roiMap=t,this.options=e,this.roi=this.createRoi()}createRoi(){let t=this.roiMap.data,e={};this.roiMap.positive=0,this.roiMap.negative=0;for(let f=0;f<t.length;f++)t[f]&&!e[t[f]]&&(e[t[f]]=!0,t[f]>0?this.roiMap.positive++:this.roiMap.negative++);let n={};for(let f in e)n[f]=new Roi(this.roiMap,f*1);let a=this.roiMap.width,l=this.roiMap.height;for(let f=0;f<l;f++)for(let g=0;g<a;g++){let h=f*a+g;if(t[h]!==0){const p=t[h],s=n[p];g<s.minX&&(s.minX=g),g>s.maxX&&(s.maxX=g),f<s.minY&&(s.minY=f),f>s.maxY&&(s.maxY=f),s.meanX+=g,s.meanY+=f,s.surface++}}let c=[];for(let f in e)n[f].meanX/=n[f].surface,n[f].meanY/=n[f].surface,c.push(n[f]);return c}}function commonBorderLength(o){let t=o.data,e=[1,0,-1,0],n=[0,1,0,-1],a=o.minMax,l=-a.min,c=a.max+l,f=[];for(let h=0;h<=c;h++)f.push(Object.create(null));for(let h=0;h<o.width;h++)for(let p=0;p<o.height;p++){let s=h+p*o.width,r=t[s];if(r!==0){let u=Object.create(null),d=!1;for(let m=0;m<4;m++){let b=h+e[m],y=p+n[m];if(b>=0&&y>=0&&b<o.width&&y<o.height){let w=t[b+y*o.width];r!==w&&(d=!0,w!==0&&u[w]===void 0&&(u[w]=!0,f[w+l][r]?f[w+l][r]++:f[w+l][r]=1))}else d=!0}d&&(f[r+l][r]?f[r+l][r]++:f[r+l][r]=1)}}let g={};for(let h=0;h<f.length;h++)Object.keys(f[h]).length>0&&(g[h-l]=f[h]);return g}function mergeRoi(o={}){const{algorithm:t="commonBorderLength",minCommonBorderLength:e=5,maxCommonBorderLength:n=100,minCommonBorderRatio:a=.3,maxCommonBorderRatio:l=1}=o;let c=function(b,y,w){return b[w]>=e&&b[w]<=n};typeof t=="function"&&(c=t),t.toLowerCase()==="commonborderratio"&&(c=function(b,y,w){let x=Math.min(b[w]/b[y],1);return x>=a&&x<=l});const f=this,g=f.commonBorderLength;let h={},p={};for(let b of Object.keys(g)){let y=g[b],w=Object.keys(y);for(let x of w)if(x!==b&&c(y,b,x)){let _=x;p[x]&&(_=p[x]);let v=b;if(p[b]&&(v=p[b]),Number(_)!==v){let E=Math.min(_,v),I=Math.max(_,v);if(h[E]||(h[E]={}),h[E][I]=!0,p[I]=E,h[I]){for(let S of Object.keys(h[I]))h[E][S]=!0,p[S]=E;delete h[I]}}}}let s=f.minMax,r=-s.min,u=s.max+r,d=new Array(u+1).fill(0);for(let b of Object.keys(p))d[Number(b)+r]=p[b];let m=f.data;for(let b=0;b<m.length;b++){let y=m[b];if(y!==0){let w=d[y+r];w!==0&&(m[b]=w)}}return f.computed={},f}class RoiMap{constructor(t,e){this.parent=t,this.width=t.width,this.height=t.height,this.data=e,this.negative=0,this.positive=0}get total(){return this.negative+this.positive}get minMax(){let t=Number.MAX_SAFE_INTEGER,e=Number.MIN_SAFE_INTEGER;for(let n=0;n<this.data.length;n++)this.data[n]<t&&(t=this.data[n]),this.data[n]>e&&(e=this.data[n]);return{min:t,max:e}}get commonBorderLength(){return commonBorderLength(this)}mergeRoi(t={}){return mergeRoi.call(this,t)}mergeRois(t){const e=t[0],n=t.slice(1);for(let a=0;a<this.data.length;a++)n.includes(this.data[a])&&(this.data[a]=e)}rowsInfo(){let t=new Array(this.height),e=0;for(let n=0;n<this.data.length;n+=this.width){let a={row:e,positivePixel:0,negativePixel:0,zeroPixel:0,positiveRoi:0,negativeRoi:0,medianChange:0};t[e++]=a;let l={},c={},f=[],g=this.data[n],h=0;for(let p=n;p<n+this.width;p++){let s=this.data[p];g!==s&&(g=s,f.push(h),h=0),h++,s>0?(a.positivePixel++,l[s]||(l[s]=!0)):s<0?(a.negativePixel++,c[s]||(c[s]=!0)):a.zeroPixel++}f.push(h),a.medianChange=f.sort((p,s)=>p-s)[Math.floor(f.length/2)],a.positiveRoiIDs=Object.keys(l),a.negativeRoiIDs=Object.keys(c),a.positiveRoi=a.positiveRoiIDs.length,a.negativeRoi=a.negativeRoiIDs.length}return t}colsInfo(){let t=new Array(this.width),e=0;for(let n=0;n<this.width;n++){let a={col:e,positivePixel:0,negativePixel:0,zeroPixel:0,positiveRoi:0,negativeRoi:0,medianChange:0};t[e++]=a;let l={},c={},f=[],g=this.data[n],h=0;for(let p=n;p<n+this.data.length;p+=this.width){let s=this.data[p];g!==s&&(g=s,f.push(h),h=0),h++,s>0?(a.positivePixel++,l[s]||(l[s]=!0)):s<0?(a.negativePixel++,c[s]||(c[s]=!0)):a.zeroPixel++}f.push(h),a.medianChange=f.sort((p,s)=>p-s)[Math.floor(f.length/2)],a.positiveRoiIDs=Object.keys(l),a.negativeRoiIDs=Object.keys(c),a.positiveRoi=a.positiveRoiIDs.length,a.negativeRoi=a.negativeRoiIDs.length}return t}}function fromMask(o,t={}){const{allowCorners:e=!1}=t,n=65535;let a=new Int16Array(o.size),l=0,c=0,f=new Uint16Array(n+1),g=new Uint16Array(n+1);for(let p=0;p<o.width;p++)for(let s=0;s<o.height;s++)a[s*o.width+p]===0&&h(p,s);function h(p,s){let r=0,u=0,d=o.getBitXY(p,s),m=d?++l:--c;if(l>32767||c<-32768)throw new Error("Too many regions of interest");for(f[0]=p,g[0]=s;r<=u;){let b=f[r&n],y=g[r&n];if(a[y*o.width+b]=m,b>0&&a[y*o.width+b-1]===0&&o.getBitXY(b-1,y)===d&&(u++,f[u&n]=b-1,g[u&n]=y,a[y*o.width+b-1]=-32768),y>0&&a[(y-1)*o.width+b]===0&&o.getBitXY(b,y-1)===d&&(u++,f[u&n]=b,g[u&n]=y-1,a[(y-1)*o.width+b]=-32768),b<o.width-1&&a[y*o.width+b+1]===0&&o.getBitXY(b+1,y)===d&&(u++,f[u&n]=b+1,g[u&n]=y,a[y*o.width+b+1]=-32768),y<o.height-1&&a[(y+1)*o.width+b]===0&&o.getBitXY(b,y+1)===d&&(u++,f[u&n]=b,g[u&n]=y+1,a[(y+1)*o.width+b]=-32768),e&&(b>0&&y>0&&a[(y-1)*o.width+b-1]===0&&o.getBitXY(b-1,y-1)===d&&(u++,f[u&n]=b-1,g[u&n]=y-1,a[(y-1)*o.width+b-1]=-32768),b<o.width-1&&y>0&&a[(y-1)*o.width+b+1]===0&&o.getBitXY(b+1,y-1)===d&&(u++,f[u&n]=b+1,g[u&n]=y-1,a[(y-1)*o.width+b+1]=-32768),b>0&&y<o.height-1&&a[(y+1)*o.width+b-1]===0&&o.getBitXY(b-1,y+1)===d&&(u++,f[u&n]=b-1,g[u&n]=y+1,a[(y+1)*o.width+b-1]=-32768),b<o.width-1&&y<o.height-1&&a[(y+1)*o.width+b+1]===0&&o.getBitXY(b+1,y+1)===d&&(u++,f[u&n]=b+1,g[u&n]=y+1,a[(y+1)*o.width+b+1]=-32768)),r++,u-r>n)throw new Error("analyseMask can not finish, the array to manage internal data is not big enough.You could improve mask by changing MAX_ARRAY")}}return new RoiMap(o,a)}class DisjointSet{constructor(){this.nodes=new Map}add(t){var e=this.nodes.get(t);return e||(e=new DisjointSetNode(t),this.nodes.set(t,e)),e}union(t,e){const n=this.find(t),a=this.find(e);n!==a&&(n.rank<a.rank?n.parent=a:n.rank>a.rank?a.parent=n:(a.parent=n,n.rank++))}find(t){for(var e=t;e.parent!==null;)e=e.parent;for(var n=t;n.parent!==null;){var a=n;n=n.parent,a.parent=e}return e}connected(t,e){return this.find(t)===this.find(e)}}var DisjointSet_1=DisjointSet;function DisjointSetNode(o){this.value=o,this.parent=null,this.rank=0}var DisjointSet$1=getDefaultExportFromCjs(DisjointSet_1);const direction4X=[-1,0],direction4Y=[0,-1],neighbours4=[null,null],direction8X=[-1,-1,0,1],direction8Y=[0,-1,-1,-1],neighbours8=[null,null,null,null];function fromMaskConnectedComponentLabelingAlgorithm(o,t={}){const{allowCorners:e=!1}=t;let n=4;e&&(n=8);let a,l,c;if(n===8)a=direction8X,l=direction8Y,c=neighbours8;else if(n===4)a=direction4X,l=direction4Y,c=neighbours4;else throw new RangeError(`unsupported neighbours count: ${n}`);const f=o.size,g=o.width,h=o.height,p=new Array(f),s=new Uint32Array(f),r=new DisjointSet$1;let u=1;for(let d=0;d<h;d++)for(let m=0;m<g;m++){const b=m+d*g;if(o.getBit(b)){let y=null;for(let w=0;w<c.length;w++){const x=m+a[w],_=d+l[w];if(x>=0&&_>=0&&x<g&&_<h){const v=x+_*g;let E=p[v];E?(c[w]=E,(!y||c[w].value<y.value)&&(y=c[w])):c[w]=null}}if(!y)p[b]=r.add(u++);else{p[b]=y;for(let w=0;w<c.length;w++)c[w]&&c[w]!==y&&r.union(y,c[w])}}}for(let d=0;d<h;d++)for(let m=0;m<g;m++){const b=m+d*g;o.getBit(b)&&(s[b]=r.find(p[b]).value)}return new RoiMap(o,s)}function fromMaxima(o={}){let{allowCorner:t=!0,onlyTop:e=!1,invert:n=!1}=o,a=this;a.checkProcessable("fromMaxima",{components:[1]});const l=1,c=2;let f=0,g=0,h=new Int16Array(a.size),p=new Int8Array(a.size),s=new Float32Array(a.size),r=1048575,u=new Uint16Array(r+1),d=new Uint16Array(r+1),m=0,b=0,y=new Uint16Array(r+1),w=new Uint16Array(r+1),x=0,_=0;for(v(a);m<b;){let S=u[m&r],T=d[m&r];I(S,T,c),m++}return new RoiMap(a,h);function v({maxima:S=!0}){for(let T=1;T<a.height-1;T++)for(let A=1;A<a.width-1;A++){let O=A+T*a.width;if(p[O]===0){let $=S?a.data[O]:-a.data[A+T*a.width];if(a.data[T*a.width+A-1]>$||a.data[T*a.width+A+1]>$||a.data[(T-1)*a.width+A]>$||a.data[(T+1)*a.width+A]>$||t&&(a.data[(T-1)*a.width+A-1]>$||a.data[(T-1)*a.width+A+1]>$||a.data[(T+1)*a.width+A-1]>$||a.data[(T+1)*a.width+A+1]>$))continue;h[O]=S?++f:--g,E(A,T)||(S?--f:++g)}}}function E(S,T){let A=b;x=0,_=1,y[0]=S,w[0]=T;let O=!0;for(;x<_;){let $=y[x&r],D=w[x&r];O&=I($,D,l),x++}if(!O){for(let $=0;$<_;$++){let D=y[$&r],F=w[$&r]*a.width+D;h[F]=0}b=A}return O}function I(S,T,A){let O=h[T*a.width+S],$=a.data[T*a.width+S];for(let D=T-1;D<=T+1;D++)for(let M=S-1;M<=S+1;M++){let F=D*a.width+M;if(p[F]===0)switch(p[F]=1,s[F]=a.data[F]-$,A){case l:if(s[F]===0){if(M===0||D===0||M===a.width-1||D===a.height-1)return!1;h[F]=O,y[_&r]=M,w[_&r]=D,_++}else{if(s[F]>0)return!1;e||(h[F]=O,u[b&r]=M,d[b&r]=D,b++)}break;case c:s[F]<=0&&(h[F]=O,u[b&r]=M,d[b&r]=D,b++);break;default:throw new Error("unreachable")}}return!0}}function fromPoints(o,t={}){let e=new Shape(t),n=new Int16Array(this.size),a=0,l=e.getPoints();for(let c=0;c<o.length;c++){a++;let f=o[c][0],g=o[c][1];for(let h=0;h<l.length;h++){let p=l[h][0],s=l[h][1];f+p>=0&&g+s>=0&&f+p<this.width&&g+s<this.height&&(n[f+p+(g+s)*this.width]=a)}}return new RoiMap(this,n)}function commonjsRequire(o){throw new Error('Could not dynamically require "'+o+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var priorityQueue={exports:{}};(function(o,t){(function(e){o.exports=e()})(function(){return function e(n,a,l){function c(h,p){if(!a[h]){if(!n[h]){var s=typeof commonjsRequire=="function"&&commonjsRequire;if(!p&&s)return s(h,!0);if(f)return f(h,!0);var r=new Error("Cannot find module '"+h+"'");throw r.code="MODULE_NOT_FOUND",r}var u=a[h]={exports:{}};n[h][0].call(u.exports,function(d){var m=n[h][1][d];return c(m||d)},u,u.exports,e,n,a,l)}return a[h].exports}for(var f=typeof commonjsRequire=="function"&&commonjsRequire,g=0;g<l.length;g++)c(l[g]);return c}({1:[function(e,n,a){var l,c,f,g,h,p=function(r,u){for(var d in u)s.call(u,d)&&(r[d]=u[d]);function m(){this.constructor=r}return m.prototype=u.prototype,r.prototype=new m,r.__super__=u.prototype,r},s={}.hasOwnProperty;l=e("./PriorityQueue/AbstractPriorityQueue"),c=e("./PriorityQueue/ArrayStrategy"),g=e("./PriorityQueue/BinaryHeapStrategy"),f=e("./PriorityQueue/BHeapStrategy"),h=function(r){p(u,r);function u(d){d||(d={}),d.strategy||(d.strategy=g),d.comparator||(d.comparator=function(m,b){return(m||0)-(b||0)}),u.__super__.constructor.call(this,d)}return u}(l),h.ArrayStrategy=c,h.BinaryHeapStrategy=g,h.BHeapStrategy=f,n.exports=h},{"./PriorityQueue/AbstractPriorityQueue":2,"./PriorityQueue/ArrayStrategy":3,"./PriorityQueue/BHeapStrategy":4,"./PriorityQueue/BinaryHeapStrategy":5}],2:[function(e,n,a){n.exports=function(){function l(c){var f;if((c!=null?c.strategy:void 0)==null)throw"Must pass options.strategy, a strategy";if((c!=null?c.comparator:void 0)==null)throw"Must pass options.comparator, a comparator";this.priv=new c.strategy(c),this.length=(c!=null&&(f=c.initialValues)!=null?f.length:void 0)||0}return l.prototype.queue=function(c){this.length++,this.priv.queue(c)},l.prototype.dequeue=function(c){if(!this.length)throw"Empty queue";return this.length--,this.priv.dequeue()},l.prototype.peek=function(c){if(!this.length)throw"Empty queue";return this.priv.peek()},l.prototype.clear=function(){return this.length=0,this.priv.clear()},l}()},{}],3:[function(e,n,a){var l;l=function(c,f,g){var h,p,s;for(p=0,h=c.length;p<h;)s=p+h>>>1,g(c[s],f)>=0?p=s+1:h=s;return p},n.exports=function(){function c(f){var g;this.options=f,this.comparator=this.options.comparator,this.data=((g=this.options.initialValues)!=null?g.slice(0):void 0)||[],this.data.sort(this.comparator).reverse()}return c.prototype.queue=function(f){var g;g=l(this.data,f,this.comparator),this.data.splice(g,0,f)},c.prototype.dequeue=function(){return this.data.pop()},c.prototype.peek=function(){return this.data[this.data.length-1]},c.prototype.clear=function(){this.data.length=0},c}()},{}],4:[function(e,n,a){n.exports=function(){function l(c){var f,g,h,p,s,r,u,d;for(this.comparator=(c!=null?c.comparator:void 0)||function(m,b){return m-b},this.pageSize=(c!=null?c.pageSize:void 0)||512,this.length=0,u=0;1<<u<this.pageSize;)u+=1;if(1<<u!==this.pageSize)throw"pageSize must be a power of two";for(this._shift=u,this._emptyMemoryPageTemplate=f=[],g=0,s=this.pageSize;0<=s?g<s:g>s;0<=s?++g:--g)f.push(null);if(this._memory=[],this._mask=this.pageSize-1,c.initialValues)for(r=c.initialValues,h=0,p=r.length;h<p;h++)d=r[h],this.queue(d)}return l.prototype.queue=function(c){this.length+=1,this._write(this.length,c),this._bubbleUp(this.length,c)},l.prototype.dequeue=function(){var c,f;return c=this._read(1),f=this._read(this.length),this.length-=1,this.length>0&&(this._write(1,f),this._bubbleDown(1,f)),c},l.prototype.peek=function(){return this._read(1)},l.prototype.clear=function(){this.length=0,this._memory.length=0},l.prototype._write=function(c,f){var g;for(g=c>>this._shift;g>=this._memory.length;)this._memory.push(this._emptyMemoryPageTemplate.slice(0));return this._memory[g][c&this._mask]=f},l.prototype._read=function(c){return this._memory[c>>this._shift][c&this._mask]},l.prototype._bubbleUp=function(c,f){var g,h,p,s;for(g=this.comparator;c>1&&(h=c&this._mask,c<this.pageSize||h>3?p=c&~this._mask|h>>1:h<2?(p=c-this.pageSize>>this._shift,p+=p&~(this._mask>>1),p|=this.pageSize>>1):p=c-2,s=this._read(p),!(g(s,f)<0));)this._write(p,f),this._write(c,s),c=p},l.prototype._bubbleDown=function(c,f){var g,h,p,s,r;for(r=this.comparator;c<this.length;)if(c>this._mask&&!(c&this._mask-1)?g=h=c+2:c&this.pageSize>>1?(g=(c&~this._mask)>>1,g|=c&this._mask>>1,g=g+1<<this._shift,h=g+1):(g=c+(c&this._mask),h=g+1),g!==h&&h<=this.length)if(p=this._read(g),s=this._read(h),r(p,f)<0&&r(p,s)<=0)this._write(g,f),this._write(c,p),c=g;else if(r(s,f)<0)this._write(h,f),this._write(c,s),c=h;else break;else if(g<=this.length)if(p=this._read(g),r(p,f)<0)this._write(g,f),this._write(c,p),c=g;else break;else break},l}()},{}],5:[function(e,n,a){n.exports=function(){function l(c){var f;this.comparator=(c!=null?c.comparator:void 0)||function(g,h){return g-h},this.length=0,this.data=((f=c.initialValues)!=null?f.slice(0):void 0)||[],this._heapify()}return l.prototype._heapify=function(){var c,f,g;if(this.data.length>0)for(c=f=1,g=this.data.length;1<=g?f<g:f>g;c=1<=g?++f:--f)this._bubbleUp(c)},l.prototype.queue=function(c){this.data.push(c),this._bubbleUp(this.data.length-1)},l.prototype.dequeue=function(){var c,f;return f=this.data[0],c=this.data.pop(),this.data.length>0&&(this.data[0]=c,this._bubbleDown(0)),f},l.prototype.peek=function(){return this.data[0]},l.prototype.clear=function(){this.length=0,this.data.length=0},l.prototype._bubbleUp=function(c){for(var f,g;c>0&&(f=c-1>>>1,this.comparator(this.data[c],this.data[f])<0);)g=this.data[f],this.data[f]=this.data[c],this.data[c]=g,c=f},l.prototype._bubbleDown=function(c){var f,g,h,p,s;for(f=this.data.length-1;g=(c<<1)+1,p=g+1,h=c,g<=f&&this.comparator(this.data[g],this.data[h])<0&&(h=g),p<=f&&this.comparator(this.data[p],this.data[h])<0&&(h=p),h!==c;)s=this.data[h],this.data[h]=this.data[c],this.data[c]=s,c=h},l}()},{}]},{},[1])(1)})})(priorityQueue);var priorityQueueExports=priorityQueue.exports,PriorityQueue=getDefaultExportFromCjs(priorityQueueExports);const dxs=[1,0,-1,0,1,1,-1,-1],dys=[0,1,0,-1,1,-1,1,-1];function fromWaterShed(o={}){let{points:t,mask:e,image:n,fillMaxValue:a=this.maxValue,invert:l=!1}=o,c=n||this;c.checkProcessable("fromWaterShed",{bitDepth:[8,16],components:1}),l=!l,t||(t=c.getLocalMaxima({invert:l,mask:e}));let f=l?0:1,g=new Int16Array(c.size),h=c.width,p=c.height,s=new PriorityQueue({comparator:(r,u)=>r[2]-u[2],strategy:PriorityQueue.BinaryHeapStrategy});for(let r=0;r<t.length;r++){let u=t[r][0]+t[r][1]*h;g[u]=r+1;let d=c.data[u];(l&&d<=a||!l&&d>=a)&&s.queue([t[r][0],t[r][1],d])}for(;s.length>0;){let r=s.dequeue(),u=r[0]+r[1]*h;for(let d=0;d<4;d++){let m=r[0]+dxs[d],b=r[1]+dys[d];if(m>=0&&b>=0&&m<h&&b<p){let y=m+b*h;if(!e||e.getBit(y)===f){let w=c.data[y];(l&&w<=a||!l&&w>=a)&&g[y]===0&&(g[y]=g[u],s.queue([r[0]+dxs[d],r[1]+dys[d],w]))}}}}return new RoiMap(c,g)}class RoiManager{constructor(t,e={}){this._image=t,this._options=e,this._options.label||(this._options.label="default"),this._layers={},this._painted=null}fromMaxima(t={}){let e=Object.assign({},this._options,t),n=fromMaxima.call(this._image,t);this._layers[e.label]=new RoiLayer(n,e)}fromPoints(t,e={}){let n=Object.assign({},this._options,e),a=fromPoints.call(this._image,t,e);return this._layers[n.label]=new RoiLayer(a,n),this}putMap(t,e={}){let n=new RoiMap(this._image,t),a=Object.assign({},this._options,e);return this._layers[a.label]=new RoiLayer(n,a),this}fromWaterShed(t={}){let e=Object.assign({},this._options,t),n=fromWaterShed.call(this._image,t);this._layers[e.label]=new RoiLayer(n,e)}fromMask(t,e={}){let n=Object.assign({},this._options,e),a=fromMask.call(this._image,t,e);return this._layers[n.label]=new RoiLayer(a,n),this}fromMaskConnectedComponentLabelingAlgorithm(t,e={}){let n=Object.assign({},this._options,e),a=fromMaskConnectedComponentLabelingAlgorithm.call(this._image,t,e);return this._layers[n.label]=new RoiLayer(a,n),this}getMap(t={}){let e=Object.assign({},this._options,t);return this._assertLayerWithLabel(e.label),this._layers[e.label].roiMap}rowsInfo(t={}){return this.getMap(t).rowsInfo()}colsInfo(t={}){return this.getMap(t).rowsInfo()}getRoiIds(t={}){let e=this.getRois(t);if(e){let n=new Array(e.length);for(let a=0;a<e.length;a++)n[a]=e[a].id;return n}throw new Error("ROIs not found")}getRois(t={}){let{label:e=this._options.label,positive:n=!0,negative:a=!0,minSurface:l=0,maxSurface:c=Number.POSITIVE_INFINITY,minWidth:f=0,maxWidth:g=Number.POSITIVE_INFINITY,minHeight:h=0,maxHeight:p=Number.POSITIVE_INFINITY,minRatio:s=0,maxRatio:r=Number.POSITIVE_INFINITY}=t;if(!this._layers[e])throw new Error(`this Roi layer (${e}) does not exist`);const u=this._layers[e].roi,d=[];for(const m of u)(m.id<0&&a||m.id>0&&n)&&m.surface>=l&&m.surface<=c&&m.width>=f&&m.width<=g&&m.height>=h&&m.height<=p&&m.ratio>=s&&m.ratio<=r&&d.push(m);return d}getRoi(t,e={}){const{label:n=this._options.label}=e;if(!this._layers[n])throw new Error(`this Roi layer (${n}) does not exist`);const a=this._layers[n].roi.find(l=>l.id===t);if(!a)throw new Error(`found no Roi with id ${t}`);return a}getMasks(t={}){let e=this.getRois(t),n=new Array(e.length);for(let a=0;a<e.length;a++)n[a]=e[a].getMask(t);return n}getAnalysisMasks(t={}){const{analysisProperty:e}=t;let n=`${e}Mask`,a=this.getRois(t);return a.length===0||!a[0][n]?[]:a.map(l=>l[n])}getData(t={}){let e=Object.assign({},this._options,t);return this._assertLayerWithLabel(e.label),this._layers[e.label].roiMap.data}paint(t={}){let{labelProperty:e,analysisProperty:n}=t;this._painted||(this._painted=this._image.rgba8());let a=this.getMasks(t);if(e){const l=this.getRois(t);t.labels=l.map(h=>deepValue(h,e));const c=Math.max(...t.labels);let f=!1,g=!1;if(e.includes("surface")?f=!0:/(?:perimeter|min|max|external|width|height|length)/.test(e)&&(g=!0),isFinite(c)){let h="";if(t.unit!=="pixel"&&t.pixelSize&&(g||f)){h=f?`${t.unit}^2`:t.unit;let p=f?"m^2":"m",s=f?t.pixelSize**2:t.pixelSize;const r=Qty.swiftConverter(p,h);t.labels=t.labels.map(u=>r(s*u))}c>50?t.labels=t.labels.map(p=>Math.round(p)+h):c>10?t.labels=t.labels.map(p=>p.toFixed(1)+h):t.labels=t.labels.map(p=>p.toFixed(2)+h)}t.labelsPosition=l.map(h=>[h.meanX,h.meanY])}if(this._painted.paintMasks(a,t),n){let l=this.getAnalysisMasks(t);this._painted.paintMasks(l,{color:t.analysisColor,alpha:t.analysisAlpha})}return this._painted}getMask(t={}){let e=new Image$1(this._image.width,this._image.height,{kind:"BINARY"}),n=this.getMasks(t);for(let a=0;a<n.length;a++){let l=n[a];for(let c=0;c<l.width;c++)for(let f=0;f<l.height;f++)l.getBitXY(c,f)&&e.setBitXY(c+l.position[0],f+l.position[1])}return e}resetPainted(t={}){const{image:e}=t;e?this._painted=this.image.rgba8():this._painted=this._image.rgba8()}mergeRoi(t={}){const e=this.getMap(t);return e.mergeRoi(t),this.putMap(e.data,t),this}mergeRois(t,e={}){if(!Array.isArray(t)||t.some(a=>!Number.isInteger(a)))throw new Error("Roi ids must be an array of integers");if(t.length<2)throw new Error("Roi ids must have at least two elements");if(new Set(t).size!==t.length)throw new Error("Roi ids must be all different");t.forEach(a=>this.getRoi(a));const n=this.getMap(e);return n.mergeRois(t),this.putMap(n.data,e),this}findCorrespondingRoi(t,e={}){let n=this.getRois(e),a=[];for(let l=0;l<n.length;l++){let c=n[l],f=c.minX,g=c.minY,h=c.points,p=Math.sign(c.id),s=correspondingRoisInformation(f,g,h,t,p);a.push(s)}return a}_assertLayerWithLabel(t){if(!this._layers[t])throw new Error(`no layer with label ${t}`)}}function correspondingRoisInformation(o,t,e,n,a){let l={id:[],surface:[],roiSurfaceCovered:[],same:0,opposite:0,total:0};for(let c=0;c<e.length;c++){let f=e[c],g=f[0],h=f[1],p=g+o+(h+t)*n.width,s=n.data[p];(s>0||s<0)&&(l.id.includes(s)?l.surface[l.id.indexOf(s)]+=1:(l.id.push(s),l.surface.push(1)))}for(let c=0;c<l.id.length;c++)Math.sign(l.id[c])===a?l.same+=l.surface[c]:l.opposite+=l.surface[c],l.roiSurfaceCovered[c]=l.surface[c]/e.length;return l.total=l.opposite+l.same,l}const objectToString=Object.prototype.toString;let Image$1=class xe{constructor(t,e,n,a){if(arguments.length===1?(a=t,{width:t,height:e,data:n}=a):n&&!n.length&&(a=n,{data:n}=a),t===void 0&&(t=1),e===void 0&&(e=1),a===void 0&&(a={}),typeof a!="object"||a===null)throw new TypeError("options must be an object");if(!Number.isInteger(t)||t<=0)throw new RangeError("width must be a positive integer");if(!Number.isInteger(e)||e<=0)throw new RangeError("height must be a positive integer");const{kind:l=RGBA}=a;if(typeof l!="string")throw new TypeError("kind must be a string");const c=getKind(l),f=Object.assign({},a);for(const m in c)f[m]===void 0&&(f[m]=c[m]);verifyKindDefinition(f);const{components:g,bitDepth:h,colorModel:p}=f,s=f.alpha+0,r=t*e,u=g+s,d=h===32?Number.MAX_VALUE:2**h-1;if(n===void 0)n=createPixelArray(r,g,s,u,h,d);else{const m=getTheoreticalPixelArraySize(r,u,h);if(n.length!==m)throw new RangeError(`incorrect data size: ${n.length}. Should be ${m}`)}this.width=t,this.height=e,this.data=n,this.size=r,this.components=g,this.alpha=s,this.bitDepth=h,this.maxValue=d,this.colorModel=p,this.channels=u,this.meta=a.meta||{},Object.defineProperty(this,"parent",{enumerable:!1,writable:!0,configurable:!0,value:a.parent||null}),this.position=a.position||[0,0],this.computed=null,this.sizes=[this.width,this.height],this.multiplierX=this.channels,this.multiplierY=this.channels*this.width,this.isClamped=this.bitDepth<32,this.borderSizes=[0,0]}get[Symbol.toStringTag](){return"IJSImage"}static isImage(t){return objectToString.call(t)==="[object IJSImage]"}static fromCanvas(t){const n=t.getContext("2d").getImageData(0,0,t.width,t.height);return new xe(n.width,n.height,n.data)}static createFrom(t,e){const n=getImageParameters(t);return Object.assign(n,{parent:t,position:[0,0]},e),new xe(n)}getRoiManager(t){return new RoiManager(this,t)}clone(){const t=this.data.slice();return new xe(this.width,this.height,t,this)}apply(t){for(let e=0;e<this.height;e++)for(let n=0;n<this.width;n++){let a=(e*this.width+n)*this.channels;t.call(this,a)}}};setValueMethods(Image$1),setBitMethods(Image$1),setExportMethods(Image$1),Image$1.prototype.checkProcessable=checkProcessable,Image$1.prototype.getRGBAData=getRGBAData,Image$1.load=load,Image$1.extendMethod=extendMethod,Image$1.extendProperty=extendProperty,extend$1(Image$1);var workerTemplate$1={},worker$1=function(){self.window=self;function o(){this._listeners={}}o.prototype.on=function(e,n){if(this._listeners[e])throw new RangeError("there is already a listener for "+e);if(typeof n!="function")throw new TypeError("callback argument must be a function");this._listeners[e]=n},o.prototype._send=function(e,n,a){a===void 0?a=[]:Array.isArray(a)||(a=[a]),self.postMessage({id:e,data:n},a)},o.prototype._trigger=function(e,n){if(!this._listeners[e])throw new Error("event "+e+" is not defined");this._listeners[e].apply(null,n)};var t=new o;self.onmessage=function(e){switch(e.data.action){case"exec":e.data.args.unshift(function(n,a){t._send(e.data.id,n,a)}),t._trigger(e.data.event,e.data.args);break;case"ping":t._send(e.data.id,"pong");break;default:throw new Error("unexpected action: "+e.data.action)}}},workerStr=worker$1.toString().split('"CODE";');workerTemplate$1.newWorkerURL=function o(t,e){var n=new Blob(["(",workerStr[0],"importScripts.apply(self, "+JSON.stringify(e)+`);
`,"(",t,")();",workerStr[1],")();"],{type:"application/javascript"});return URL.createObjectURL(n)};var workerTemplate=workerTemplate$1,CORES=navigator.hardwareConcurrency||1;function WorkerManager(o,t){if(typeof o!="string"&&typeof o!="function")throw new TypeError("func argument must be a function");if(t===void 0&&(t={}),typeof t!="object"||t===null)throw new TypeError("options argument must be an object");this._workerCode=o.toString(),t.maxWorkers===void 0||t.maxWorkers==="auto"?this._numWorkers=Math.min(CORES-1,1):t.maxWorkers>0?this._numWorkers=Math.min(t.maxWorkers,CORES):this._numWorkers=CORES,this._workers=new Map,this._timeout=t.timeout||0,this._terminateOnError=!!t.terminateOnError;var e=t.deps;typeof e=="string"&&(e=[e]),Array.isArray(e)||(e=void 0),this._id=0,this._terminated=!1,this._working=0,this._waiting=[],this._init(e)}WorkerManager.prototype._init=function(o){for(var t=workerTemplate.newWorkerURL(this._workerCode,o),e=0;e<this._numWorkers;e++){var n=new Worker(t);n.onmessage=this._onmessage.bind(this,n),n.onerror=this._onerror.bind(this,n),n.running=!1,n.id=e,this._workers.set(n,null)}URL.revokeObjectURL(t)},WorkerManager.prototype._onerror=function(o,t){if(!this._terminated){this._working--,o.running=!1;var e=this._workers.get(o);e&&e[1](t.message),this._workers.set(o,null),this._terminateOnError?this.terminate():this._exec()}},WorkerManager.prototype._onmessage=function(o,t){if(!this._terminated){this._working--,o.running=!1;var e=this._workers.get(o);e&&e[0](t.data.data),this._workers.set(o,null),this._exec()}},WorkerManager.prototype._exec=function(){for(var o of this._workers.keys()){if(this._working===this._numWorkers||this._waiting.length===0)return;if(!o.running)for(var t=0;t<this._waiting.length;t++){var e=this._waiting[t];if(!(typeof e[4]=="number"&&e[4]!==o.id)){this._waiting.splice(t,1),o.postMessage({action:"exec",event:e[0],args:e[1]},e[2]),o.running=!0,o.time=Date.now(),this._workers.set(o,e[3]),this._working++;break}}}},WorkerManager.prototype.terminate=function(){if(!this._terminated){for(var o of this._workers)o[0].terminate(),o[1]&&o[1][1](new Error("Terminated"));this._workers.clear(),this._waiting=[],this._working=0,this._terminated=!0}},WorkerManager.prototype.postAll=function(o,t){if(this._terminated)throw new Error("Cannot post (terminated)");var e=[];for(var n of this._workers.keys())e.push(this.post(o,t,[],n.id));return Promise.all(e)},WorkerManager.prototype.post=function(o,t,e,n){t===void 0&&(t=[]),e===void 0&&(e=[]),Array.isArray(t)||(t=[t]),Array.isArray(e)||(e=[e]);var a=this;return new Promise(function(l,c){if(a._terminated)throw new Error("Cannot post (terminated)");a._waiting.push([o,t,e,[l,c],n]),a._exec()})};var src=WorkerManager,WorkerManager$1=getDefaultExportFromCjs(src);const defaultOptions={regression:{kernelType:"polynomial",kernelOptions:{degree:2,constant:1}},threshold:.02,roi:{minSurface:100,positive:!1},sampling:20,include:[]};function run(o,t,e){t=Object.assign({},defaultOptions,t);const n=this.manager;return Array.isArray(o)?Promise.all(o.map(function(a){const l=runOnce(n,a,t);return typeof e=="function"&&l.then(e),l})):runOnce(n,o,t)}function runOnce(o,t,e){return o.post("data",[t,e]).then(function(n){for(let a in n)n[a]=new Image$1(n[a]);return n})}function work(){worker.on("data",function(o,t,e){t=new IJS(t);const n={},a=[],l=t.grey(),c=l.sobelFilter();u("sobel",c);const f=c.level().mask({threshold:e.threshold});u("mask",f);const g=c.getRoiManager();g.fromMask(f);const h=g.getMask(e.roi);u("realMask",h);const p=l.getPixelsGrid({sampling:e.sampling,mask:h}),s=t.getBackground(p.xyS,p.zS,e.regression);u("background",s);const r=t.subtract(s);n.result=r,a.push(r.data.buffer),o(n,a);function u(d,m){e.include.includes(d)&&(n[d]=m,a.push(m.data.buffer))}})}const background={run,work};function extend(o){o.extendMethod("background",background)}let Worker$1=class Le{constructor(){this._url=null,this._deps=[null]}checkUrl(){if(this._url===null)throw new Error("image worker must be initialized with an URL")}get url(){return this._url}set url(t){if(typeof t!="string")throw new TypeError("worker URL must be a string");this._url=t,this._deps[0]=t}static extendMethod(t,e){let n,a,l={};function c(...f){return n||(this.checkUrl(),a=this.url,n=new WorkerManager$1(e.work,{deps:a}),l.manager=n),e.run.call(l,...f)}c.reset=function(){n&&(n.terminate(),n=new WorkerManager$1(e.work,{deps:a}),l.manager=n)},Le.prototype[t]=c}};extend(Worker$1);var ort_min={exports:{}};/*!
* ONNX Runtime Web v1.15.0
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/(function(module,exports){(function(o,t){module.exports=t()})(self,()=>(()=>{var __webpack_modules__={8453:(o,t,e)=>{e.r(t),e.d(t,{InferenceSession:()=>u,Tensor:()=>s,env:()=>c,registerBackend:()=>l});const n={},a=[],l=(d,m,b)=>{if(!m||typeof m.init!="function"||typeof m.createSessionHandler!="function")throw new TypeError("not a valid backend");{const y=n[d];if(y===void 0)n[d]={backend:m,priority:b};else{if(y.priority>b)return;if(y.priority===b&&y.backend!==m)throw new Error(`cannot register backend "${d}" using priority ${b}`)}if(b>=0){const w=a.indexOf(d);w!==-1&&a.splice(w,1);for(let x=0;x<a.length;x++)if(n[a[x]].priority<=b)return void a.splice(x,0,d);a.push(d)}}},c=new class{constructor(){this.wasm={},this.webgl={},this.webgpu={},this.logLevelInternal="warning"}set logLevel(d){if(d!==void 0){if(typeof d!="string"||["verbose","info","warning","error","fatal"].indexOf(d)===-1)throw new Error(`Unsupported logging level: ${d}`);this.logLevelInternal=d}}get logLevel(){return this.logLevelInternal}},f=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),g=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let h=!1;class p{constructor(m,b,y){let w,x,_;if((()=>{if(!h){h=!0;const E=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",I=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";E&&(f.set("int64",BigInt64Array),g.set(BigInt64Array,"int64")),I&&(f.set("uint64",BigUint64Array),g.set(BigUint64Array,"uint64"))}})(),typeof m=="string")if(w=m,_=y,m==="string"){if(!Array.isArray(b))throw new TypeError("A string tensor's data must be a string array.");x=b}else{const E=f.get(m);if(E===void 0)throw new TypeError(`Unsupported tensor type: ${m}.`);if(Array.isArray(b))x=E.from(b);else{if(!(b instanceof E))throw new TypeError(`A ${w} tensor's data must be type of ${E}`);x=b}}else if(_=b,Array.isArray(m)){if(m.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const E=typeof m[0];if(E==="string")w="string",x=m;else{if(E!=="boolean")throw new TypeError(`Invalid element type of data array: ${E}.`);w="bool",x=Uint8Array.from(m)}}else{const E=g.get(m.constructor);if(E===void 0)throw new TypeError(`Unsupported type for tensor data: ${m.constructor}.`);w=E,x=m}if(_===void 0)_=[x.length];else if(!Array.isArray(_))throw new TypeError("A tensor's dims must be a number array");const v=(E=>{let I=1;for(let S=0;S<E.length;S++){const T=E[S];if(typeof T!="number"||!Number.isSafeInteger(T))throw new TypeError(`dims[${S}] must be an integer, got: ${T}`);if(T<0)throw new RangeError(`dims[${S}] must be a non-negative integer, got: ${T}`);I*=T}return I})(_);if(v!==x.length)throw new Error(`Tensor's size(${v}) does not match data length(${x.length}).`);this.dims=_,this.type=w,this.data=x,this.size=v}static bufferToTensor(m,b){if(m===void 0)throw new Error("Image buffer must be defined");if(b.height===void 0||b.width===void 0)throw new Error("Image height and width must be defined");if(b.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:y,width:w}=b,x=b.norm??{mean:255,bias:0};let _,v;_=typeof x.mean=="number"?[x.mean,x.mean,x.mean,x.mean]:[x.mean[0],x.mean[1],x.mean[2],x.mean[3]??255],v=typeof x.bias=="number"?[x.bias,x.bias,x.bias,x.bias]:[x.bias[0],x.bias[1],x.bias[2],x.bias[3]??0];const E=b.bitmapFormat!==void 0?b.bitmapFormat:"RGBA",I=b.tensorFormat!==void 0&&b.tensorFormat!==void 0?b.tensorFormat:"RGB",S=y*w,T=I==="RGBA"?new Float32Array(4*S):new Float32Array(3*S);let A=4,O=0,$=1,D=2,M=3,F=0,C=S,R=2*S,j=-1;E==="RGB"&&(A=3,O=0,$=1,D=2,M=-1),I==="RGBA"?j=3*S:I==="RBG"?(F=0,R=S,C=2*S):I==="BGR"&&(R=0,C=S,F=2*S);for(let G=0;G<S;G++,O+=A,D+=A,$+=A,M+=A)T[F++]=(m[O]+v[0])/_[0],T[C++]=(m[$]+v[1])/_[1],T[R++]=(m[D]+v[2])/_[2],j!==-1&&M!==-1&&(T[j++]=(m[M]+v[3])/_[3]);return new p("float32",T,I==="RGBA"?[1,4,y,w]:[1,3,y,w])}static async fromImage(m,b){const y=typeof HTMLImageElement<"u"&&m instanceof HTMLImageElement,w=typeof ImageData<"u"&&m instanceof ImageData,x=typeof ImageBitmap<"u"&&m instanceof ImageBitmap,_=typeof m=="string";let v,E=b??{};if(y){const I=document.createElement("canvas");I.width=m.width,I.height=m.height;const S=I.getContext("2d");if(S==null)throw new Error("Can not access image data");{let T=m.height,A=m.width;if(b!==void 0&&b.resizedHeight!==void 0&&b.resizedWidth!==void 0&&(T=b.resizedHeight,A=b.resizedWidth),b!==void 0){if(E=b,b.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");if(E.tensorFormat="RGBA",b.height!==void 0&&b.height!==T)throw new Error("Image input config height doesn't match HTMLImageElement height");if(E.height=T,b.width!==void 0&&b.width!==A)throw new Error("Image input config width doesn't match HTMLImageElement width");E.width=A}else E.tensorFormat="RGBA",E.height=T,E.width=A;S.drawImage(m,0,0),v=S.getImageData(0,0,A,T).data}}else{if(!w){if(x){if(b===void 0)throw new Error("Please provide image config with format for Imagebitmap");if(b.bitmapFormat!==void 0)throw new Error("Image input config format must be defined for ImageBitmap");const I=document.createElement("canvas").getContext("2d");if(I!=null){const S=m.height,T=m.width;if(I.drawImage(m,0,0,T,S),v=I.getImageData(0,0,T,S).data,b!==void 0){if(b.height!==void 0&&b.height!==S)throw new Error("Image input config height doesn't match ImageBitmap height");if(E.height=S,b.width!==void 0&&b.width!==T)throw new Error("Image input config width doesn't match ImageBitmap width");E.width=T}else E.height=S,E.width=T;return p.bufferToTensor(v,E)}throw new Error("Can not access image data")}if(_)return new Promise((I,S)=>{const T=document.createElement("canvas"),A=T.getContext("2d");if(!m||!A)return S();const O=new Image;O.crossOrigin="Anonymous",O.src=m,O.onload=()=>{T.width=O.width,T.height=O.height,A.drawImage(O,0,0,T.width,T.height);const $=A.getImageData(0,0,T.width,T.height);if(b!==void 0){if(b.height!==void 0&&b.height!==T.height)throw new Error("Image input config height doesn't match height");if(E.height=T.height,b.width!==void 0&&b.width!==T.width)throw new Error("Image input config width doesn't match width");E.width=T.width}else E.height=T.height,E.width=T.width;I(p.bufferToTensor($.data,E))}});throw new Error("Input data provided is not supported - aborted tensor creation")}{const I="RGBA";let S,T;if(b!==void 0&&b.resizedWidth!==void 0&&b.resizedHeight!==void 0?(S=b.resizedHeight,T=b.resizedWidth):(S=m.height,T=m.width),b!==void 0){if(E=b,b.bitmapFormat!==void 0&&b.bitmapFormat!==I)throw new Error("Image input config format must be RGBA for ImageData");E.bitmapFormat="RGBA"}else E.bitmapFormat="RGBA";if(E.height=S,E.width=T,b!==void 0){const A=document.createElement("canvas");A.width=T,A.height=S;const O=A.getContext("2d");if(O==null)throw new Error("Can not access image data");O.putImageData(m,0,0),v=O.getImageData(0,0,T,S).data}else v=m.data}}if(v!==void 0)return p.bufferToTensor(v,E);throw new Error("Input data provided is not supported - aborted tensor creation")}toDataURL(m){const b=document.createElement("canvas");b.width=this.dims[3],b.height=this.dims[2];const y=b.getContext("2d");if(y!=null){let w,x;(m==null?void 0:m.tensorLayout)!==void 0&&m.tensorLayout==="NHWC"?(w=this.dims[2],x=this.dims[3]):(w=this.dims[3],x=this.dims[2]);const _=(m==null?void 0:m.format)!==void 0?m.format:"RGB",v=m==null?void 0:m.norm;let E,I;v===void 0||v.mean===void 0?E=[255,255,255,255]:typeof v.mean=="number"?E=[v.mean,v.mean,v.mean,v.mean]:(E=[v.mean[0],v.mean[1],v.mean[2],0],v.mean[3]!==void 0&&(E[3]=v.mean[3])),v===void 0||v.bias===void 0?I=[0,0,0,0]:typeof v.bias=="number"?I=[v.bias,v.bias,v.bias,v.bias]:(I=[v.bias[0],v.bias[1],v.bias[2],0],v.bias[3]!==void 0&&(I[3]=v.bias[3]));const S=x*w;let T=0,A=S,O=2*S,$=-1;_==="RGBA"?(T=0,A=S,O=2*S,$=3*S):_==="RGB"?(T=0,A=S,O=2*S):_==="RBG"&&(T=0,O=S,A=2*S);for(let D=0;D<x;D++)for(let M=0;M<w;M++){const F=(this.data[T++]-I[0])*E[0],C=(this.data[A++]-I[1])*E[1],R=(this.data[O++]-I[2])*E[2],j=$===-1?255:(this.data[$++]-I[3])*E[3];y.fillStyle="rgba("+F+","+C+","+R+","+j+")",y.fillRect(M,D,1,1)}return b.toDataURL()}throw new Error("Can not access image data")}toImageData(m){const b=document.createElement("canvas").getContext("2d");let y;if(b==null)throw new Error("Can not access image data");{let w,x,_;(m==null?void 0:m.tensorLayout)!==void 0&&m.tensorLayout==="NHWC"?(w=this.dims[2],x=this.dims[1],_=this.dims[3]):(w=this.dims[3],x=this.dims[2],_=this.dims[1]);const v=m!==void 0&&m.format!==void 0?m.format:"RGB",E=m==null?void 0:m.norm;let I,S;E===void 0||E.mean===void 0?I=[255,255,255,255]:typeof E.mean=="number"?I=[E.mean,E.mean,E.mean,E.mean]:(I=[E.mean[0],E.mean[1],E.mean[2],255],E.mean[3]!==void 0&&(I[3]=E.mean[3])),E===void 0||E.bias===void 0?S=[0,0,0,0]:typeof E.bias=="number"?S=[E.bias,E.bias,E.bias,E.bias]:(S=[E.bias[0],E.bias[1],E.bias[2],0],E.bias[3]!==void 0&&(S[3]=E.bias[3]));const T=x*w;if(m!==void 0){if(m.height!==void 0&&m.height!==x)throw new Error("Image output config height doesn't match tensor height");if(m.width!==void 0&&m.width!==w)throw new Error("Image output config width doesn't match tensor width");if(m.format!==void 0&&_===4&&m.format!=="RGBA"||_===3&&m.format!=="RGB"&&m.format!=="BGR")throw new Error("Tensor format doesn't match input tensor dims")}const A=4;let O=0,$=1,D=2,M=3,F=0,C=T,R=2*T,j=-1;v==="RGBA"?(F=0,C=T,R=2*T,j=3*T):v==="RGB"?(F=0,C=T,R=2*T):v==="RBG"&&(F=0,R=T,C=2*T),y=b.createImageData(w,x);for(let G=0;G<x*w;O+=A,$+=A,D+=A,M+=A,G++)y.data[O]=(this.data[F++]-S[0])*I[0],y.data[$]=(this.data[C++]-S[1])*I[1],y.data[D]=(this.data[R++]-S[2])*I[2],y.data[M]=j===-1?255:(this.data[j++]-S[3])*I[3]}return y}reshape(m){return new p(this.type,this.data,m)}}const s=p;class r{constructor(m){this.handler=m}async run(m,b,y){const w={};let x={};if(typeof m!="object"||m===null||m instanceof s||Array.isArray(m))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let _=!0;if(typeof b=="object"){if(b===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(b instanceof s)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(b)){if(b.length===0)throw new TypeError("'fetches' cannot be an empty array.");_=!1;for(const I of b){if(typeof I!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(I)===-1)throw new RangeError(`'fetches' contains invalid output name: ${I}.`);w[I]=null}if(typeof y=="object"&&y!==null)x=y;else if(y!==void 0)throw new TypeError("'options' must be an object.")}else{let I=!1;const S=Object.getOwnPropertyNames(b);for(const T of this.outputNames)if(S.indexOf(T)!==-1){const A=b[T];(A===null||A instanceof s)&&(I=!0,_=!1,w[T]=A)}if(I){if(typeof y=="object"&&y!==null)x=y;else if(y!==void 0)throw new TypeError("'options' must be an object.")}else x=b}}else if(b!==void 0)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const I of this.inputNames)if(m[I]===void 0)throw new Error(`input '${I}' is missing in 'feeds'.`);if(_)for(const I of this.outputNames)w[I]=null;const v=await this.handler.run(m,w,x),E={};for(const I in v)Object.hasOwnProperty.call(v,I)&&(E[I]=new s(v[I].type,v[I].data,v[I].dims));return E}static async create(m,b,y,w){let x,_={};if(typeof m=="string"){if(x=m,typeof b=="object"&&b!==null)_=b;else if(b!==void 0)throw new TypeError("'options' must be an object.")}else if(m instanceof Uint8Array){if(x=m,typeof b=="object"&&b!==null)_=b;else if(b!==void 0)throw new TypeError("'options' must be an object.")}else{if(!(m instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&m instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const S=m;let T=0,A=m.byteLength;if(typeof b=="object"&&b!==null)_=b;else if(typeof b=="number"){if(T=b,!Number.isSafeInteger(T))throw new RangeError("'byteOffset' must be an integer.");if(T<0||T>=S.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${S.byteLength}).`);if(A=m.byteLength-T,typeof y=="number"){if(A=y,!Number.isSafeInteger(A))throw new RangeError("'byteLength' must be an integer.");if(A<=0||T+A>S.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${S.byteLength-T}].`);if(typeof w=="object"&&w!==null)_=w;else if(w!==void 0)throw new TypeError("'options' must be an object.")}else if(y!==void 0)throw new TypeError("'byteLength' must be a number.")}else if(b!==void 0)throw new TypeError("'options' must be an object.");x=new Uint8Array(S,T,A)}}const v=(_.executionProviders||[]).map(S=>typeof S=="string"?S:S.name),E=await(async S=>{const T=S.length===0?a:S,A=[];for(const O of T){const $=n[O];if($){if($.initialized)return $.backend;if($.aborted)continue;const D=!!$.initPromise;try{return D||($.initPromise=$.backend.init()),await $.initPromise,$.initialized=!0,$.backend}catch(M){D||A.push({name:O,err:M}),$.aborted=!0}finally{delete $.initPromise}}}throw new Error(`no available backend found. ERR: ${A.map(O=>`[${O.name}] ${O.err}`).join(", ")}`)})(v),I=await E.createSessionHandler(x,_);return new r(I)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}const u=r},5716:(o,t,e)=>{t.R=void 0;const n=e(6027),a=e(1723);t.R=new class{async init(){}async createSessionHandler(l,c){const f=new n.Session(c);return await f.loadModel(l),new a.OnnxjsSessionHandler(f)}}},2818:(o,t,e)=>{t.c8=t.rX=void 0;const n=e(8453),a=e(5381),l=e(9544),c=e(6640);t.rX=()=>{if((typeof n.env.wasm.initTimeout!="number"||n.env.wasm.initTimeout<0)&&(n.env.wasm.initTimeout=0),typeof n.env.wasm.simd!="boolean"&&(n.env.wasm.simd=!0),typeof n.env.wasm.proxy!="boolean"&&(n.env.wasm.proxy=!1),typeof n.env.wasm.numThreads!="number"||!Number.isInteger(n.env.wasm.numThreads)||n.env.wasm.numThreads<=0){const f=typeof navigator>"u"?(0,a.cpus)().length:navigator.hardwareConcurrency;n.env.wasm.numThreads=Math.min(4,Math.ceil((f||1)/2))}},t.c8=new class{async init(){(0,t.rX)(),await(0,l.initWasm)()}async createSessionHandler(f,g){const h=new c.OnnxruntimeWebAssemblySessionHandler;return await h.loadModel(f,g),Promise.resolve(h)}}},1057:function(o,t,e){var n=this&&this.__createBinding||(Object.create?function(c,f,g,h){h===void 0&&(h=g);var p=Object.getOwnPropertyDescriptor(f,g);p&&!("get"in p?!f.__esModule:p.writable||p.configurable)||(p={enumerable:!0,get:function(){return f[g]}}),Object.defineProperty(c,h,p)}:function(c,f,g,h){h===void 0&&(h=g),c[h]=f[g]}),a=this&&this.__exportStar||function(c,f){for(var g in c)g==="default"||Object.prototype.hasOwnProperty.call(f,g)||n(f,c,g)};Object.defineProperty(t,"__esModule",{value:!0}),a(e(8453),t);const l=e(8453);{const c=e(5716).R;(0,l.registerBackend)("webgl",c,-10)}{const c=e(2818).c8;(0,l.registerBackend)("cpu",c,10),(0,l.registerBackend)("wasm",c,10),(0,l.registerBackend)("xnnpack",c,9)}},4910:(o,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createAttributeWithCacheKey=void 0;class e{constructor(a){Object.assign(this,a)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(a=>`${this[a]}`).join(";")),this._cacheKey}}t.createAttributeWithCacheKey=n=>new e(n)},6874:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Attribute=void 0;const n=e(1446),a=e(1287),l=e(9240),c=e(7273);var f=a.onnxruntime.experimental.fbs;class g{constructor(p){if(this._attributes=new Map,p!=null){for(const s of p)s instanceof n.onnx.AttributeProto?this._attributes.set(s.name,[g.getValue(s),g.getType(s)]):s instanceof f.Attribute&&this._attributes.set(s.name(),[g.getValue(s),g.getType(s)]);if(this._attributes.size<p.length)throw new Error("duplicated attribute names")}}set(p,s,r){this._attributes.set(p,[r,s])}delete(p){this._attributes.delete(p)}getFloat(p,s){return this.get(p,"float",s)}getInt(p,s){return this.get(p,"int",s)}getString(p,s){return this.get(p,"string",s)}getTensor(p,s){return this.get(p,"tensor",s)}getFloats(p,s){return this.get(p,"floats",s)}getInts(p,s){return this.get(p,"ints",s)}getStrings(p,s){return this.get(p,"strings",s)}getTensors(p,s){return this.get(p,"tensors",s)}get(p,s,r){const u=this._attributes.get(p);if(u===void 0){if(r!==void 0)return r;throw new Error(`required attribute not found: ${p}`)}if(u[1]!==s)throw new Error(`type mismatch: expected ${s} but got ${u[1]}`);return u[0]}static getType(p){const s=p instanceof n.onnx.AttributeProto?p.type:p.type();switch(s){case n.onnx.AttributeProto.AttributeType.FLOAT:return"float";case n.onnx.AttributeProto.AttributeType.INT:return"int";case n.onnx.AttributeProto.AttributeType.STRING:return"string";case n.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case n.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case n.onnx.AttributeProto.AttributeType.INTS:return"ints";case n.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case n.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${n.onnx.AttributeProto.AttributeType[s]}`)}}static getValue(p){const s=p instanceof n.onnx.AttributeProto?p.type:p.type();if(s===n.onnx.AttributeProto.AttributeType.GRAPH||s===n.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const r=this.getValueNoCheck(p);if(s===n.onnx.AttributeProto.AttributeType.INT&&c.LongUtil.isLong(r))return c.LongUtil.longToNumber(r);if(s===n.onnx.AttributeProto.AttributeType.INTS){const u=r,d=new Array(u.length);for(let m=0;m<u.length;m++){const b=u[m];d[m]=c.LongUtil.longToNumber(b)}return d}if(s===n.onnx.AttributeProto.AttributeType.TENSOR)return p instanceof n.onnx.AttributeProto?l.Tensor.fromProto(r):l.Tensor.fromOrtTensor(r);if(s===n.onnx.AttributeProto.AttributeType.TENSORS){if(p instanceof n.onnx.AttributeProto)return r.map(u=>l.Tensor.fromProto(u));if(p instanceof f.Attribute)return r.map(u=>l.Tensor.fromOrtTensor(u))}if(s===n.onnx.AttributeProto.AttributeType.STRING&&p instanceof n.onnx.AttributeProto){const u=r;return(0,c.decodeUtf8String)(u)}return s===n.onnx.AttributeProto.AttributeType.STRINGS&&p instanceof n.onnx.AttributeProto?r.map(c.decodeUtf8String):r}static getValueNoCheck(p){return p instanceof n.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(p):this.getValueNoCheckFromOrtFormat(p)}static getValueNoCheckFromOnnxFormat(p){switch(p.type){case n.onnx.AttributeProto.AttributeType.FLOAT:return p.f;case n.onnx.AttributeProto.AttributeType.INT:return p.i;case n.onnx.AttributeProto.AttributeType.STRING:return p.s;case n.onnx.AttributeProto.AttributeType.TENSOR:return p.t;case n.onnx.AttributeProto.AttributeType.GRAPH:return p.g;case n.onnx.AttributeProto.AttributeType.FLOATS:return p.floats;case n.onnx.AttributeProto.AttributeType.INTS:return p.ints;case n.onnx.AttributeProto.AttributeType.STRINGS:return p.strings;case n.onnx.AttributeProto.AttributeType.TENSORS:return p.tensors;case n.onnx.AttributeProto.AttributeType.GRAPHS:return p.graphs;default:throw new Error(`unsupported attribute type: ${n.onnx.AttributeProto.AttributeType[p.type]}`)}}static getValueNoCheckFromOrtFormat(p){switch(p.type()){case f.AttributeType.FLOAT:return p.f();case f.AttributeType.INT:return p.i();case f.AttributeType.STRING:return p.s();case f.AttributeType.TENSOR:return p.t();case f.AttributeType.GRAPH:return p.g();case f.AttributeType.FLOATS:return p.floatsArray();case f.AttributeType.INTS:{const s=[];for(let r=0;r<p.intsLength();r++)s.push(p.ints(r));return s}case f.AttributeType.STRINGS:{const s=[];for(let r=0;r<p.stringsLength();r++)s.push(p.strings(r));return s}case f.AttributeType.TENSORS:{const s=[];for(let r=0;r<p.tensorsLength();r++)s.push(p.tensors(r));return s}default:throw new Error(`unsupported attribute type: ${f.AttributeType[p.type()]}`)}}}t.Attribute=g},1975:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.resolveBackend=t.backend=void 0;const n=e(4418),a=new Map;async function l(c){const f=t.backend;if(f[c]!==void 0&&function(g){const h=g;return"initialize"in h&&typeof h.initialize=="function"&&"createSessionHandler"in h&&typeof h.createSessionHandler=="function"&&"dispose"in h&&typeof h.dispose=="function"}(f[c])){const g=f[c];let h=g.initialize();if(typeof h=="object"&&"then"in h&&(h=await h),h)return a.set(c,g),g}}t.backend={webgl:new n.WebGLBackend},t.resolveBackend=async function c(f){if(!f)return c(["webgl"]);{const g=typeof f=="string"?[f]:f;for(const h of g){const p=a.get(h);if(p)return p;const s=await l(h);if(s)return s}}throw new Error("no available backend to use")}},4418:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLBackend=void 0;const n=e(8453),a=e(1315),l=e(2171),c=e(3389);t.WebGLBackend=class{get contextId(){return n.env.webgl.contextId}set contextId(f){n.env.webgl.contextId=f}get matmulMaxBatchSize(){return n.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(f){n.env.webgl.matmulMaxBatchSize=f}get textureCacheMode(){return n.env.webgl.textureCacheMode}set textureCacheMode(f){n.env.webgl.textureCacheMode=f}get pack(){return n.env.webgl.pack}set pack(f){n.env.webgl.pack=f}get async(){return n.env.webgl.async}set async(f){n.env.webgl.async=f}initialize(){try{return this.glContext=(0,c.createWebGLContext)(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),a.Logger.setWithEnv(n.env),a.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(f){return a.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${f}`),!1}}createSessionHandler(f){return new l.WebGLSessionHandler(this,f)}dispose(){this.glContext.dispose()}}},6859:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.CoordsGlslLib=void 0;const n=e(7273),a=e(1997),l=e(6757),c=e(7618),f=e(432);class g extends a.GlslLib{constructor(p){super(p)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new a.GlslLibRoutine(`
      vec2 offsetToCoords(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){return{coordsToOffset:new a.GlslLibRoutine(`
      int coordsToOffset(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){const p=this.context.outputTextureLayout;return p.isPacked?this.getPackedOutputSamplingSnippet(p):this.getUnpackedOutputSamplingSnippet(p)}getPackedOutputSamplingSnippet(p){const s=p.unpackedShape,r=[p.width,p.height],u={},d="getOutputCoords";switch(s.length){case 0:u[d]=this.getOutputScalarCoords();break;case 1:u[d]=this.getOutputPacked1DCoords(s,r);break;case 2:u[d]=this.getOutputPacked2DCoords(s,r);break;case 3:u[d]=this.getOutputPacked3DCoords(s,r);break;default:u[d]=this.getOutputPackedNDCoords(s,r)}const m=`
      void setOutput(vec4 val) {
        ${(0,l.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;return u.floatTextureSetRGBA=new a.GlslLibRoutine(m),u}getUnpackedOutputSamplingSnippet(p){const s=p.unpackedShape,r=[p.width,p.height],u={},d="getOutputCoords";switch(s.length){case 0:u[d]=this.getOutputScalarCoords();break;case 1:u[d]=this.getOutputUnpacked1DCoords(s,r);break;case 2:u[d]=this.getOutputUnpacked2DCoords(s,r);break;case 3:u[d]=this.getOutputUnpacked3DCoords(s,r);break;case 4:u[d]=this.getOutputUnpacked4DCoords(s,r);break;case 5:u[d]=this.getOutputUnpacked5DCoords(s,r);break;case 6:u[d]=this.getOutputUnpacked6DCoords(s,r);break;default:throw new Error(`Unsupported output dimensionality: ${s.length}`)}const m=`
        void setOutput(float val) {
          ${(0,l.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;return u.floatTextureSetR=new a.GlslLibRoutine(m),u}getOutputScalarCoords(){return new a.GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(p,s){const r=s;let u="";return r[0]===1?(u=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${r[1]}.0);
          }
        `,new a.GlslLibRoutine(u)):r[1]===1?(u=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${r[0]}.0);
          }
        `,new a.GlslLibRoutine(u)):(u=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${r[0]}, ${r[1]}));
          return 2 * (resTexRC.y * ${r[0]} + resTexRC.x);
        }
      `,new a.GlslLibRoutine(u))}getOutputPacked2DCoords(p,s){let r="";if(n.ArrayUtil.arraysEqual(p,s))return r=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${s[0]}, ${s[1]}));
        }
      `,new a.GlslLibRoutine(r);const u=s,d=Math.ceil(p[1]/2);return r=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${u[0]}, ${u[1]}));

          int index = resTexRC.y * ${u[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${d}) * 2;
          int c = 2 * (index / ${d});

          return ivec2(r, c);
        }
      `,new a.GlslLibRoutine(r)}getOutputPacked3DCoords(p,s){const r=[s[0],s[1]],u=Math.ceil(p[2]/2),d=u*Math.ceil(p[1]/2),m=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;

          int b = index / ${d};
          index -= b * ${d};

          // reverse r and c order for packed texture
          int r = imod(index, ${u}) * 2;
          int c = 2 * (index / ${u});

          return ivec3(b, r, c);
        }
      `;return new a.GlslLibRoutine(m)}getOutputPackedNDCoords(p,s){const r=[s[0],s[1]],u=Math.ceil(p[p.length-1]/2),d=u*Math.ceil(p[p.length-2]/2);let m=d,b="",y="b, r, c";for(let x=2;x<p.length-1;x++)m*=p[p.length-x-1],b=`
      int b${x} = index / ${m};
      index -= b${x} * ${m};
    `+b,y=`b${x}, `+y;const w=`
      ivec${p.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${r[0]}, ${r[1]}));
        int index = resTexRC.y * ${r[0]} + resTexRC.x;

        ${b}

        int b = index / ${d};
        index -= b * ${d};

        // reverse r and c order for packed texture
        int r = imod(index, ${u}) * 2;
        int c = 2 * (index / ${u});

        return ivec${p.length}(${y});
      }
    `;return new a.GlslLibRoutine(w)}getOutputUnpacked1DCoords(p,s){const r=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${s[0]}, ${s[1]}));
          return resTexRC.y * ${s[0]} + resTexRC.x;
        }
      `;return new a.GlslLibRoutine(r)}getOutputUnpacked2DCoords(p,s){const r=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${s[0]}, ${s[1]}));
          int index = resTexRC.y * ${s[0]} + resTexRC.x;
          int r = index / ${p[1]};
          int c = index - r * ${p[1]};
          return ivec2(r, c);
        }
      `;return new a.GlslLibRoutine(r)}getOutputUnpacked3DCoords(p,s){let r="";const u=p.length;let d=null;u<2&&(d=[]),d=new Array(u-1),d[u-2]=p[u-1];for(let y=u-3;y>=0;--y)d[y]=d[y+1]*p[y+1];const m=["r","c","d"],b=d.map((y,w)=>`int ${m[w]} = index / ${y}; ${w===d.length-1?`int ${m[w+1]} = index - ${m[w]} * ${y}`:`index -= ${m[w]} * ${y}`};`).join("");return r=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${s[0]}, ${s[1]}));
          int index = resTexRC.y * ${s[0]} + resTexRC.x;
          ${b}
          return ivec3(r, c, d);
        }
      `,new a.GlslLibRoutine(r)}getOutputUnpacked4DCoords(p,s){let r="";const u=p.length;let d=null;u<2&&(d=[]),d=new Array(u-1),d[u-2]=p[u-1];for(let y=u-3;y>=0;--y)d[y]=d[y+1]*p[y+1];const m=["r","c","d","d2"],b=d.map((y,w)=>`int ${m[w]} = index / ${y}; ${w===d.length-1?`int ${m[w+1]} = index - ${m[w]} * ${y}`:`index -= ${m[w]} * ${y}`};`).join("");return r=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${s[0]}, ${s[1]}));
          int index = resTexRC.y * ${s[0]} + resTexRC.x;
          ${b}
          return ivec4(r, c, d, d2);
        }
      `,new a.GlslLibRoutine(r)}getOutputUnpacked5DCoords(p,s){let r="";const u=p.length;let d=null;u<2&&(d=[]),d=new Array(u-1),d[u-2]=p[u-1];for(let y=u-3;y>=0;--y)d[y]=d[y+1]*p[y+1];const m=["r","c","d","d2","d3"],b=d.map((y,w)=>`int ${m[w]} = index / ${y}; ${w===d.length-1?`int ${m[w+1]} = index - ${m[w]} * ${y}`:`index -= ${m[w]} * ${y}`};`).join("");return r=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${s[0]}, ${s[1]}));
          int index = resTexRC.y * ${s[0]} + resTexRC.x;
          ${b}
          return ivec5(r, c, d, d2, d3);
        }
      `,new a.GlslLibRoutine(r)}getOutputUnpacked6DCoords(p,s){let r="";const u=p.length;let d=null;u<2&&(d=[]),d=new Array(u-1),d[u-2]=p[u-1];for(let y=u-3;y>=0;--y)d[y]=d[y+1]*p[y+1];const m=["r","c","d","d2","d3","d4"],b=d.map((y,w)=>`int ${m[w]} = index / ${y}; ${w===d.length-1?`int ${m[w+1]} = index - ${m[w]} * ${y}`:`index -= ${m[w]} * ${y}`};`).join("");return r=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${s[0]}, ${s[1]}));
         int index = resTexRC.y * ${s[0]} + resTexRC.x;
         ${b}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new a.GlslLibRoutine(r)}getCommonUtilFuncs(){const p={};let s="uvFromFlat";p[s]=new a.GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),s="packedUVfrom1D",p[s]=new a.GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),s="packedUVfrom2D",p[s]=new a.GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),s="packedUVfrom3D",p[s]=new a.GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),s="sampleTexture";const r=(0,l.getGlsl)(this.context.glContext.version);return p[s]=new a.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${r.texture2D}(textureSampler, uv).r;
        }`),p}getInputsSamplingSnippets(){const p={},s=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((r,u)=>{const d=this.context.inputTextureLayouts[u],m=(0,f.generateShaderFuncNameFromInputSamplerName)(r);d.isPacked?p[m]=this.getPackedSamplerFromInput(m,r,d):p[m]=this.getUnpackedSamplerFromInput(m,r,d);const b=(0,f.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(r);d.unpackedShape.length<=s.unpackedShape.length&&(d.isPacked?p[b]=this.getPackedSamplerAtOutputCoords(b,d,s,r):p[b]=this.getUnpackedSamplerAtOutputCoords(b,d,s,r))}),p}getPackedSamplerAtOutputCoords(p,s,r,u){const d=s.unpackedShape,m=r.unpackedShape,b=u,y=(0,f.generateShaderFuncNameFromInputSamplerName)(b),w=d.length,x=m.length,_=n.BroadcastUtil.getBroadcastDims(d,m),v=(0,f.getCoordsDataType)(x),E=x-w;let I;const S=(0,f.getGlChannels)();I=w===0?"":x<2&&_.length>=1?"coords = 0;":_.map(M=>`coords.${S[M+E]} = 0;`).join(`
`);let T="";T=x<2&&w>0?"coords":d.map((M,F)=>`coords.${S[F+E]}`).join(", ");let A="return outputValue;";const O=n.ShapeUtil.size(d)===1,$=n.ShapeUtil.size(m)===1;if(w!==1||O||$){if(O&&!$)A=x===1?`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:`
          return vec4(outputValue.x);
        `;else if(_.length){const M=w-2,F=w-1;_.indexOf(M)>-1&&_.indexOf(F)>-1?A="return vec4(outputValue.x);":_.indexOf(M)>-1?A="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":_.indexOf(F)>-1&&(A="return vec4(outputValue.xx, outputValue.zz);")}}else A=`
        return vec4(outputValue.xy, outputValue.xy);
      `;const D=`
      vec4 ${p}() {
        ${v} coords = getOutputCoords();
        
        int lastDim = coords.${S[x-1]};
        coords.${S[x-1]} = coords.${S[x-2]};
        coords.${S[x-2]} = lastDim;
      
        ${I}
        vec4 outputValue = ${y}(${T});
        ${A}
      }
    `;return new a.GlslLibRoutine(D,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(p,s,r,u){const d=[r.width,r.height],m=[s.width,s.height],b=s.unpackedShape.length,y=r.unpackedShape.length,w=s.unpackedShape,x=r.unpackedShape,_=(0,f.generateShaderFuncNameFromInputSamplerName)(u);if(b===y&&n.ArrayUtil.arraysEqual(m,d)){const $=`
          float ${p}() {
            return sampleTexture(${u}, TexCoords);
          }
        `;return new a.GlslLibRoutine($,["coordinates.sampleTexture"])}const v=(0,f.getCoordsDataType)(y),E=n.BroadcastUtil.getBroadcastDims(w,x),I=y-b;let S;const T=(0,f.getGlChannels)();S=b===0?"":y<2&&E.length>=1?"coords = 0;":E.map($=>`coords.${T[$+I]} = 0;`).join(`
`);let A="";A=y<2&&b>0?"coords":s.unpackedShape.map(($,D)=>`coords.${T[D+I]}`).join(", ");const O=`
        float ${p}() {
          ${v} coords = getOutputCoords();
          ${S}
          return ${_}(${A});
        }
      `;return new a.GlslLibRoutine(O,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(p,s,r){switch(r.unpackedShape.length){case 0:return this.getPackedSamplerScalar(p,s);case 1:return this.getPackedSampler1D(p,s,r);case 2:return this.getPackedSampler2D(p,s,r);case 3:return this.getPackedSampler3D(p,s,r);default:return this.getPackedSamplerND(p,s,r)}}getUnpackedSamplerFromInput(p,s,r){const u=r.unpackedShape;switch(u.length){case 0:return this.getUnpackedSamplerScalar(p,s,r);case 1:return this.getUnpackedSampler1D(p,s,r);case 2:return this.getUnpackedSampler2D(p,s,r);case 3:return this.getUnpackedSampler3D(p,s,r);case 4:return this.getUnpackedSampler4D(p,s,r);case 5:return this.getUnpackedSampler5D(p,s,r);case 6:return this.getUnpackedSampler6D(p,s,r);default:throw new Error(`Unsupported dimension ${u.length}-D`)}}getPackedSamplerScalar(p,s){const r=`
          vec4 ${p}() {
            return ${(0,l.getGlsl)(this.context.glContext.version).texture2D}(${s}, halfCR);
          }
        `;return new a.GlslLibRoutine(r)}getPackedSampler1D(p,s,r){const u=[r.width,r.height],d=[u[1],u[0]],m=(0,l.getGlsl)(this.context.glContext.version),b=`vec4 ${p}(int index) {
      vec2 uv = packedUVfrom1D(
      ${d[0]}, ${d[1]}, index);
      return ${m.texture2D}(${s}, uv);
    }`;return new a.GlslLibRoutine(b,["coordinates.packedUVfrom1D"])}getPackedSampler2D(p,s,r){const u=r.unpackedShape,d=[r.width,r.height],m=(0,l.getGlsl)(this.context.glContext.version),b=d[0],y=d[1];if(d!=null&&n.ArrayUtil.arraysEqual(u,d)){const v=`vec4 ${p}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${y}.0, ${b}.0);
        return ${m.texture2D}(${s}, uv);
      }`;return new a.GlslLibRoutine(v)}const w=d,x=Math.ceil(u[1]/2),_=`vec4 ${p}(int row, int col) {
      vec2 uv = packedUVfrom2D(${w[1]}, ${w[0]}, ${x}, row, col);
      return ${m.texture2D}(${s}, uv);
    }`;return new a.GlslLibRoutine(_,["coordinates.packedUVfrom2D"])}getPackedSampler3D(p,s,r){const u=r.unpackedShape,d=[r.width,r.height],m=[d[0],d[1]],b=(0,l.getGlsl)(this.context.glContext.version);if(u[0]===1){const v=u.slice(1),E=[1,2],I=(0,f.squeezeInputShape)(u,v),S=["b","row","col"],T=JSON.parse(JSON.stringify(r));T.unpackedShape=I;const A=this.getPackedSamplerFromInput(p,s,T),O=`${A.routineBody}
      vec4 ${p}(int b, int row, int col) {
        return ${p}(${(0,f.getSqueezedParams)(S,E)});
      } `;return new a.GlslLibRoutine(O,A.dependencies)}const y=m[0],w=m[1],x=Math.ceil(u[2]/2),_=`vec4 ${p}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${w}, ${y}, ${x*Math.ceil(u[1]/2)}, ${x}, b, row, col);
      return ${b.texture2D}(${s}, uv);}`;return new a.GlslLibRoutine(_,["coordinates.packedUVfrom3D"])}getPackedSamplerND(p,s,r){const u=r.unpackedShape,d=u.length,m=[r.width,r.height],b=(0,l.getGlsl)(this.context.glContext.version),y=[m[0],m[1]],w=y[1],x=y[0],_=Math.ceil(u[d-1]/2);let v=_*Math.ceil(u[d-2]/2),E="int b, int row, int col",I=`b * ${v} + (row / 2) * ${_} + (col / 2)`;for(let T=2;T<d-1;T++)E=`int b${T}, `+E,v*=u[d-T-1],I=`b${T} * ${v} + `+I;const S=`vec4 ${p}(${E}) {
      int index = ${I};
      int texR = index / ${x};
      int texC = index - texR * ${x};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${x}, ${w});
      return ${b.texture2D}(${s}, uv);
    }`;return new a.GlslLibRoutine(S)}getUnpackedSamplerScalar(p,s,r){const[u,d]=[r.width,r.height];if(u===1&&d===1){const b=`
          float ${p}() {
            return sampleTexture(${s}, halfCR);
          }
        `;return new a.GlslLibRoutine(b,["coordinates.sampleTexture"])}const m=`
        float ${p}() {
          int offset_${s} = coordsToOffset(TexCoords, ${u}, ${d});
          vec2 uv = uvFromFlat(${u}, ${d}, offset_${s});
          return sampleTexture(${s}, uv);
        }
      `;return new a.GlslLibRoutine(m,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(p,s,r){const u=r.width,d=r.height;if(d===1&&u===1){const b=`
        float ${p}(int index) {
          return sampleTexture(${s}, halfCR);
        }
      `;return new a.GlslLibRoutine(b,["coordinates.sampleTexture"])}if(d===1){const b=`
          float ${p}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${u}.0, 0.5);
            return sampleTexture(${s}, uv);
          }
        `;return new a.GlslLibRoutine(b,["coordinates.sampleTexture"])}if(u===1){const b=`
          float ${p}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${d}.0);
            return sampleTexture(${s}, uv);
          }
        `;return new a.GlslLibRoutine(b,["coordinates.sampleTexture"])}const m=`
        float ${p}(int index) {
          vec2 uv = uvFromFlat(${u}, ${d}, index);
          return sampleTexture(${s}, uv);
        }
      `;return new a.GlslLibRoutine(m,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(p,s,r){const u=r.unpackedShape,d=[r.height,r.width];if(d!=null&&n.ArrayUtil.arraysEqual(u,d)){const v=`
          float ${p}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${d[1]}.0, ${d[0]}.0);
            return sampleTexture(${s}, uv);
          }
        `;return new a.GlslLibRoutine(v,["coordinates.sampleTexture"])}const{newShape:m,keptDims:b}=(0,c.squeezeShape)(u),y=m;if(y.length<u.length){const v=(0,f.squeezeInputShape)(u,y),E=JSON.parse(JSON.stringify(r));E.unpackedShape=v;const I=["col","row"],S=`
          ${this.getUnpackedSamplerFromInput(p,s,E).routineBody}
          float ${p}(int row, int col) {
            return ${p}(${(0,f.getSqueezedParams)(I,b)});
          }
        `;return new a.GlslLibRoutine(S,["coordinates.sampleTexture"])}const w=d[1],x=d[0];if(x===1){const v=`
          float ${p}(int row, int col) {
            int offset_${s} = coordsToOffset(TexCoords, ${w}, ${x});
            float index = dot(vec3(row, col, offset_${s}), vec3(${u[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${w}.0);
            return sampleTexture(${s}, uv);
          }
        `;return new a.GlslLibRoutine(v,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(w===1){const v=`
          float ${p}(int row, int col) {
            int offset_${s} = coordsToOffset(TexCoords, ${w}, ${x});
            float index = dot(vec3(row, col, offset_${s}), vec3(${u[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${x}.0, 0.5);
            return sampleTexture(${s}, uv);
          }
        `;return new a.GlslLibRoutine(v,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const _=`
        float ${p}(int row, int col) {
          int index = col * ${u[1]} + row;
          vec2 uv = uvFromFlat(${w}, ${x}, index);
          return sampleTexture(${s}, uv);
        }
      `;return new a.GlslLibRoutine(_,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(p,s,r){const u=r.unpackedShape,d=u[1]*u[2],m=u[2],{newShape:b,keptDims:y}=(0,c.squeezeShape)(u),w=b;if(w.length<u.length){const _=(0,f.squeezeInputShape)(u,w),v=["batch","col","row"],E=JSON.parse(JSON.stringify(r));E.unpackedShape=_;const I=this.getUnpackedSamplerFromInput(p,s,E),S=y.reverse(),T=`
          ${I.routineBody}
          float ${p}(int batch, int row, int col) {
            return ${p}(${(0,f.getSqueezedParams)(v,S)});
          }
        `;return new a.GlslLibRoutine(T,I.dependencies)}const x=`
          float ${p}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${d} + col * ${m} + row;
            vec2 uv = uvFromFlat(${r.width}, ${r.height}, index);
            return sampleTexture(${s}, uv);
          }
      `;return new a.GlslLibRoutine(x,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(p,s,r){const u=r.unpackedShape,d=u[3],m=u[2]*d,b=`
        float ${p}(int row, int col, int depth, int depth2) {
          int index = row * ${u[1]*m} + col * ${m} +
              depth2 * ${d} + depth;
          vec2 uv = uvFromFlat(${r.width}, ${r.height}, index);
          return sampleTexture(${s}, uv);
        }
      `;return new a.GlslLibRoutine(b,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(p,s,r){const u=r.unpackedShape,d=u[4],m=u[3]*d,b=u[2]*m,y=u[1]*b,{newShape:w,keptDims:x}=(0,c.squeezeShape)(u);if(w.length<u.length){const v=(0,f.squeezeInputShape)(u,w),E=["row","col","depth","depth2","depth3"],I=JSON.parse(JSON.stringify(r));I.unpackedShape=v;const S=`
          ${this.getUnpackedSamplerFromInput(p,s,I).routineBody}
          float ${p}(int row, int col, int depth, int depth2, int depth3) {
            return ${p}(${(0,f.getSqueezedParams)(E,x)});
          }
        `;return new a.GlslLibRoutine(S,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const _=`
        float ${p}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${y} + col * ${b} + depth * ${m} +
          depth3 * ${d} + depth2;
          vec2 uv = uvFromFlat(${r.width}, ${r.height}, index);
          return sampleTexture(${s}, uv);
        }
      `;return new a.GlslLibRoutine(_,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(p,s,r){const u=r.unpackedShape,d=u[5],m=u[4]*d,b=u[3]*m,y=u[2]*b,w=u[1]*y,{newShape:x,keptDims:_}=(0,c.squeezeShape)(u);if(x.length<u.length){const E=(0,f.squeezeInputShape)(u,x),I=["row","col","depth","depth2","depth3","depth4"],S=JSON.parse(JSON.stringify(r));S.unpackedShape=E;const T=`
            ${this.getUnpackedSamplerFromInput(p,s,S).routineBody}
            float ${p}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${p}(${(0,f.getSqueezedParams)(I,_)});
            }
          `;return new a.GlslLibRoutine(T,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const v=`
          float ${p}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${w} + col * ${y} + depth * ${b} +
            depth2 * ${m} + depth3 * ${d} + depth4;
            vec2 uv = uvFromFlat(${r.width}, ${r.height}, index);
            return sampleTexture(${s}, uv);
          }
        `;return new a.GlslLibRoutine(v,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const p=this.context.outputTextureLayout,s=p.shape.length,r=p.strides,u=p.width,d=p.height,m=[];for(let y=0;y<s-1;++y)m.push(`
        c[${y}] = offset / ${r[y]};`),m.push(`
        offset -= c[${y}] * ${r[y]};`);m.push(`
        c[${s-1}] = offset;`);const b=`
      void toVec(vec2 texCoords, out int c[${s}]) {
        int offset = coordsToOffset(texCoords, ${u}, ${d});
        ${m.join("")}
      }
      void toVec(int offset, out int c[${s}]) {
        ${m.join("")}
      }
    `;return{toVec:new a.GlslLibRoutine(b,["coordinates.coordsToOffset"])}}valueFrom(){const p={};return this.context.programInfo.inputNames.forEach((s,r)=>{const u=this.context.inputTextureLayouts[r],d=(u.unpackedShape.length>0?u.unpackedShape:u.shape).length;let m=`_${s}`;p[m]=new a.GlslLibRoutine(this.getValueFromSingle(s,d,u.width,u.height,!1),[`shapeUtils.indicesToOffset${m}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),m+="_T",p[m]=new a.GlslLibRoutine(this.getValueFromSingle(s,d,u.width,u.height,!0),[`shapeUtils.indicesToOffset${m}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),p}getValueFromSingle(p,s,r,u,d){let m=`_${p}`;return d&&(m+="_T"),`
        float ${m}(int m[${s}]) {
          int offset = indicesToOffset${m}(m);
          vec2 coords = offsetToCoords(offset, ${r}, ${u});
          float value = getColorAsFloat(${(0,l.getGlsl)(this.context.glContext.version).texture2D}(${p}, coords));
          return value;
        }
        `}getPackedValueFrom(p,s,r,u,d){let m=`_${p}_Pack`;return d&&(m+="_T"),`
        vec4 ${m}(int m[${s}]) {
          int offset = indicesToOffset_${p}(m);
          vec2 coords = offsetToCoords(offset, ${r}, ${u});
          return ${(0,l.getGlsl)(this.context.glContext.version).texture2D}(${p}, coords);
        }
        `}}t.CoordsGlslLib=g},1997:(o,t)=>{var e;Object.defineProperty(t,"__esModule",{value:!0}),t.TopologicalSortGlslRoutines=t.GlslLibRoutineNode=t.GlslLibRoutine=t.GlslLib=t.GlslContext=t.FunctionType=void 0,(e=t.FunctionType||(t.FunctionType={}))[e.ValueBased=0]="ValueBased",e[e.Positional=1]="Positional",t.GlslContext=class{constructor(n,a,l,c){this.glContext=n,this.programInfo=a,this.inputTextureLayouts=l,this.outputTextureLayout=c}},t.GlslLib=class{constructor(n){this.context=n}},t.GlslLibRoutine=class{constructor(n,a){this.routineBody=n,this.dependencies=a}},t.GlslLibRoutineNode=class{constructor(n,a,l){this.name=n,this.dependencies=l||[],a&&(this.routineBody=a)}addDependency(n){n&&this.dependencies.push(n)}},t.TopologicalSortGlslRoutines=class{static returnOrderedNodes(n){if(!n||n.length===0)return[];if(n.length===1)return n;const a=new Set,l=new Set,c=new Array;return this.createOrderedNodes(n,a,l,c),c}static createOrderedNodes(n,a,l,c){for(let f=0;f<n.length;++f)this.dfsTraverse(n[f],a,l,c)}static dfsTraverse(n,a,l,c){if(!n||l.has(n.name))return;if(a.has(n.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");a.add(n.name);const f=n.dependencies;if(f&&f.length>0)for(let g=0;g<f.length;++g)this.dfsTraverse(f[g],a,l,c);c.push(n),l.add(n.name),a.delete(n.name)}}},1371:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.EncodingGlslLib=void 0;const n=e(1997);class a extends n.GlslLib{constructor(c){super(c)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new n.GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new n.GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){const c=a.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new n.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${c}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){const c=a.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new n.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${c}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){const c=new ArrayBuffer(4),f=new Uint32Array(c),g=new Uint8Array(c);if(f[0]=3735928559,g[0]===239)return!0;if(g[0]===222)return!1;throw new Error("unknown endianness")}}t.EncodingGlslLib=a},2691:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.FragColorGlslLib=void 0;const n=e(1997),a=e(6757);class l extends n.GlslLib{constructor(f){super(f)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const f=(0,a.getGlsl)(this.context.glContext.version);return{setFragColor:new n.GlslLibRoutine(`
        void setFragColor(float value) {
            ${f.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new n.GlslLibRoutine(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}t.FragColorGlslLib=l},3878:(o,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.replaceInlines=void 0;const e=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;t.replaceInlines=function(n){const a={};let l;for(;(l=e.exec(n))!==null;){const c=l[3].split(",").map(f=>{const g=f.trim().split(" ");return g&&g.length===2?{type:g[0],name:g[1]}:null}).filter(f=>f!==null);a[l[2]]={params:c,body:l[4]}}for(const c in a){const f="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",c),g=new RegExp(f,"gm");for(;(l=g.exec(n))!==null;){const h=l[1],p=l[2],s=l[3].split(","),r=h?`${h} ${p};`:"";let u=a[c].body,d="";a[c].params.forEach((b,y)=>{b&&(d+=`${b.type} ${b.name} = ${s[y]};
`)}),u=`${d}
 ${u}`,u=u.replace("return",`${p} = `);const m=`
      ${r}
      {
        ${u}
      }
      `;n=n.replace(l[0],m)}}return n.replace(e,"")}},8897:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.GlslPreprocessor=void 0;const n=e(1997),a=e(3878),l=e(1248),c=e(6757);t.GlslPreprocessor=class{constructor(f,g,h,p){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new n.GlslContext(f,g,h,p),Object.keys(l.glslRegistry).forEach(r=>{const u=new l.glslRegistry[r](this.context);this.libs[r]=u});const s=this.glslLibRoutineDependencyGraph;for(const r in this.libs){const u=this.libs[r].getFunctions();for(const d in u){const m=r+"."+d;let b;s[m]?(b=s[m],b.routineBody=u[d].routineBody):(b=new n.GlslLibRoutineNode(m,u[d].routineBody),s[m]=b);const y=u[d].dependencies;if(y)for(let w=0;w<y.length;++w)if(s[y[w]])b.addDependency(s[y[w]]);else{const x=new n.GlslLibRoutineNode(y[w]);s[y[w]]=x,b.addDependency(x)}}}}preprocess(){const f=this.context.programInfo;let g=f.shaderSource;return this.context.programInfo.hasMain||(g=`${g}
      ${(0,c.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),g=(0,a.replaceInlines)(g),`${(0,c.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(f.inputNames,f.variables)}
    ${this.getImports(g)}
    ${g}`}getImports(f){const g=this.selectGlslLibRoutinesToBeIncluded(f);if(g.length===0)return"";let h="";for(let p=0;p<g.length;++p){if(!g[p].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${g[p].name}`);h+=g[p].routineBody+`
`}return h}selectGlslLibRoutinesToBeIncluded(f){const g=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(h=>{const p=h.split(".")[1];f.indexOf(p)!==-1&&g.push(this.glslLibRoutineDependencyGraph[h])}),n.TopologicalSortGlslRoutines.returnOrderedNodes(g)}getUniforms(f,g){const h=[];if(f)for(const p of f)h.push(`uniform sampler2D ${p};`);if(g)for(const p of g)h.push(`uniform ${p.type} ${p.name}${p.arrayLength?`[${p.arrayLength}]`:""};`);return h.join(`
`)}}},1248:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.glslRegistry=void 0;const n=e(6859),a=e(1371),l=e(2691),c=e(9183),f=e(9314);t.glslRegistry={encoding:a.EncodingGlslLib,fragcolor:l.FragColorGlslLib,vec:f.VecGlslLib,shapeUtils:c.ShapeUtilsGlslLib,coordinates:n.CoordsGlslLib}},9183:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ShapeUtilsGlslLib=void 0;const n=e(1997);class a extends n.GlslLib{constructor(c){super(c)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const c=this.context.outputTextureLayout.shape.length,f={};return this.context.programInfo.inputNames.forEach((g,h)=>{const p=this.context.inputTextureLayouts[h].unpackedShape;if(p.length<=c){const s=p.length,r=c-s,u=`bcastIndices_${g}`;let d="";for(let b=0;b<s;++b)d+=`
          realIndices[${b}] = int( mod(float(bcastedIndices[${r+b}]), ${p[b]}.0) );
          `;const m=`
        void ${u} (int bcastedIndices[${c}], out int realIndices[${s}]) {
          ${d}
        }
        `;f[u]=new n.GlslLibRoutine(m)}}),f}bcastMatmulIndex(){const c=this.context.outputTextureLayout.shape.length,f={};return this.context.programInfo.inputNames.forEach((g,h)=>{const p=this.context.inputTextureLayouts[h].shape;if(!(p.length<2||p.length>c)){const s=p.length,r=c-s,u=`bcastMatmulIndices_${g}`;let d="";for(let b=0;b<s-2;++b)d+=`
          realIndices[${b}] = int( mod(float(bcastedIndices[${r+b}]), ${p[b]}.0) );
          `;const m=`
        void ${u}(int bcastedIndices[${c}], out int realIndices[${s}]) {
          ${d}
          realIndices[${s-1}] = bcastedIndices[${c-1}];
          realIndices[${s-2}] = bcastedIndices[${c-2}];
        }
        `;f[u]=new n.GlslLibRoutine(m)}}),f}indicesToOffset(){const c={};return this.context.programInfo.inputNames.forEach((f,g)=>{const h=this.context.inputTextureLayouts[g].shape,p=this.context.inputTextureLayouts[g].strides,s=h.length;let r=`indicesToOffset_${f}`;c[r]=new n.GlslLibRoutine(a.indexToOffsetSingle(r,s,p)),r=`indicesToOffset_${f}_T`,c[r]=new n.GlslLibRoutine(a.indexToOffsetSingle(r,s,p.slice().reverse()))}),c}static indexToOffsetSingle(c,f,g){let h="";for(let p=f-1;p>=0;--p)h+=`
        offset += indices[${p}] * ${g[p]};
        `;return`
      int ${c}(int indices[${f}]) {
        int offset = 0;
        ${h}
        return offset;
      }
      `}offsetToIndices(){const c={};return this.context.programInfo.inputNames.forEach((f,g)=>{const h=this.context.inputTextureLayouts[g].shape,p=this.context.inputTextureLayouts[g].strides,s=h.length;let r=`offsetToIndices_${f}`;c[r]=new n.GlslLibRoutine(a.offsetToIndicesSingle(r,s,p)),r=`offsetToIndices_${f}_T`,c[r]=new n.GlslLibRoutine(a.offsetToIndicesSingle(r,s,p.slice().reverse()))}),c}static offsetToIndicesSingle(c,f,g){const h=[];for(let p=0;p<f-1;++p)h.push(`
      indices[${p}] = offset / ${g[p]};`),h.push(`
        offset -= indices[${p}] * ${g[p]};`);return h.push(`
      indices[${f-1}] = offset;`),`
      void ${c}(int offset, out int indices[${f}]) {
        ${h.join("")}
      }
      `}incrementIndices(){const c={};return this.context.programInfo.inputNames.forEach((f,g)=>{const h=this.context.inputTextureLayouts[g].shape,p=h.length,s=`incrementIndices_${f}`;let r="";for(let d=0;d<p;++d)r+=`
        shape[${d}] = ${h[d]};`;const u=`
        void ${s}(int axis, out int indices[${p}]) {
          int shape[${p}];
          ${r};
          for(int i = ${p} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;c[s]=new n.GlslLibRoutine(u)}),c}}t.ShapeUtilsGlslLib=a},6757:(o,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.getDefaultFragShaderMain=t.getFragShaderPreamble=t.getVertexShaderSource=t.getGlsl=void 0;const e={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},n={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function a(l){return l===1?e:n}t.getGlsl=a,t.getVertexShaderSource=function(l){const c=a(l);return`${c.version}
      precision highp float;
      ${c.attribute} vec3 position;
      ${c.attribute} vec2 textureCoord;

      ${c.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`},t.getFragShaderPreamble=function(l){const c=a(l);return`${c.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${c.varyingFrag} vec2 TexCoords;
    ${c.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `},t.getDefaultFragShaderMain=function(l,c){return`
  void main() {
    int indices[${c}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${a(l).output} = result;
  }
  `}},9314:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.VecGlslLib=void 0;const n=e(1997);class a extends n.GlslLib{constructor(c){super(c)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const c=this.context.outputTextureLayout.shape.length,f={add:"+=",sub:"-=",mul:"*=",div:"/="},g={};for(const h in f){const p=`${h}Vec`;let s="";for(let u=0;u<c;++u)s+=`
          dest[${u}] ${f[h]} src[${u}];
          `;const r=`
        void ${p}(int src[${c}], out int dest[${c}]) {
          ${s}
        }
        `;g[p]=new n.GlslLibRoutine(r)}return g}copyVec(){const c=this.context.outputTextureLayout.shape.length;let f="";for(let h=0;h<c;++h)f+=`
        dest[${h}] = src[${h}];
        `;const g=`
      void copyVec(int src[${c}], out int dest[${c}]) {
        ${f}
      }
      `;return{copyVec:new n.GlslLibRoutine(g)}}setVecItem(){const c=this.context.outputTextureLayout.shape.length;let f=`
        if(index < 0)
            index =${c} + index;
        if (index == 0)
            m[0] = value;
        `;for(let h=1;h<c-1;++h)f+=`
        else if (index == ${h})
            m[${h}] = value;
            `;f+=`
        else
            m[${c-1}] = value;
        `;const g=`
      void setVecItem(out int m[${c}], int index, int value) {
        ${f}
      }
        `;return{setVecItem:new n.GlslLibRoutine(g)}}getVecItem(){const c=this.context.outputTextureLayout.shape.length;let f=`
        if(index < 0)
            index = ${c} + index;
        if (index == 0)
            return m[0];
      `;for(let h=1;h<c-1;++h)f+=`
        else if (index == ${h})
            return m[${h}];
      `;f+=`
        else
            return m[${c-1}];
        `;const g=`
      int getVecItem(int m[${c}], int index) {
        ${f}
      }
    `;return{getVecItem:new n.GlslLibRoutine(g)}}}t.VecGlslLib=a},7860:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLInferenceHandler=void 0;const n=e(1315),a=e(9240),l=e(7273),c=e(9),f=e(7379),g=e(2488),h=e(540),p=e(3314),s=e(5639);t.WebGLInferenceHandler=class{constructor(r){this.session=r,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(r,u){return(0,p.calculateTextureWidthAndHeight)(this.session.layoutStrategy,r,u)}executeProgram(r,u){if(u.length<r.inputNames.length)throw new Error(`Input size mustn't be less than ${r.inputNames.length}.`);if(r.inputNames.length!==r.inputTypes.length)throw new Error("input names size does not match input types");const d=[];for(let _=0;_<r.inputNames.length;++_)d[_]=this.getOrCreateTextureData(u[_],r.inputTypes[_]);const m=((_,v)=>{const E=v.map(S=>`${S.unpackedShape.join(",")};${S.width}x${S.height}`).join("_");let I=_.name;return _.cacheHint&&(I+="["+_.cacheHint+"]"),I+=":"+E,I})(r,d);let b=this.session.programManager.getArtifact(m);const y=b?b.programInfo:typeof r.get=="function"?r.get():r,w=(0,p.createTextureLayoutFromTextureType)(this.session.layoutStrategy,y.output.dims,y.output.textureType),x=this.createTextureData(w,y.output.type);return b||(b=this.session.programManager.build(y,d,x),this.session.programManager.setArtifact(m,b)),this.runProgram(b,d,x),x}run(r,u){return this.executeProgram(r,u).tensor}runProgram(r,u,d){for(let m=0;m<u.length;++m)if(!!u[m].isPacked!=(r.programInfo.inputTypes[m]===s.TextureType.packed))throw new Error(`input[${m}] property packed inconsistent`);if(!!d.isPacked!=(r.programInfo.output.textureType===s.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(r,u,d)}getOrCreateTextureData(r,u){let d=this.getTextureData(r.dataId,u===s.TextureType.packed);if(!d&&(d=this.getTextureData(r.dataId,u!==s.TextureType.packed),d))return u===s.TextureType.packed?this.pack(d):this.unpack(d);if(!d){const m=(0,p.createTextureLayoutFromTextureType)(this.session.layoutStrategy,r.dims,u);if(u===s.TextureType.packedLastDimension){const w=r.dims;if(w.length===4){const x=[w[0],Math.ceil(w[1]*w[2]*w[3]/4)],_=(0,p.createTextureLayoutFromTextureType)(this.session.layoutStrategy,x,u);let v=r.numberData;if(w[1]*w[2]*w[3]%4!=0){const E=w[0],I=w[1]*w[2]*w[3],S=Math.ceil(I*1/4)*4;v=new Float32Array(E*S);for(let T=0;T<E;++T){const A=T*I,O=T*S+T%1*I;v.set(r.numberData.subarray(A,A+I),O)}}return this.createTextureData(_,r.type,v,r,1)}}if(u===s.TextureType.packed){const b=(0,p.createTextureLayoutFromShape)(this.session.layoutStrategy,r.dims,1,[],{reverseWH:!0}),y=this.createTextureData(b,r.type,r.numberData,r,1);d=this.pack(y)}else d=this.createTextureData(m,r.type,r.numberData,r,1)}return d}createTextureDataFromLayoutBindTensor(r,u,d,m){return this.createTextureData(r,u,d,m,1)}createTextureData(r,u,d,m,b){n.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(r)}]`);const y=this.session.textureManager.createTextureFromLayout(u,r,d,b);return this.createTextureDataFromTexture(r,u,y,m)}reshapeUnpacked(r,u){const d=this.getOrCreateTextureData(r,s.TextureType.unpacked),m={channels:d.channels,height:d.height,width:d.width,shape:u.length!==0?u:[1],strides:l.ShapeUtil.computeStrides(u),unpackedShape:u};return this.createTextureDataFromTexture(m,r.type,d.texture).tensor}reshapePacked(r,u){const d=this.getOrCreateTextureData(r,s.TextureType.packed);if((0,f.isReshapeCheap)(r.dims,u)){const x={channels:d.channels,height:d.height,width:d.width,shape:u.length!==0?u:[1],strides:l.ShapeUtil.computeStrides(u),unpackedShape:u,isPacked:!0};return this.createTextureDataFromTexture(x,r.type,d.texture).tensor}const m=(0,f.processDims3D)(r.dims),b=(0,f.processDims3D)(u),y=this.reshapePacked(r,m),w=this.run((0,f.createPackedReshape3DProgramInfoLoader)(this,y,b),[y]);return this.reshapePacked(w,u)}cast(r,u){const d=this.getOrCreateTextureData(r,s.TextureType.unpacked);return this.createTextureDataFromTexture(d,u,d.texture).tensor}createTextureDataFromTexture(r,u,d,m,b){const y=Object.assign(Object.assign({},r),{tensor:m||new a.Tensor(r.unpackedShape,u,w=>this.readTexture(y),async w=>this.readTextureAsync(y),void 0,b),texture:d});return this.setTextureData(y.tensor.dataId,y,r.isPacked),y}getTextureData(r,u=!1){return this.session.isInitializer(r)?this.session.getTextureData(r,u):u?this.packedTextureDataCache.get(r):this.unpackedTextureDataCache.get(r)}setTextureData(r,u,d=!1){this.session.isInitializer(r)?this.session.setTextureData(r,u,d):(d?this.packedTextureDataCache:this.unpackedTextureDataCache).set(r,u)}isTextureLayoutCached(r,u=!1){return!!this.getTextureData(r.dataId,u)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(r=>this.session.textureManager.releaseTexture(r)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(r=>this.session.textureManager.releaseTexture(r)),this.unpackedTextureDataCache=new Map}readTexture(r){return r.isPacked?this.readTexture(this.unpack(r)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(r,r.tensor.type,r.channels):this.session.textureManager.readUint8TextureAsFloat((0,g.encodeAsUint8)(this,r))}async readTextureAsync(r){return r.isPacked?this.readTextureAsync(this.unpack(r)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(r,r.tensor.type,r.channels):this.session.textureManager.readUint8TextureAsFloat((0,g.encodeAsUint8)(this,r))}pack(r){return this.executeProgram((0,c.createPackProgramInfoLoader)(this,r.tensor),[r.tensor])}unpack(r){return this.executeProgram((0,h.createUnpackProgramInfoLoader)(this,r.tensor),[r.tensor])}}},4110:function(o,t,e){var n=this&&this.__createBinding||(Object.create?function(W,Z,at,J){J===void 0&&(J=at);var Y=Object.getOwnPropertyDescriptor(Z,at);Y&&!("get"in Y?!Z.__esModule:Y.writable||Y.configurable)||(Y={enumerable:!0,get:function(){return Z[at]}}),Object.defineProperty(W,J,Y)}:function(W,Z,at,J){J===void 0&&(J=at),W[J]=Z[at]}),a=this&&this.__setModuleDefault||(Object.create?function(W,Z){Object.defineProperty(W,"default",{enumerable:!0,value:Z})}:function(W,Z){W.default=Z}),l=this&&this.__importStar||function(W){if(W&&W.__esModule)return W;var Z={};if(W!=null)for(var at in W)at!=="default"&&Object.prototype.hasOwnProperty.call(W,at)&&n(Z,W,at);return a(Z,W),Z};Object.defineProperty(t,"__esModule",{value:!0}),t.WEBGL_OP_RESOLVE_RULES=void 0;const c=e(8817),f=l(e(5194)),g=e(4752),h=e(6668),p=e(9754),s=e(5042),r=e(6742),u=e(4125),d=e(6149),m=e(5378),b=e(6981),y=e(7413),w=e(7006),x=e(8276),_=e(5565),v=e(2834),E=e(1010),I=e(8126),S=e(2801),T=e(565),A=e(2444),O=e(815),$=e(564),D=e(5416),M=e(1240),F=e(5944),C=e(5707),R=l(e(9087)),j=e(7862),G=e(3980);t.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",R.abs],["Acos","","7+",R.acos],["Add","","7+",f.add],["And","","7+",f.and],["Asin","","7+",R.asin],["Atan","","7+",R.atan],["AveragePool","","7+",v.averagePool,v.parseAveragePoolAttributes],["BatchNormalization","","7+",c.batchNormalization,c.parseBatchNormalizationAttributes],["Cast","","6+",g.cast,g.parseCastAttributes],["Ceil","","6+",R.ceil],["Clip","","6-10",R.clip,R.parseClipAttributes],["Clip","","11+",R.clipV11],["Concat","","4+",h.concat,h.parseConcatAttributes],["Conv","","1+",p.conv,p.parseConvAttributes],["ConvTranspose","","1+",s.convTranspose,s.parseConvTransposeAttributes],["Cos","","7+",R.cos],["Div","","7+",f.div],["Dropout","","7+",R.identity],["DepthToSpace","","1+",r.depthToSpace,r.parseDepthToSpaceAttributes],["Equal","","7+",f.equal],["Elu","","6+",R.elu,R.parseEluAttributes],["Exp","","6+",R.exp],["Flatten","","1+",u.flatten,u.parseFlattenAttributes],["Floor","","6+",R.floor],["FusedConv","com.microsoft","1+",p.conv,p.parseConvAttributes],["Gather","","1+",d.gather,d.parseGatherAttributes],["Gemm","","7-10",m.gemm,m.parseGemmAttributesV7],["Gemm","","11+",m.gemm,m.parseGemmAttributesV11],["GlobalAveragePool","","1+",v.globalAveragePool,v.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",v.globalMaxPool],["Greater","","7+",f.greater],["Identity","","1+",R.identity],["ImageScaler","","1+",b.imageScaler,b.parseImageScalerAttributes],["InstanceNormalization","","6+",y.instanceNormalization,y.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",R.leakyRelu,R.parseLeakyReluAttributes],["Less","","7+",f.less],["LRN","","1+",w.lrn,w.parseLrnAttributes],["Log","","6+",R.log],["MatMul","","1+",x.matMul,x.parseMatMulAttributes],["MaxPool","","1+",v.maxPool,v.parseMaxPoolAttributes],["Mul","","7+",f.mul],["Neg","","6+",R.neg],["Not","","1+",R.not],["Or","","7+",f.or],["Pad","","2-10",_.padV2,_.parsePadAttributesV2],["Pad","","11+",_.padV11,_.parsePadAttributesV11],["Pow","","7+",f.pow],["PRelu","","7+",f.pRelu],["ReduceLogSum","","1+",E.reduceLogSum,E.parseReduceAttributes],["ReduceMax","","1+",E.reduceMax,E.parseReduceAttributes],["ReduceMean","","1+",E.reduceMean,E.parseReduceAttributes],["ReduceMin","","1+",E.reduceMin,E.parseReduceAttributes],["ReduceProd","","1+",E.reduceProd,E.parseReduceAttributes],["ReduceSum","","1-12",E.reduceSum,E.parseReduceAttributes],["ReduceSumSquare","","1+",E.reduceLogSumSquare,E.parseReduceAttributes],["Relu","","6+",R.relu],["Reshape","","5+",I.reshape],["Resize","","10",S.resize,S.parseResizeAttributesV10],["Resize","","11+",S.resize,S.parseResizeAttributesV11],["Shape","","1+",T.shape],["Sigmoid","","6+",R.sigmoid],["Sin","","7+",R.sin],["Slice","","10+",A.sliceV10],["Slice","","1-9",A.slice,A.parseSliceAttributes],["Softmax","","1-12",O.softmax,O.parseSoftmaxAttributes],["Softmax","","13+",O.softmaxV13,O.parseSoftmaxAttributesV13],["Split","","2-12",$.split,$.parseSplitAttributes],["Sqrt","","6+",R.sqrt],["Squeeze","","1-12",D.squeeze,D.parseSqueezeAttributes],["Squeeze","","13+",D.squeezeV13],["Sub","","7+",f.sub],["Sum","","6+",M.sum],["Tan","","7+",R.tan],["Tanh","","6+",R.tanh],["Tile","","6+",F.tile],["Transpose","","1+",C.transpose,C.parseTransposeAttributes],["Upsample","","7-8",G.upsample,G.parseUpsampleAttributesV7],["Upsample","","9",G.upsample,G.parseUpsampleAttributesV9],["Unsqueeze","","1-12",j.unsqueeze,j.parseUnsqueezeAttributes],["Unsqueeze","","13+",j.unsqueezeV13],["Xor","","7+",f.xor]]},8817:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseBatchNormalizationAttributes=t.batchNormalization=void 0;const n=e(4910),a=e(6757),l=e(5639),c={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[l.TextureType.unpacked,l.TextureType.unpacked,l.TextureType.unpacked,l.TextureType.unpacked,l.TextureType.unpacked]};t.batchNormalization=(h,p,s)=>(g(p),[h.run(Object.assign(Object.assign({},c),{cacheHint:s.cacheKey,get:()=>f(h,p,s)}),p)]),t.parseBatchNormalizationAttributes=h=>{const p=h.attributes.getFloat("epsilon",1e-5),s=h.attributes.getFloat("momentum",.9),r=h.attributes.getInt("spatial",1);return(0,n.createAttributeWithCacheKey)({epsilon:p,momentum:s,spatial:r})};const f=(h,p,s)=>{const r=(0,a.getGlsl)(h.session.backend.glContext.version),u=p[0].dims.length,[d,m]=h.calculateTextureWidthAndHeight(p[1].dims,l.TextureType.unpacked),b=`
  float process(int[${u}] indices) {
    vec2 position = offsetToCoords(indices[1], ${d}, ${m});
    float scale = getColorAsFloat(${r.texture2D}(Scale, position));
    float mean = getColorAsFloat(${r.texture2D}(Mean, position));
    float variance = getColorAsFloat(${r.texture2D}(Variance, position));
    float b = getColorAsFloat(${r.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${s.epsilon})) ) + b;
  }`;return Object.assign(Object.assign({},c),{output:{dims:p[0].dims,type:p[0].type,textureType:l.TextureType.unpacked},shaderSource:b})},g=h=>{if(!h||h.length!==5)throw new Error("BatchNormalization requires 5 inputs.");const p=h[0],s=h[1],r=h[2],u=h[3],d=h[4];if(p.dims.length<3||s.dims.length!==1||r.dims.length!==1||u.dims.length!==1||d.dims.length!==1)throw new Error("invalid input shape.");if(s.dims[0]!==p.dims[1]||r.dims[0]!==p.dims[1]||u.dims[0]!==p.dims[1]||d.dims[0]!==p.dims[1])throw new Error("invalid input shape.");if(p.type!=="float32"&&p.type!=="float64"||s.type!=="float32"&&s.type!=="float64"||r.type!=="float32"&&r.type!=="float64"||u.type!=="float32"&&u.type!=="float64"||d.type!=="float32"&&d.type!=="float64")throw new Error("invalid input tensor types.")}},5194:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.xor=t.sub=t.pRelu=t.pow=t.or=t.mul=t.less=t.greater=t.equal=t.div=t.and=t.add=t.glslPRelu=t.glslPow=t.glslXor=t.glslOr=t.glslAnd=t.glslLess=t.glslGreater=t.glslEqual=t.glslSub=t.glslMul=t.glslDiv=t.glslAdd=void 0;const n=e(7273),a=e(1997),l=e(6757),c=e(5639);function f(){const v="add_";return{body:`
  float ${v}(float a, float b) {
    return a + b;
  }
  vec4 ${v}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:v,type:a.FunctionType.ValueBased}}function g(){const v="div_";return{body:`
  float ${v}(float a, float b) {
    return a / b;
  }
  vec4 ${v}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:v,type:a.FunctionType.ValueBased}}function h(){const v="mul_";return{body:`
  float ${v}(float a, float b) {
    return a * b;
  }
  vec4 ${v}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:v,type:a.FunctionType.ValueBased}}function p(){const v="sub_";return{body:`
  float ${v}(float a, float b) {
    return a - b;
  }
  vec4 ${v}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:v,type:a.FunctionType.ValueBased}}function s(){const v="equal_";return{body:`
  float ${v}(float a, float b) {
    return float(a == b);
  }
  vec4 ${v}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:v,type:a.FunctionType.ValueBased}}function r(){const v="greater_";return{body:`
  float ${v}(float a, float b) {
    return float(a > b);
  }
  vec4 ${v}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:v,type:a.FunctionType.ValueBased}}function u(){const v="less_";return{body:`
  float ${v}(float a, float b) {
    return float(a < b);
  }
  vec4 ${v}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:v,type:a.FunctionType.ValueBased}}function d(){const v="and_";return{body:`
  float ${v}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${v}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:v,type:a.FunctionType.ValueBased}}function m(){const v="or_";return{body:`
  float ${v}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${v}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:v,type:a.FunctionType.ValueBased}}function b(){const v="xor_";return{body:`
  float ${v}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${v}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:v,type:a.FunctionType.ValueBased}}function y(){return function(v){const E=`${v}_`;return{body:`
  float ${E}(float a, float b) {
    return ${v}(a, b);
  }
  vec4 ${E}(vec4 v1, vec4 v2) {
    return ${v}(v1, v2);
  }
  `,name:E,type:a.FunctionType.ValueBased}}("pow")}function w(){const v="prelu_";return{body:`
  float ${v}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${v}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:v,type:a.FunctionType.ValueBased}}t.glslAdd=f,t.glslDiv=g,t.glslMul=h,t.glslSub=p,t.glslEqual=s,t.glslGreater=r,t.glslLess=u,t.glslAnd=d,t.glslOr=m,t.glslXor=b,t.glslPow=y,t.glslPRelu=w;const x=(v,E,I,S=E[0].type,T)=>{const A=v.session.pack?c.TextureType.packed:c.TextureType.unpacked;return{name:I.name,inputNames:["A","B"],inputTypes:[A,A],cacheHint:T,get:()=>_(v,E,I,S)}},_=(v,E,I,S=E[0].type)=>{const T=v.session.pack?c.TextureType.packed:c.TextureType.unpacked,A=!n.ShapeUtil.areEqual(E[0].dims,E[1].dims);let O=E[0].dims;const $=v.session.pack;if(A){const F=n.BroadcastUtil.calcShape(E[0].dims,E[1].dims,!1);if(!F)throw new Error("Can't perform binary op on the given tensors");O=F;const C=O.length,R=E[0].dims.length!==0?E[0].dims.length:1,j=E[1].dims.length!==0?E[1].dims.length:1,G=E[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",W=E[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",Z=(0,l.getGlsl)(v.session.backend.glContext.version),at=$?`
      ${I.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${I.name}(a, b);
        ${Z.output} = result;
      }`:`
      ${I.body}
      float process(int indices[${C}]) {
        int aindices[${R}];
        int bindices[${j}];
        ${G}
        ${W}
        return ${I.name}(_A(aindices), _B(bindices));
      }`;return{name:I.name,inputNames:["A","B"],inputTypes:[T,T],output:{dims:O,type:S,textureType:T},shaderSource:at,hasMain:$}}const D=(0,l.getGlsl)(v.session.backend.glContext.version),M=`
    ${I.body}
    void main() {
      vec4 v1 = ${D.texture2D}(A, TexCoords);
      vec4 v2 = ${D.texture2D}(B, TexCoords);
      vec4 result = ${I.name}(v1, v2);
      ${D.output} = result;
    }
    `;return{name:I.name,inputNames:["A","B"],inputTypes:[T,T],output:{dims:E[0].dims,type:S,textureType:T},shaderSource:M,hasMain:!0}};t.add=(v,E)=>[v.run(x(v,E,f()),E)],t.and=(v,E)=>[v.run(x(v,E,d(),"bool"),E)],t.div=(v,E)=>[v.run(x(v,E,g()),E)],t.equal=(v,E)=>[v.run(x(v,E,s(),"bool"),E)],t.greater=(v,E)=>[v.run(x(v,E,r(),"bool"),E)],t.less=(v,E)=>[v.run(x(v,E,u(),"bool"),E)],t.mul=(v,E)=>[v.run(x(v,E,h()),E)],t.or=(v,E)=>[v.run(x(v,E,m(),"bool"),E)],t.pow=(v,E)=>[v.run(x(v,E,y()),E)],t.pRelu=(v,E)=>[v.run(x(v,E,w()),E)],t.sub=(v,E)=>[v.run(x(v,E,p()),E)],t.xor=(v,E)=>[v.run(x(v,E,b(),"bool"),E)]},4752:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseCastAttributes=t.cast=void 0;const n=e(7273);t.cast=(l,c,f)=>(a(c),[l.cast(c[0],f)]),t.parseCastAttributes=l=>n.ProtoUtil.tensorDataTypeFromProto(l.attributes.getInt("to"));const a=l=>{if(!l||l.length!==1)throw new Error("Cast requires 1 input.");if(l[0].type==="string")throw new Error("Invalid input type.")}},4595:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedConcatProgramInfoLoader=void 0;const n=e(6757),a=e(5639),l=e(432),c=e(5614);t.createPackedConcatProgramInfoLoader=(g,h,p)=>{const s=(r=h.length,u=p.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:r},(d,m)=>`X${m}`),inputTypes:Array(r).fill(a.TextureType.packed),cacheHint:u});var r,u;return Object.assign(Object.assign({},s),{get:()=>((d,m,b,y)=>{const w=b[0].dims.slice();if(y>=w.length||y<-1*w.length)throw new Error("axis specified for concat doesn't match input dimensionality");y<0&&(y=w.length+y);const x=w.slice(0);for(let G=1;G<b.length;G++){const W=b[G].dims.slice();for(let Z=0;Z<w.length;Z++)if(Z===y)x[y]+=W[Z];else if(w[Z]!==W[Z])throw new Error("non concat dimensions must match")}const _=x.length,v=(0,c.getChannels)("coords",_),E=(0,l.getCoordsDataType)(_),I=(0,c.unpackFromChannel)(),S=b.map(G=>G.dims),T=(0,l.getGlChannels)(_),A=new Array(S.length-1);A[0]=S[0][y];for(let G=1;G<A.length;G++)A[G]=A[G-1]+S[G][y];const O=T[y],$=T.slice(-2),D=T.join();let M=`if (${O} < ${A[0]}) {
        return getChannel(
            getX0(${D}), vec2(${$.join()}));
        }`;for(let G=1;G<A.length;G++){const W=A[G-1];M+=`
            if (${O} < ${A[G]}  && ${O} >= ${A[G-1]}) {
              return getChannel(
                getX${G}(${f(T,O,W)}),
                vec2(${f($,O,W)}));
            }`}const F=A.length,C=A[A.length-1];M+=`
            return getChannel(
              getX${F}(${f(T,O,C)}),
              vec2(${f($,O,C)}));`;const R=(0,n.getGlsl)(d.session.backend.glContext.version),j=`
          ${I}
          float getValue(${T.map(G=>"int "+G)}) {
            ${M}
          }

          void main() {
            ${E} coords = getOutputCoords();
            int lastDim = coords.${T[_-1]};
            coords.${T[_-1]} = coords.${T[_-2]};
            coords.${T[_-2]} = lastDim;

            vec4 result = vec4(getValue(${v}), 0., 0., 0.);

            ${v[_-1]} = ${v[_-1]} + 1;
            if (${v[_-1]} < ${x[_-1]}) {
              result.g = getValue(${v});
            }

            ${v[_-2]} = ${v[_-2]} + 1;
            if (${v[_-2]} < ${x[_-2]}) {
              result.a = getValue(${v});
            }

            ${v[_-1]} = ${v[_-1]} - 1;
            if (${v[_-2]} < ${x[_-2]} &&
                ${v[_-1]} < ${x[_-1]}) {
              result.b = getValue(${v});
            }
            ${R.output} = result;
          }
        `;return Object.assign(Object.assign({},m),{output:{dims:x,type:b[0].type,textureType:a.TextureType.packed},shaderSource:j,hasMain:!0})})(g,s,h,p.axis)})};const f=(g,h,p)=>{const s=g.indexOf(h);return g.map((r,u)=>u===s?`${r} - ${p}`:r).join()}},6668:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseConcatAttributes=t.concat=void 0;const n=e(4910),a=e(5639),l=e(4595);t.concat=(r,u,d)=>(s(u),r.session.pack&&u[0].dims.length>1?[r.run((0,l.createPackedConcatProgramInfoLoader)(r,u,d),u)]:[r.run(c(r,u,d),u)]);const c=(r,u,d)=>{const m=(b=u.length,y=d.cacheKey,{name:"Concat",inputNames:Array.from({length:b},(w,x)=>`X${x}`),inputTypes:Array(b).fill(a.TextureType.unpacked),cacheHint:y});var b,y;return Object.assign(Object.assign({},m),{get:()=>((w,x,_,v)=>{const E=_[0].dims.slice();if(v>=E.length||v<-1*E.length)throw new Error("axis specified for concat doesn't match input dimensionality");v<0&&(v=E.length+v);const I=E.slice(0);for(let D=1;D<_.length;D++){const M=_[D].dims.slice();for(let F=0;F<E.length;F++)if(F===v)I[v]+=M[F];else if(E[F]!==M[F])throw new Error("non concat dimensions must match")}const S=I.length,T=new Array(_.length);let A=0;for(let D=0;D<T.length;++D)A+=_[D].dims[v],T[D]=A;let O="";O=_.length<5?f(T):g(T);const $=`
        ${h(_.length,S)}
        ${p(T)}
        ${O}
        float process(int indices[${S}]) {
          int textureIndex = getTextureWhereDataResides (indices[${v}]);

          if(textureIndex != 0) {
            indices[${v}] = indices[${v}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return Object.assign(Object.assign({},x),{output:{dims:I,type:_[0].type,textureType:a.TextureType.unpacked},shaderSource:$})})(0,m,u,d.axis)})},f=r=>`int getTextureWhereDataResides(int index) {
      ${r.map((u,d)=>`if(index<${u}) {return ${d};}
`).join("")}
    }`,g=r=>f(r),h=(r,u)=>{const d=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${u}]) {`];for(let m=0;m<r;++m)m===0?d.push(`	if (textureIndex == ${m}) { return _X${m}(indices); }`):m===r-1?d.push(`	else { return _X${m}(indices); }`):d.push(`	else if (textureIndex == ${m}) { return _X${m}(indices); }`);return d.push("	}"),d.join(`
`)},p=r=>{const u=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let d=0;d<r.length;++d)d===0?u.push(`	if (index == ${d}) { return ${r[d]}; }`):d===r.length-1?u.push(`	else { return ${r[d]}; }`):u.push(`	else if (index == ${d}) { return ${r[d]}; }`);return u.push("	}"),u.join(`
`)};t.parseConcatAttributes=r=>(0,n.createAttributeWithCacheKey)({axis:r.attributes.getInt("axis")});const s=r=>{if(!r||r.length<1)throw new Error("too few inputs");const u=r[0].type,d=r[0].dims.length;if(u==="string")throw new Error("string tensor is not supported yet");for(const m of r){if(m.type!==u)throw new Error("input tensors should be one type");if(m.dims.length!==d)throw new Error("input tensors should have the same shape")}}},7825:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createUnpackedGroupedConvProgramInfoLoader=void 0;const n=e(1315),a=e(6757),l=e(5639),c=e(9754),f=e(2150);t.createUnpackedGroupedConvProgramInfoLoader=(g,h,p)=>{const s=(r=h.length>2,u=p.cacheKey,{name:"GroupedConv",inputNames:r?["X","W","Bias"]:["X","W"],inputTypes:r?[l.TextureType.unpacked,l.TextureType.unpacked,l.TextureType.unpacked]:[l.TextureType.unpacked,l.TextureType.unpacked],cacheHint:u});var r,u;return Object.assign(Object.assign({},s),{get:()=>((d,m,b,y)=>{const w=m.length>2?"value += getBias(output_channel);":"",x=m[0].dims.slice(),_=m[1].dims.slice(),v=_[0]/y.group;n.Logger.verbose("GroupedConv",`autpPad:${y.autoPad}, dilations:${y.dilations}, group:${y.group}, kernelShape:${y.kernelShape}, pads:${y.pads}, strides:${y.strides}`);const E=(0,c.calculateOutputShape)(x,_,y.dilations,y.pads,y.strides),I=(0,a.getGlsl)(d.session.backend.glContext.version),{activationFunction:S,applyActivation:T}=(0,f.getActivationSnippet)(y),A=`
  const ivec2 strides = ivec2(${y.strides[0]}, ${y.strides[1]});
  const ivec2 pads = ivec2(${y.pads[0]}, ${y.pads[1]});
  ${S}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${v};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${_[1]}; wInChannel++) {
      int input_channel = group_id * ${_[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${_[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${y.dilations[0]};

        if (xHeight < 0 || xHeight >= ${x[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${_[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${y.dilations[1]};
          if (xWidth < 0 || xWidth >= ${x[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${w}
    ${T}
    ${I.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},b),{output:{dims:E,type:m[0].type,textureType:l.TextureType.unpacked},shaderSource:A,hasMain:!0})})(g,h,s,p)})}},7708:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.conv2DPacked=t.conv2DPackedPointwise=void 0;const n=e(9754),a=e(5950),l=e(5632);t.conv2DPackedPointwise=(c,f,g)=>{const h=f[0].dims,p=f[1].dims,s=(0,n.calculateOutputShape)(h,p,g.dilations,g.pads,g.strides),r=c.reshapePacked(f[0],[h[1],h[2]*h[3]]),u=c.reshapePacked(f[1],[p[0],p[1]]),d=f.length>2?[u,r,f[2]]:[u,r],m=c.run((0,l.createPackedMatmulProgramInfoLoader)(c,d,g),d);return c.reshapePacked(m,s)},t.conv2DPacked=(c,f,g)=>{const h=f[0].dims,p=f[1].dims,s=(0,n.calculateOutputShape)(h,p,g.dilations,g.pads,g.strides),r=c.run((0,a.createPackedIm2ColProgramInfoLoader)(c,f[0],f[1],s,g),[f[0]]),u=c.reshapePacked(f[1],[p[0],p[1]*p[2]*p[3]]),d=f.length===3?[u,r,f[2]]:[u,r],m=c.run((0,l.createPackedMatmulProgramInfoLoader)(c,d,g),d);return c.reshapePacked(m,s)}},5042:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseConvTransposeAttributes=t.convTranspose=void 0;const n=e(4910),a=e(6757),l=e(5639),c=e(2150),f=(u,d,m,b,y,w)=>(u-1)*d+m+(b-1)*y+1-w,g=(u,d,m,b,y)=>{const w=Math.floor(u/2);d==="SAME_UPPER"?(m[b]=w,m[y]=u-w):d==="SAME_LOWER"&&(m[b]=u-w,m[y]=w)};t.convTranspose=(u,d,m)=>(r(d,m),h(u,d,m));const h=(u,d,m)=>{const b=s(m,d);return[p(u,d,b)]},p=(u,d,m)=>u.run(((b,y,w)=>{const x=(_=y.length>2,v=w.cacheKey,{name:"ConvTranspose",inputNames:_?["X","W","B"]:["X","W"],inputTypes:_?[l.TextureType.unpacked,l.TextureType.unpacked,l.TextureType.unpacked]:[l.TextureType.unpacked,l.TextureType.unpacked],cacheHint:v});var _,v;return Object.assign(Object.assign({},x),{get:()=>((E,I,S,T)=>{const A=I.length>2?"getB(output_channel)":"0.0",O=I[0].dims,$=I[1].dims,D=$[1],M=$[0]/T.group,F=[I[0].dims[0],I[1].dims[1]*T.group,...T.outputShape],C=(0,a.getGlsl)(E.session.backend.glContext.version),{activationFunction:R,applyActivation:j}=(0,c.getActivationSnippet)(T),G=`
  const ivec2 strides = ivec2(${T.strides[0]}, ${T.strides[1]});
  const ivec2 pads = ivec2(${T.pads[0]}, ${T.pads[1]});
  ${R}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${D};
    int wOutChannel = output_channel - group_id * ${D};

    float value = ${A};
    for (int inChannelOffset = 0; inChannelOffset < ${M}; inChannelOffset++) {
      int input_channel = group_id * ${M} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${$[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${$[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${T.dilations[0]}, wHOff * ${T.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${O[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${O[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${j}
    ${C.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},S),{output:{dims:F,type:I[0].type,textureType:l.TextureType.unpacked},shaderSource:G,hasMain:!0})})(b,y,x,w)})})(u,d,m),d),s=(u,d)=>{const m=u.kernelShape.slice();if(u.kernelShape.length===0)for(let x=2;x<d[1].dims.length;++x)m.push(d[1].dims[x]);const b=u.pads.slice(),y=u.outputShape.slice();((x,_,v,E,I,S,T,A)=>{const O=x.length-2,$=A.length===0;for(let D=0;D<O;++D){const M=$?x[D+2]*S[D]:A[D],F=f(x[D+2],S[D],I[D],_[D],v[D],M);g(F,E,I,D,D+O),$&&A.push(S[D]*(x[D+2]-1)+T[D]+(_[D]-1)*v[D]+1-I[D]-I[D+O])}})(d[0].dims,m,u.dilations,u.autoPad,b,u.strides,u.outputPadding,y);const w=Object.assign({},u);return Object.assign(w,{kernelShape:m,pads:b,outputShape:y,cacheKey:u.cacheKey}),w};t.parseConvTransposeAttributes=u=>{const d=u.attributes,m=(0,c.parseInternalActivationAttributes)(d),b=d.getString("auto_pad","NOTSET"),y=d.getInts("dilations",[1,1]),w=d.getInt("group",1),x=d.getInts("kernel_shape",[]),_=d.getInts("output_padding",[0,0]),v=d.getInts("output_shape",[]),E=d.getInts("pads",[0,0,0,0]),I=d.getInts("strides",[1,1]);return(0,n.createAttributeWithCacheKey)(Object.assign({autoPad:b,dilations:y,group:w,kernelShape:x,outputPadding:_,outputShape:v,pads:E,strides:I},m))};const r=(u,d)=>{if(!u||u.length!==2&&u.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(u[0].dims.length!==4||u[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(u[0].dims[1]!==u[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const m=u[1].dims[1]*d.group;if(u.length===3&&(u[2].dims.length!==1||u[2].dims[0]!==m))throw new Error("invalid bias");const b=u[0].dims.length-2;if(d.dilations.length!==b)throw new Error(`dilations should be ${b}D`);if(d.strides.length!==b)throw new Error(`strides should be ${b}D`);if(d.pads.length!==2*b)throw new Error(`pads should be ${2*b}D`);if(d.outputPadding.length!==b)throw new Error(`output_padding should be ${b}D`);if(d.kernelShape.length!==0&&d.kernelShape.length!==u[1].dims.length-2)throw new Error("invalid kernel shape");if(d.outputShape.length!==0&&d.outputShape.length!==u[0].dims.length-2)throw new Error("invalid output shape");if(u[0].type!=="float32"||u[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(u.length===3&&u[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}},9754:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseConvAttributes=t.conv=t.calculateOutputShape=void 0;const n=e(4910),a=e(7273),l=e(7825),c=e(7708),f=e(3281),g=e(2150),h=e(1625),p=e(8276);t.calculateOutputShape=(b,y,w,x,_)=>{const v=b[0],E=b.slice(2),I=E.length,S=y[0],T=y.slice(2).map((O,$)=>O+(O-1)*(w[$]-1)),A=E.map((O,$)=>O+x[$]+x[$+I]).map((O,$)=>Math.floor((O-T[$]+_[$])/_[$]));return[v,S].concat(...A)},t.conv=(b,y,w)=>(m(y,w),s(b,y,w));const s=(b,y,w)=>{const x=d(w,y),_=b.session.pack,v=x.kernelShape[0]===1&&x.kernelShape[1]===1;return x.group>1?[b.run((0,l.createUnpackedGroupedConvProgramInfoLoader)(b,y,x),y)]:v&&_?[r(b,y,x)]:_&&y[0].dims.length===4&&y[0].dims[0]===1&&!v?[(0,c.conv2DPacked)(b,y,x)]:[u(b,y,x)]},r=(b,y,w)=>{const x=y[0].dims,_=y[1].dims,v=(0,t.calculateOutputShape)(x,_,w.dilations,w.pads,w.strides),E=b.reshapeUnpacked(y[0],[x[1],x[2]*x[3]]),I=b.reshapeUnpacked(y[1],[_[0],_[1]]),S=y.length>2?[I,E,y[2]]:[I,E],T=b.run((0,p.createMatmulProgramInfoLoader)(S,w),S);return b.reshapeUnpacked(T,v)},u=(b,y,w)=>{const x=y[0].dims,_=y[1].dims,v=(0,t.calculateOutputShape)(x,_,w.dilations,w.pads,w.strides),E=b.run((0,h.createIm2ColProgramInfoLoader)(b,y[0],y[1],v,w),[y[0]]),I=y.length===3?[E,y[1],y[2]]:[E,y[1]];return b.run((0,f.createDotProductProgramInfoLoader)(b,y,v,w),I)},d=(b,y)=>{const w=b.kernelShape.slice();if(b.kernelShape.length===0)for(let v=2;v<y[1].dims.length;++v)w.push(y[1].dims[v]);const x=b.pads.slice();a.PoolConvUtil.adjustPadsBasedOnAutoPad(y[0].dims,b.strides,b.dilations,w,x,b.autoPad);const _=Object.assign({},b);return Object.assign(_,{kernelShape:w,pads:x,cacheKey:b.cacheKey}),_};t.parseConvAttributes=b=>{const y=b.attributes,w=(0,g.parseInternalActivationAttributes)(y),x=y.getString("auto_pad","NOTSET"),_=y.getInts("dilations",[1,1]),v=y.getInt("group",1),E=y.getInts("kernel_shape",[]),I=y.getInts("pads",[0,0,0,0]),S=y.getInts("strides",[1,1]);return(0,n.createAttributeWithCacheKey)(Object.assign({autoPad:x,dilations:_,group:v,kernelShape:E,pads:I,strides:S},w))};const m=(b,y)=>{if(!b||b.length!==2&&b.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(b[0].dims.length!==4||b[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(b[0].dims[1]!==b[1].dims[1]*y.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(b.length===3&&(b[2].dims.length!==1||b[1].dims[0]!==b[2].dims[0]))throw new Error("invalid bias");const w=b[0].dims.length-2;if(y.dilations.length!==w)throw new Error(`dilations should be ${w}D`);if(y.strides.length!==w)throw new Error(`strides should be ${w}D`);if(y.pads.length!==2*w)throw new Error(`pads should be ${2*w}D`);if(y.kernelShape.length!==0&&y.kernelShape.length!==b[1].dims.length-2)throw new Error("invalid kernel shape");if(b[0].type!=="float32"||b[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(b.length===3&&b[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}},6742:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseDepthToSpaceAttributes=t.depthToSpace=void 0;const n=e(5707);t.depthToSpace=(l,c,f)=>{a(c);const g=f.blocksize,h=g*g,p=f.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],s=f.mode==="DCR"?[c[0].dims[0],g,g,c[0].dims[1]/h,c[0].dims[2],c[0].dims[3]]:[c[0].dims[0],c[0].dims[1]/h,g,g,c[0].dims[2],c[0].dims[3]],r=l.reshapeUnpacked(c[0],s),u={perm:p,cacheKey:`${p}`},[d]=(0,n.transpose)(l,[r],u),m=[c[0].dims[0],c[0].dims[1]/h,c[0].dims[2]*g,c[0].dims[3]*g];return[l.reshapeUnpacked(d,m)]},t.parseDepthToSpaceAttributes=l=>{const c=l.attributes.getInt("blocksize");if(c<1)throw new Error(`blocksize must be >= 1, but got : ${c} for DepthToSpace`);const f=l.attributes.getString("mode","DCR");if(f!=="DCR"&&f!=="CRD")throw new Error(`unrecognized mode: ${f} for DepthToSpace`);return{mode:f,blocksize:c}};const a=l=>{if(l.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${l.length}`);if(l[0].type==="string"||l[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},3281:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createDotProductProgramInfoLoader=void 0;const n=e(7273),a=e(6757),l=e(5639),c=e(2150),f=e(1625);t.createDotProductProgramInfoLoader=(g,h,p,s)=>{const r=((u,d)=>({name:"ConvDotProduct",inputNames:u?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:u?[l.TextureType.unpacked,l.TextureType.packedLastDimension,l.TextureType.unpacked]:[l.TextureType.unpacked,l.TextureType.packedLastDimension],cacheKey:d.activationCacheKey}))(h.length>2,s);return Object.assign(Object.assign({},r),{get:()=>((u,d,m,b,y)=>{const w=m[0].dims,x=m[1].dims,_=[x[0],Math.ceil(w[1]*x[2]*x[3]/4)],v=(0,f.calculateIm2ColDims)(w,x,b),[E,I]=u.calculateTextureWidthAndHeight(_,l.TextureType.packedLastDimension),S=n.ShapeUtil.computeStrides(v),[T,A]=u.calculateTextureWidthAndHeight(v,l.TextureType.packedLastDimension),O=b.length,$=m.length<3?"0.0":"_B(b)",D=Math.ceil(w[1]*x[2]*x[3]/4),{activationFunction:M,applyActivation:F}=(0,c.getActivationSnippet)(y),C=(0,a.getGlsl)(u.session.backend.glContext.version),R=`
${M}
float process(int indices[${O}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${S[0]} + im2col[1] * ${S[1]} + im2col[2] * ${S[2]};
  int kernelOffset = indices[1] * ${_[1]};
  float value = ${$};
  for (int i = 0; i < ${D}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${T}, ${A});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${E}, ${I});
    value += dot(${C.texture2D}(Im2Col, im2colCoords), ${C.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${F}
  return value;
}`;return Object.assign(Object.assign({},d),{output:{dims:b,type:m[0].type,textureType:l.TextureType.unpacked},shaderSource:R})})(g,r,h,p,s)})}},4125:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseFlattenAttributes=t.flatten=void 0;const n=e(7273);t.flatten=(l,c,f)=>{a(c,f);const g=n.ShapeUtil.flattenShape(c[0].dims,f);return[l.reshapeUnpacked(c[0],g)]},t.parseFlattenAttributes=l=>l.attributes.getInt("axis",1);const a=(l,c)=>{if(!l||l.length!==1)throw new Error("Flatten requires 1 input.");const f=l[0].dims.length;if(f===0)throw new Error("scalar tensor is not supported.");if(c<-f||c>f)throw new Error("Invalid axis");if(l[0].type==="string")throw new Error("string tensor is not supported.")}},2150:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseInternalActivationAttributes=t.getActivationSnippet=void 0;const n=e(7273),a=e(9087);t.getActivationSnippet=function(l){let c;switch(l.activation){case"Relu":c=(0,a.glslRelu)();break;case"Sigmoid":c=(0,a.glslSigmoid)();break;case"Clip":c=(0,a.glslClip)(l.clipMin,l.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const f=c.name;return{activationFunction:c.body,applyActivation:`value = ${f}_(value);`}},t.parseInternalActivationAttributes=l=>{const c=l.getString("activation","");if(c==="Clip"){const[f,g]=l.getFloats("activation_params",[n.MIN_CLIP,n.MAX_CLIP]);return{activation:c,clipMax:g,clipMin:f,activationCacheKey:`${c}:${f},${g}`}}return{activation:c,activationCacheKey:c}}},6149:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseGatherAttributes=t.gather=void 0;const n=e(4910),a=e(6145),l=e(7273),c=e(5639);t.gather=(p,s,r)=>(h(s,r.axis),[p.run(g(p,s,r),s)]),t.parseGatherAttributes=p=>(0,n.createAttributeWithCacheKey)({axis:p.attributes.getInt("axis",0)});const f={name:"Gather",inputNames:["A","B"],inputTypes:[c.TextureType.unpacked,c.TextureType.unpacked]},g=(p,s,r)=>{const u=Object.assign(Object.assign({},f),{cacheHint:r.cacheKey});return Object.assign(Object.assign({},u),{get:()=>((d,m,b,y)=>{const w=b[0].dims.slice(),x=b[1].dims.slice(),_=new Array(w.length+x.length-1);y=l.ShapeUtil.normalizeAxis(y,w.length);const v=[];for(let I=0;I<_.length;I++)I<y?(_[I]=w[I],v.push(`inputIdx[${I}] = outputIdx[${I}];`)):I<y+x.length?(_[I]=x[I-y],v.push(`indexDataIdx[${I-y}] = outputIdx[${I}];`)):(_[I]=w[I-x.length+1],v.push(`inputIdx[${I-x.length+1}] = outputIdx[${I}];`));const E=`
      float process(int outputIdx[${_.length||1}]) {
        int inputIdx[${w.length}];
        int indexDataIdx[${x.length||1}];
        indexDataIdx[0] = 0;
        ${v.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${y}] = idx < 0 ? idx + ${w[y]} : idx;
        return _A(inputIdx);
      }`;return Object.assign(Object.assign({},m),{output:{dims:_,type:b[0].type,textureType:c.TextureType.unpacked},shaderSource:E})})(0,u,s,r.axis)})},h=(p,s)=>{if(!p||p.length!==2)throw new Error("Gather requires 2 inputs.");const r=p[0].dims.length;if(r<1)throw new Error("Invalid input shape.");if(s<-r||s>r-1)throw new Error("Invalid axis.");if(a.NUMBER_TYPES.indexOf(p[0].type)===-1)throw new Error("Invaid input type.");if(p[1].type!=="int32"&&p[1].type!=="int16")throw new Error("Invaid input type.")}},5378:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseGemmAttributesV11=t.parseGemmAttributesV7=t.gemm=void 0;const n=e(4910),a=e(7273),l=e(5639);t.gemm=(p,s,r)=>(h(s,r),[p.run(f(s,r),s)]);const c=(p,s)=>{const r=p.attributes.getInt("transA",0)!==0,u=p.attributes.getInt("transB",0)!==0,d=p.attributes.getFloat("alpha",1),m=p.attributes.getFloat("beta",1);return(0,n.createAttributeWithCacheKey)({transA:r,transB:u,alpha:d,beta:m,isOptionalC:s})};t.parseGemmAttributesV7=p=>c(p,!1),t.parseGemmAttributesV11=p=>c(p,!0);const f=(p,s)=>{const r={name:"Gemm",inputNames:p.length===3?["A","B","C"]:["A","B"],inputTypes:p.length===3?[l.TextureType.unpacked,l.TextureType.unpacked,l.TextureType.unpacked]:[l.TextureType.unpacked,l.TextureType.unpacked],key:s.cacheKey};return Object.assign(Object.assign({},r),{get:()=>g(r,p,s)})},g=(p,s,r)=>{const u=s[0].dims.slice(),d=s[1].dims.slice(),[m,b]=a.GemmUtil.getShapeOfGemmResult(u,r.transA,d,r.transB,s.length===3?s[2].dims:void 0),y=[m,b];if(!y)throw new Error("Can't use gemm on the given tensors");let w=u[u.length-1],x="";r.transA&&(w=u[0]),r.transA&&r.transB?x="value += _A_T(a) * _B_T(b);":r.transA&&!r.transB?x="value += _A_T(a) * _B(b);":!r.transA&&r.transB?x="value += _A(a) * _B_T(b);":r.transA||r.transB||(x="value += _A(a) * _B(b);");const _=y.length,v=`
      float process(int indices[${_}]) {
          int a[${_}];
          int b[${_}];
          ${s.length===3?`int c[${s[2].dims.length}];`:""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${s.length===3?"bcastIndices_C(indices, c);":""}

          float value = 0.0;
          for (int k=0; k<${w}; ++k) {
              a[${_-1}] = k;
              b[${_-2}] = k;
              ${x}
          }

          value = value * alpha;
          ${s.length===3?"value += beta * _C(c);":""}
          return value;
      }`;return Object.assign(Object.assign({},p),{output:{dims:y,type:s[0].type,textureType:l.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:r.alpha},{name:"beta",type:"float",data:r.beta}],shaderSource:v})},h=(p,s)=>{if(!p)throw new Error("Input is missing");if(s.isOptionalC&&(p.length<2||p.length>3))throw new Error("Invaid input shape.");if(!s.isOptionalC&&p.length!==3)throw new Error("Gemm requires 3 inputs");if(p.length===3&&p[2].dims.length!==1&&p[2].dims.length!==2)throw new Error("Invalid input shape of C");if(p[0].type!=="float32"&&p[0].type!=="float64"||p[1].type!=="float32"&&p[1].type!=="float64"||p.length===3&&p[2].type!=="float32"&&p[2].type!=="float64")throw new Error("Invalid input type.");if(p[0].type!==p[1].type||p.length===3&&p[0].type!==p[2].type)throw new Error("Input types are mismatched")}},5950:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedIm2ColProgramInfoLoader=void 0;const n=e(6757),a=e(5639),l=e(5614);t.createPackedIm2ColProgramInfoLoader=(c,f,g,h,p)=>{const s=(r=p.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[a.TextureType.packed],cacheHint:r});var r;return Object.assign(Object.assign({},s),{get:()=>((u,d,m,b,y,w)=>{const x=m.dims,_=b.dims,v=y.length,E=[_[1]*_[2]*_[3],y[2]*y[3]],I=_[2]*_[3],S=(0,l.unpackFromChannel)(),T=(0,n.getGlsl)(u.session.backend.glContext.version);let A="";for(let $=0;$<=1;$++)for(let D=0;D<=1;D++)A+=`
            blockIndex = rc.x + ${D};
            pos = rc.y + ${$};

            if(blockIndex < ${E[1]} && pos < ${E[0]}) {
              offsetY = int(blockIndex / (${y[v-1]})) * ${w.strides[0]} -
                ${w.pads[0]};
              d0 = offsetY + ${w.dilations[0]} * (imod(pos, ${I}) / ${_[2]});

              if(d0 < ${x[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${y[v-1]}) * ${w.strides[1]} -
                  ${w.pads[1]};
                d1 = offsetX + ${w.dilations[1]} * imod(imod(pos, ${I}), ${_[2]});

                if(d1 < ${x[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${I}.);
                    innerDims = vec2(d0, d1);
                    result[${2*$+D}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;const O=`
      ${S}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${A}
          ${T.output} = result;
      }
            `;return Object.assign(Object.assign({},d),{output:{dims:E,type:m.type,textureType:a.TextureType.packed},shaderSource:O,hasMain:!0})})(c,s,f,g,h,p)})}},1625:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.calculateIm2ColDims=t.createIm2ColProgramInfoLoader=void 0;const n=e(5639);t.createIm2ColProgramInfoLoader=(a,l,c,f,g)=>{const h=(p=g.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[n.TextureType.unpacked],cacheHint:p});var p;return Object.assign(Object.assign({},h),{get:()=>((s,r,u,d,m,b)=>{const y=u.dims,w=d.dims,x=m.length,_=(0,t.calculateIm2ColDims)(y,w,m,4),v=`
        const int XC = ${y[1]};
        const int XH = ${y[2]};
        const int XW = ${y[3]};
        const int KH = ${b.kernelShape[0]};
        const int KW = ${b.kernelShape[1]};
        const int dilationH = ${b.dilations[0]};
        const int dilationW = ${b.dilations[1]};
        const int strideH = ${b.strides[0]};
        const int strideW = ${b.strides[1]};
        const int padH = ${b.pads[0]};
        const int padW = ${b.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${x}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${y.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return Object.assign(Object.assign({},r),{output:{dims:_,type:u.type,textureType:n.TextureType.packedLastDimension},shaderSource:v})})(0,h,l,c,f,g)})},t.calculateIm2ColDims=(a,l,c,f=4)=>[c[0],c[2],c[3],Math.ceil(a[1]*l[2]*l[3]/f)]},6981:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseImageScalerAttributes=t.imageScaler=void 0;const n=e(4910),a=e(5639);t.imageScaler=(h,p,s)=>(g(p),[h.run(c(h,p,s),p)]),t.parseImageScalerAttributes=h=>{const p=h.attributes.getFloat("scale"),s=h.attributes.getFloats("bias");return(0,n.createAttributeWithCacheKey)({scale:p,bias:s})};const l={name:"ImageScaler",inputNames:["X"],inputTypes:[a.TextureType.unpacked]},c=(h,p,s)=>{const r=Object.assign(Object.assign({},l),{cacheHint:s.cacheKey});return Object.assign(Object.assign({},r),{get:()=>((u,d,m,b)=>{const y=m[0].dims.slice(),w=y.length,x=`
      ${f(b.bias.length)}
      float process(int indices[${w}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return Object.assign(Object.assign({},d),{output:{dims:y,type:m[0].type,textureType:a.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:b.bias.length,data:b.bias},{name:"scale",type:"float",data:b.scale}],shaderSource:x})})(0,r,p,s)})},f=h=>{const p=[`float getBias(float bias[${h}], int channel) {`];for(let s=0;s<h;++s)s===0?p.push(`	if (channel == ${s}) { return bias[${s}]; }`):s===h-1?p.push(`	else { return bias[${s}]; }`):p.push(`	else if (channel == ${s}) { return bias[${s}]; }`);return p.push("	}"),p.join(`
`)},g=h=>{if(!h||h.length!==1)throw new Error("ImageScaler requires 1 input.");if(h[0].dims.length!==4)throw new Error("Invalid input shape.");if(h[0].type!=="float32"&&h[0].type!=="float64")throw new Error("Invalid input type.")}},7413:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseInstanceNormalizationAttributes=t.instanceNormalization=void 0;const n=e(6757),a=e(5639);t.instanceNormalization=(p,s,r)=>{h(s);const u=p.run(c(s[0]),s);return[p.run(g(p,s[0],r,u.dims),[s[0],u,s[1],s[2]])]},t.parseInstanceNormalizationAttributes=p=>p.attributes.getFloat("epsilon",1e-5);const l={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[a.TextureType.unpacked]},c=p=>Object.assign(Object.assign({},l),{get:()=>((s,r)=>{const u=r.dims.slice(),d=u[1],m=u[2]*u[3],b=[u[0],d],y=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${u[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${u[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${m});
        temp = 0.0;
        for(int a2=0; a2<${u[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${u[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${m});

        return v;
      }`;return Object.assign(Object.assign({},s),{output:{dims:b,type:r.type,textureType:a.TextureType.packedLastDimension},shaderSource:y})})(l,p)}),f={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[a.TextureType.unpacked,a.TextureType.packedLastDimension,a.TextureType.unpacked,a.TextureType.unpacked]},g=(p,s,r,u)=>{const d=Object.assign(Object.assign({},f),{cacheHint:`${r}`});return Object.assign(Object.assign({},d),{get:()=>((m,b,y,w,x)=>{const _=(0,n.getGlsl)(m.session.backend.glContext.version),[v,E]=m.calculateTextureWidthAndHeight(x,a.TextureType.packedLastDimension),[I,S]=[v/4,E],T=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${I}, ${S});
        return ${_.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return Object.assign(Object.assign({},b),{output:{dims:y.dims,type:y.type,textureType:a.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:w}],shaderSource:T})})(p,d,s,r,u)})},h=p=>{if(!p||p.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");const s=p[0],r=p[1],u=p[2];if(s.dims.length<3||r.dims.length!==1||u.dims.length!==1)throw new Error("Invalid input shape.");if(r.dims[0]!==s.dims[1]||u.dims[0]!==s.dims[1])throw new Error("Input shapes are mismatched.");if(s.type!=="float32"&&s.type!=="float64"||r.type!=="float32"&&r.type!=="float64"||u.type!=="float32"&&u.type!=="float64")throw new Error("Invalid input type.");if(p[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}},7006:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createLrnProgramInfoLoader=t.parseLrnAttributes=t.lrn=void 0;const n=e(4910),a=e(5639);t.lrn=(g,h,p)=>(f(h),[g.run(c(h,p),h)]),t.parseLrnAttributes=g=>{const h=g.attributes.getFloat("alpha",1e-4),p=g.attributes.getFloat("beta",.75),s=g.attributes.getFloat("bias",1),r=g.attributes.getInt("size");return(0,n.createAttributeWithCacheKey)({alpha:h,beta:p,bias:s,size:r})};const l={name:"LRN",inputNames:["X"],inputTypes:[a.TextureType.unpacked]};function c(g,h){return Object.assign(Object.assign({},l),{cacheHint:h.cacheKey,get:()=>function(p,s){const r=p[0].dims[1],u=p[0].dims.length,d=-Math.floor((s.size-1)/2),m=Math.ceil((s.size-1)/2),b=`float(${s.alpha}) / float(${s.size})`,y=`
    float process(int indices[${u}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${d}; i <= ${m}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${r}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(float(${s.bias}) + ${b} * square_sum, float(${s.beta}));
    }`;return Object.assign(Object.assign({},l),{cacheHint:s.cacheKey,output:{dims:p[0].dims,type:p[0].type,textureType:a.TextureType.unpacked},shaderSource:y})}(g,h)})}t.createLrnProgramInfoLoader=c;const f=g=>{if(!g||g.length!==1)throw new Error("LRN requires 1 input.");if(g[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(g[0].type!=="float32")throw new Error("input should be float type")}},5632:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedMatmulProgramInfoLoader=void 0;const n=e(7273),a=e(6757),l=e(5639),c=e(432),f=e(2150),g=e(8276);t.createPackedMatmulProgramInfoLoader=(h,p,s)=>{const r=(u=p.length>2,d=s.activationCacheKey,{name:"MatMul (packed)",inputNames:u?["A","B","Bias"]:["A","B"],inputTypes:u?[l.TextureType.packed,l.TextureType.packed,l.TextureType.packed]:[l.TextureType.packed,l.TextureType.packed],cacheHint:d});var u,d;return Object.assign(Object.assign({},r),{get:()=>((m,b,y,w)=>{const x=y.length>2,_=x?"value += getBiasForMatmul();":"",v=y[0].dims,E=y[1].dims,I=n.BroadcastUtil.calcShape(v,E,!0),S=!n.ShapeUtil.areEqual(y[0].dims,y[1].dims);if(!I)throw new Error("Can't use matmul on the given tensors");const T=v[v.length-1],A=Math.ceil(T/2),O=v.length,$=E.length,D=(0,a.getGlsl)(m.session.backend.glContext.version),M=(0,c.getCoordsDataType)(I.length),F=I.length,C=(0,c.getGlChannels)(),{activationFunction:R,applyActivation:j}=(0,f.getActivationSnippet)(w),G=x?`${(0,g.getBiasForMatmul)(M,C,y[2].dims,I,!0)}`:"",W=S?`${function(Y,K,it,rt){let yt=[],ut=[];const St=it[0].dims,gt=it[1].dims,Ot=St.length,pt=gt.length,ct=rt.length,ot=ct-Ot,Mt=ct-pt;yt=St.map((_t,et)=>`coords.${K[et+ot]}`),yt[Ot-1]="i*2",yt.join(", "),ut=gt.map((_t,et)=>`coords.${K[et+Mt]}`),ut[pt-2]="i*2",ut.join(", ");const It=n.BroadcastUtil.getBroadcastDims(St,rt),Dt=n.BroadcastUtil.getBroadcastDims(gt,rt),H=It.map(_t=>`coords.${K[_t+ot]} = 0;`).join(`
`),ft=Dt.map(_t=>`coords.${K[_t+Mt]} = 0;`).join(`
`),xt=`int lastDim = coords.${K[ct-1]};
  coords.${K[ct-1]} = coords.${K[ct-2]};
  coords.${K[ct-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${Y} coords = getOutputCoords();
  ${xt}
  ${H}
  vec4 outputValue = getA(${yt});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${Y} coords = getOutputCoords();
  ${xt}
  ${ft}
  vec4 outputValue = getB(${ut});
  return outputValue;
}`}(M,C,y,I)}`:"",Z=S?"getAAtOutCoordsMatmul(i)":`getA(${function(Y,K){let it="";for(let rt=0;rt<K-2;rt++)it+=`rc.${Y[rt]}, `;return it+=`rc.${Y[K-2]}, i*2`,it}(C,O)})`,at=S?"getBAtOutCoordsMatmul(i)":`getB(${function(Y,K){let it="";for(let rt=0;rt<K-2;rt++)it+=`rc.${Y[rt]}, `;return it+=`i*2, rc.${Y[K-1]}`,it}(C,$)})`,J=`
            ${W}
            ${G}
            ${R}
            void main() {
              ${S?"":`${M} rc =
          getOutputCoords(); int lastDim = rc.${C[F-1]}; rc.${C[F-1]} =
          rc.${C[F-2]}; rc.${C[F-2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${A}; i++) {
                vec4 a = ${Z};
                vec4 b = ${at};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${_}
              ${j}
              ${D.output} = value;
            }`;return Object.assign(Object.assign({},b),{output:{dims:I,type:y[0].type,textureType:l.TextureType.packed},shaderSource:J,hasMain:!0})})(h,r,p,s)})}},8276:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.getBiasForMatmul=t.createMatmulProgramInfoLoader=t.parseMatMulAttributes=t.matMul=void 0;const n=e(7273),a=e(5639),l=e(432),c=e(2150),f=e(5632);t.matMul=(r,u,d)=>(p(u),r.session.pack?[r.run((0,f.createPackedMatmulProgramInfoLoader)(r,u,d),u)]:[r.run(h(u,d),u)]),t.parseMatMulAttributes=r=>(0,c.parseInternalActivationAttributes)(r.attributes);const g=(r,u)=>({name:"MatMul",inputNames:r?["A","B","Bias"]:["A","B"],inputTypes:r?[a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked]:[a.TextureType.unpacked,a.TextureType.unpacked],cacheHint:u});function h(r,u){const d=g(r.length>2,u.activationCacheKey);return Object.assign(Object.assign({},d),{get:()=>function(m,b,y){const w=b[0].dims,x=b[1].dims,_=n.BroadcastUtil.calcShape(w,x,!0);if(!_)throw new Error("Can't use matmul on the given tensors");const v=(0,l.getCoordsDataType)(_.length),E=(0,l.getGlChannels)(),{activationFunction:I,applyActivation:S}=(0,c.getActivationSnippet)(y),T=b.length>2,A=T?"value += getBiasForMatmul();":"",O=T?`${s(v,E,b[2].dims,_,!1)}`:"",$=_.length,D=w.length,M=x.length,F=`
    ${I}
    ${O}
    float process(int indices[${$}]) {
        int a[${D}];
        int b[${M}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${w[w.length-1]}; ++k) {
            a[${D-1}] = k;
            b[${M-2}] = k;
            value += _A(a) * _B(b);
        }
        ${A}
        ${S}
        return value;
    }`;return Object.assign(Object.assign({},m),{output:{dims:_,type:b[0].type,textureType:a.TextureType.unpacked},shaderSource:F})}(d,r,u)})}t.createMatmulProgramInfoLoader=h;const p=r=>{if(!r||r.length!==2)throw new Error("MatMul requires 2 inputs.");if(r[0].dims[r[0].dims.length-1]!==r[1].dims[r[1].dims.length-2])throw new Error("shared dimension does not match.");if(r[0].type!=="float32"&&r[0].type!=="float64"||r[1].type!=="float32"&&r[1].type!=="float64")throw new Error("inputs should be float type");if(r[0].type!==r[1].type)throw new Error("inputs types should match")};function s(r,u,d,m,b){let y="";const w=d.length,x=m.length,_=x-w;y=x<2&&w>0?"coords":d.map((I,S)=>`coords.${u[S+_]}`).join(", ");const v=n.BroadcastUtil.getBroadcastDims(d,m).map(I=>`coords.${u[I+_]} = 0;`).join(`
`);let E="vec4(outputValue.xx, outputValue.yy)";return n.ShapeUtil.size(d)===1&&(E="vec4(outputValue.x)"),b?`
vec4 getBiasForMatmul() {
  ${r} coords = getOutputCoords();
  ${v}
  vec4 outputValue = getBias(${y});
  return ${E};
}`:`
float getBiasForMatmul() {
  ${r} coords = getOutputCoords();
  ${v}
  return getBias(coords.x);
}`}t.getBiasForMatmul=s},9:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createPackProgramInfoLoader=void 0;const n=e(6757),a=e(5639),l=e(432),c=e(5614),f={name:"pack",inputNames:["A"],inputTypes:[a.TextureType.unpackedReversed]};t.createPackProgramInfoLoader=(g,h)=>Object.assign(Object.assign({},f),{get:()=>((p,s)=>{const r=(0,n.getGlsl)(p.session.backend.glContext.version),u=s.dims,d=u.length,m=s.dims.length,b=(0,l.getCoordsDataType)(m),y=(0,c.getChannels)("rc",m),w=(x=m,_=y,v=u[u.length-2],E=u[u.length-1],x===0||x===1?"":`
    int r = ${_[x-2]};
    int c = ${_[x-1]};
    int rp1 = ${_[x-2]} + 1;
    int cp1 = ${_[x-1]} + 1;
    bool rEdge = rp1 >= ${E};
    bool cEdge = cp1 >= ${v};
    `);var x,_,v,E;let I;I=d===0?[1,1]:d===1?[u[0],1]:[u[m-1],u[m-2]];const S=function(O,$,D){if(O===0)return"false";if(O===1)return`rc > ${$[0]}`;let M="";for(let F=O-2;F<O;F++)M+=`${D[F]} >= ${$[F-O+2]}`,F<O-1&&(M+="||");return M}(m,I,y),T=function(O,$){const D=O.length;if(D===0)return"getA(), 0, 0, 0";if(D===1)return`getA(rc),
            rc + 1 >= ${O[0]} ? 0. : getA(rc + 1),
            0, 0`;let M="";if(D>2)for(let F=0;F<D-2;++F)M+=`${$[F]},`;return`getA(${M}r, c),
          rEdge ? 0. : getA(${M}rp1, c),
          cEdge ? 0. : getA(${M}r, cp1),
          rEdge || cEdge ? 0. : getA(${M}rp1, cp1)`}(u,y),A=`
        void main() {
          ${b} rc = getOutputCoords();

          if(${S}) {
            ${r.output} = vec4(0);
          } else {
            ${w}

            ${r.output} = vec4(${T});
          }
        }
      `;return Object.assign(Object.assign({},f),{hasMain:!0,output:{dims:s.dims,type:s.type,textureType:a.TextureType.packed},shaderSource:A})})(g,h)})},5614:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.unpackFromChannel=t.getChannels=t.getVecChannels=void 0;const n=e(432);function a(l,c){return(0,n.getGlChannels)(c).map(f=>`${l}.${f}`)}t.getVecChannels=a,t.getChannels=function(l,c){return c===1?[l]:a(l,c)},t.unpackFromChannel=function(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}},5565:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parsePadAttributesV11=t.padV11=t.parsePadAttributesV2=t.padV2=void 0;const n=e(4910),a=e(7273),l=e(6757),c=e(5639),f={name:"Pad",inputNames:["A"],inputTypes:[c.TextureType.unpacked]};t.padV2=(b,y,w)=>(p(y),[b.run(Object.assign(Object.assign({},f),{cacheHint:w.cacheKey,get:()=>h(b,y[0],w)}),y)]),t.parsePadAttributesV2=b=>{const y=b.attributes.getString("mode","constant"),w=b.attributes.getFloat("value",0),x=b.attributes.getInts("pads");return(0,n.createAttributeWithCacheKey)({mode:y,value:w,pads:x})},t.padV11=(b,y,w)=>{s(y);const x=g(b,y,w);return(0,t.padV2)(b,[y[0]],x)},t.parsePadAttributesV11=b=>b.attributes.getString("mode","constant");const g=(b,y,w)=>{if(!b.session.isInitializer(y[1].dataId)||y.length>=3&&!b.session.isInitializer(y[2].dataId))throw new Error("dynamic pad attributes are not allowed");const x=Array.from(y[1].integerData),_=y.length>=3?y[2].floatData[0]:0;return(0,n.createAttributeWithCacheKey)({mode:w,pads:x,value:_})},h=(b,y,w)=>{const x=a.ShapeUtil.padShape(y.dims.slice(),w.pads),_=x.length,v=`
      ${r(b,y,w)}
      float process(int[${_}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[c.TextureType.unpacked],output:{dims:x,type:y.type,textureType:c.TextureType.unpacked},shaderSource:v}},p=b=>{if(!b||b.length!==1)throw new Error("Pad requires 1 input");if(b[0].type!=="float32"&&b[0].type!=="float64")throw new Error("Invalid input type.")},s=b=>{if(!b||b.length!==2&&b.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(b[1].type!=="int32")throw new Error("Invalid input type.");if(b.length>=3&&b[2].type==="string")throw new Error("Invalid input type.")},r=(b,y,w)=>{const x=(0,l.getGlsl)(b.session.backend.glContext.version),[_,v]=b.calculateTextureWidthAndHeight(y.dims,c.TextureType.unpacked),E=a.ShapeUtil.computeStrides(y.dims);switch(w.mode){case"constant":return u(x,y.dims,E,_,v,w.pads,w.value);case"reflect":return d(x,y.dims,E,_,v,w.pads);case"edge":return m(x,y.dims,E,_,v,w.pads);default:throw new Error("Invalid mode")}},u=(b,y,w,x,_,v,E)=>{const I=y.length;let S="";for(let T=I-1;T>=0;--T)S+=`
        k = m[${T}] - ${v[T]};
        if (k < 0)  return constant;
        if (k >= ${y[T]}) return constant;
        offset += k * ${w[T]};
        `;return`
      float padA(int m[${I}]) {
        const float constant = float(${E});
        int offset = 0;
        int k = 0;
        ${S}
        vec2 coords = offsetToCoords(offset, ${x}, ${_});
        float value = getColorAsFloat(${b.texture2D}(A, coords));
        return value;
      }
      `},d=(b,y,w,x,_,v)=>{const E=y.length;let I="";for(let S=E-1;S>=0;--S)I+=`
        k = m[${S}] - ${v[S]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(y[S]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${y[S]}) { k = _2n_1 - k; }
        }
        offset += k * ${w[S]};
        `;return`
      float padA(int m[${E}]) {
        int offset = 0;
        int k = 0;
        ${I}
        vec2 coords = offsetToCoords(offset, ${x}, ${_});
        float value = getColorAsFloat(${b.texture2D}(A, coords));
        return value;
      }
      `},m=(b,y,w,x,_,v)=>{const E=y.length;let I="";for(let S=E-1;S>=0;--S)I+=`
        k = m[${S}] - ${v[S]};
        if (k < 0)  k = 0;
        if (k >= ${y[S]}) k = ${y[S]-1};
        offset += k * ${w[S]};
      `;return`
      float padA(int m[${E}]) {
        int offset = 0;
        int k = 0;
        ${I}
        vec2 coords = offsetToCoords(offset, ${x}, ${_});
        float value = getColorAsFloat(${b.texture2D}(A, coords));
        return value;
      }
      `}},2834:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.globalMaxPool=t.parseMaxPoolAttributes=t.maxPool=t.parseGlobalAveragePoolAttributes=t.globalAveragePool=t.parseAveragePoolAttributes=t.averagePool=void 0;const n=e(4910),a=e(7273),l=e(5639);t.averagePool=(m,b,y)=>{s(b);const w={name:"AveragePool",inputNames:["X"],inputTypes:[l.TextureType.unpacked],cacheHint:y.cacheKey};return[m.run(Object.assign(Object.assign({},w),{get:()=>c(b,w,!1,y)}),b)]},t.parseAveragePoolAttributes=m=>{const b=m.attributes.getString("auto_pad","NOTSET"),y=m.attributes.getInt("ceil_mode",0),w=m.attributes.getInt("count_include_pad",0)!==0,x=m.attributes.getInts("kernel_shape"),_=m.attributes.getInts("strides",[]),v=m.attributes.getInts("pads",[]);if(y!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,n.createAttributeWithCacheKey)({autoPad:b,ceilMode:y,countIncludePad:w,kernelShape:x,strides:_,pads:v})};const c=(m,b,y,w)=>{const[x,_]=g(m,w,y),v=a.ShapeUtil.size(x.kernelShape);let E="";x.countIncludePad?E+=`value /= float(${v});`:E+=`value /= float(${v} - pad);`;const I=`
        ${r(m[0].dims,x,"value += _X(x);",E,"0.0")}
      `;return Object.assign(Object.assign({},b),{output:{dims:_,type:m[0].type,textureType:l.TextureType.unpacked},shaderSource:I})};t.globalAveragePool=(m,b,y)=>{s(b);const w={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[l.TextureType.unpacked],cacheHint:`${y.countIncludePad}`};return[m.run(Object.assign(Object.assign({},w),{get:()=>c(b,w,!0,y)}),b)]},t.parseGlobalAveragePoolAttributes=m=>{const b=m.attributes.getInt("count_include_pad",0)!==0;return(0,n.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:b,kernelShape:[],strides:[],pads:[]})},t.maxPool=(m,b,y)=>{s(b);const w={name:"MaxPool",inputNames:["X"],inputTypes:[l.TextureType.unpacked],cacheHint:y.cacheKey};return[m.run(Object.assign(Object.assign({},w),{get:()=>f(b,w,!1,y)}),b)]},t.parseMaxPoolAttributes=m=>{const b=m.attributes.getString("auto_pad","NOTSET"),y=m.attributes.getInt("ceil_mode",0),w=m.attributes.getInts("kernel_shape"),x=m.attributes.getInts("strides",[]),_=m.attributes.getInts("pads",[]),v=m.attributes.getInt("storage_order",0),E=m.attributes.getInts("dilations",[]);if(v!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(y!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,n.createAttributeWithCacheKey)({autoPad:b,ceilMode:y,countIncludePad:!1,kernelShape:w,strides:x,pads:_,storageOrder:v,dilations:E})};const f=(m,b,y,w)=>{const[x,_]=g(m,w,y),v=`
      ${r(m[0].dims,x,`
      value = max(_X(x), value);
    `,"","-1e5")}
    `;return Object.assign(Object.assign({},b),{output:{dims:_,type:m[0].type,textureType:l.TextureType.unpacked},shaderSource:v})},g=(m,b,y)=>{const w=m[0].dims.slice(),x=Object.hasOwnProperty.call(b,"dilations"),_=b.kernelShape.slice(),v=b.strides.slice(),E=x?b.dilations.slice():[],I=b.pads.slice();a.PoolConvUtil.adjustPoolAttributes(y,w,_,v,E,I);const S=a.PoolConvUtil.computePoolOutputShape(y,w,v,E,_,I,b.autoPad),T=Object.assign({},b);return x?Object.assign(T,{kernelShape:_,strides:v,pads:I,dilations:E,cacheKey:b.cacheKey}):Object.assign(T,{kernelShape:_,strides:v,pads:I,cacheKey:b.cacheKey}),[T,S]},h={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},p={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[l.TextureType.unpacked]};t.globalMaxPool=(m,b)=>(s(b),[m.run(Object.assign(Object.assign({},p),{get:()=>f(b,p,!0,h)}),b)]);const s=m=>{if(!m||m.length!==1)throw new Error("Pool ops requires 1 input.");if(m[0].type!=="float32"&&m[0].type!=="float64")throw new Error("Invalid input type.")},r=(m,b,y,w,x)=>{const _=m.length;if(b.kernelShape.length<=2){const v=b.kernelShape[b.kernelShape.length-1],E=b.strides[b.strides.length-1],I=b.pads[b.pads.length/2-1],S=b.pads[b.pads.length-1],T=m[_-1];let A="",O="",$="";if(A=I+S!==0?`
          for (int i = 0; i < ${v}; i++) {
            x[${_} - 1] = indices[${_} - 1] * ${E} - ${I} + i;
            if (x[${_} - 1] < 0 || x[${_} - 1] >= ${T}) {
              pad++;
              continue;
            }
            ${y}
          }`:`
          for (int i = 0; i < ${v}; i++) {
            x[${_} - 1] = indices[${_} - 1] * ${E} - ${I} + i;
            ${y}
          }`,b.kernelShape.length===2){const D=b.kernelShape[b.kernelShape.length-2],M=b.strides[b.strides.length-2],F=b.pads[b.pads.length/2-2],C=b.pads[b.pads.length-2],R=m[_-2];O=F+C!==0?`
            for (int j = 0; j < ${D}; j++) {
              x[${_} - 2] = indices[${_} - 2] * ${M} - ${F} + j;
              if (x[${_} - 2] < 0 || x[${_} - 2] >= ${R}) {
                pad+= ${v};
                continue;
              }
          `:`
            for (int j = 0; j < ${D}; j++) {
              x[${_} - 2] = indices[${_} - 2] * ${M} - ${F} + j;
            `,$=`
          }
        `}return`
        float process(int indices[${_}]) {
          int x[${_}];
          copyVec(indices, x);

          float value = ${x};
          int pad = 0;
          ${O}
          ${A}
          ${$}
          ${w}
          return value;
        }
      `}{const v=a.ShapeUtil.size(b.kernelShape),E=a.ShapeUtil.computeStrides(b.kernelShape),I=E.length,S=b.pads.length,T=d(I),A=u(m,"inputDims"),O=u(b.pads,"pads"),$=u(E,"kernelStrides"),D=u(b.strides,"strides");let M="";return M=b.pads.reduce((F,C)=>F+C)?`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${y}
          }`:`
          }
          ${y}
        `,`
        ${T}
        float process(int indices[${_}]) {
          int x[${_}];
          copyVec(indices, x);
          int offset[${I}];
          int pads[${S}];
          int inputDims[${_}];
          int kernelStrides[${I}];
          int strides[${I}];
          ${O}
          ${A}
          ${D}
          ${$}

          float value = ${x};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${v}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${_} - ${I}; j < ${_}; j++) {
              x[j] = indices[j] * strides[j - ${_} + ${I}]
                + offset[j - ${_} + ${I}] - pads[j - 2];
              ${M}
          }
          ${w}

          return value;
        }
      `}},u=(m,b)=>{let y="";for(let w=0;w<m.length;w++)y+=`
      ${b}[${w}] = ${m[w]};
    `;return y},d=m=>`
  void offsetToIndices(int offset, int[${m}] strides, out int[${m}] indices) {
    if (${m} == 0) {
      return;
    }
    for (int i = 0; i < ${m} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${m} - 1] = offset;
  }`},1010:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.reduceLogSumSquare=t.reduceLogSum=t.reduceProd=t.reduceMin=t.reduceMax=t.reduceMean=t.reduceSum=t.parseReduceAttributes=void 0;const n=e(4910),a=e(6145),l=e(7273),c=e(5639),f=(p,s,r,u,d)=>{h(s);const m={name:u,inputNames:["A"],inputTypes:[c.TextureType.unpacked]};return[p.run(Object.assign(Object.assign({},m),{cacheHint:r.cacheKey,get:()=>g(p,s,r,u,d,m)}),s)]};t.parseReduceAttributes=p=>{const s=p.attributes.getInts("axes",[]),r=p.attributes.getInt("keepdims",1)===1;return(0,n.createAttributeWithCacheKey)({axes:s,keepDims:r})};const g=(p,s,r,u,d,m)=>{const b=[],y=s[0].dims.length||1,w=[],x=l.ShapeUtil.normalizeAxes(r.axes,s[0].dims.length),_=d(s,x);let v=_[1];for(let I=0;I<s[0].dims.length;I++)x.indexOf(I)>=0||x.length===0?(r.keepDims&&b.push(1),v=`
          for(int j${I} = 0; j${I} < ${s[0].dims[I]}; j${I}++) {
            inputIdx[${I}] = j${I};
            ${v}
          }`):(w.push(`inputIdx[${I}] = outputIdx[${b.length}];`),b.push(s[0].dims[I]));const E=`
      float process(int outputIdx[${b.length||1}]) {
        float value;                 // final result
        int inputIdx[${y}];      // addressing input data
        ${w.join(`
`)}
        ${_[0]}       // init ops for reduce max/min
        ${v}
        ${_[2]}       // final computation for reduce mean
        return value;
      }`;return Object.assign(Object.assign({},m),{output:{dims:b,type:s[0].type,textureType:c.TextureType.unpacked},shaderSource:E})},h=p=>{if(!p||p.length!==1)throw new Error("Reduce op requires 1 input.");if(a.NUMBER_TYPES.indexOf(p[0].type)===-1)throw new Error("Invalid input type.")};t.reduceSum=(p,s,r)=>f(p,s,r,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),t.reduceMean=(p,s,r)=>f(p,s,r,"ReduceMean",(u,d)=>{let m=1;for(let b=0;b<u[0].dims.length;b++)(d.indexOf(b)>=0||d.length===0)&&(m*=u[0].dims[b]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${m}.;`]}),t.reduceMax=(p,s,r)=>f(p,s,r,"ReduceMax",(u,d)=>{const m=[];for(let b=0;b<u[0].dims.length;b++)(d.indexOf(b)>=0||d.length===0)&&m.push(`inputIdx[${b}] = 0;`);return[`${m.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),t.reduceMin=(p,s,r)=>f(p,s,r,"ReduceMin",(u,d)=>{const m=[];for(let b=0;b<u[0].dims.length;b++)(d.indexOf(b)>=0||d.length===0)&&m.push(`inputIdx[${b}] = 0;`);return[`${m.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),t.reduceProd=(p,s,r)=>f(p,s,r,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),t.reduceLogSum=(p,s,r)=>f(p,s,r,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),t.reduceLogSumSquare=(p,s,r)=>f(p,s,r,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])},7379:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.isReshapeCheap=t.processDims3D=t.createPackedReshape3DProgramInfoLoader=void 0;const n=e(7273),a=e(6757),l=e(5639),c=e(5614);t.createPackedReshape3DProgramInfoLoader=(f,g,h)=>{const p=(s=>({name:"Reshape (packed)",inputTypes:[l.TextureType.packed],inputNames:["A"],cacheHint:`${s}`}))(h);return Object.assign(Object.assign({},p),{get:()=>((s,r,u,d)=>{const m=r.dims,b=d;let y="";for(let _=0;_<4;_++){let v="";switch(_){case 0:v="outputCoords = rc;";break;case 1:v="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:v="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:v="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}y+=`
        ${v}
        ${_>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${_}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${_>0?"}":""}
      `}const w=(0,a.getGlsl)(s.session.backend.glContext.version),x=`
      ${function(_){const v=n.ShapeUtil.computeStrides(_),E=["b","r","c"],I="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${v.map((S,T)=>`int ${E[T]} = ${I} / ${S}; ${T===v.length-1?`int ${E[T+1]} = ${I} - ${E[T]} * ${S}`:`index -= ${E[T]} * ${S}`};`).join("")}
      return ivec3(b, r, c);
    }
  `}(m)}
      ${function(_){const v=n.ShapeUtil.computeStrides(_);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${v[0]} + coords.z * ${v[1]} + coords.y;
  }
`}(b)}
      ${(0,c.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${b[2]};
        int cols = ${b[1]};

        ${y}
        ${w.output} = result;
      }
    `;return Object.assign(Object.assign({},u),{output:{dims:b,type:r.type,textureType:l.TextureType.packed},shaderSource:x,hasMain:!0})})(f,g,p,h)})},t.processDims3D=function(f){if(f.length===0)return[1,1,1];let g=1;for(let h=0;h<f.length-2;++h)g*=f[h];return[g,f.length>1?f[f.length-2]:1,f[f.length-1]]},t.isReshapeCheap=function(f,g){let h=!1;return h=f.length===0||g.length===0||(f.length<2||g.length<2?f[f.length-1]===g[g.length-1]:f[f.length-1]===g[g.length-1]&&f[f.length-2]===g[g.length-2]),h}},8126:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.reshape=void 0;const n=e(7273);t.reshape=(a,l)=>{const c=n.ShapeUtil.calculateReshapedDims(l[0].dims,l[1].integerData);return a.session.pack?[a.reshapePacked(l[0],c)]:[a.reshapeUnpacked(l[0],c)]}},2801:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseResizeAttributesV11=t.parseResizeAttributesV10=t.resize=void 0;const n=e(6757),a=e(5639),l=e(432),c=e(5614),f=e(3980),g={name:"Resize",inputNames:["A"],inputTypes:[a.TextureType.packed]};t.resize=(u,d,m)=>((0,f.validateInputs)(d,m),[u.run(Object.assign(Object.assign({},g),{cacheHint:m.cacheKey,get:()=>h(u,d,m)}),d)]),t.parseResizeAttributesV10=u=>(0,f.parseUpsampleAttributes)(u,10),t.parseResizeAttributesV11=u=>(0,f.parseUpsampleAttributes)(u,11);const h=(u,d,m)=>{const b=(0,n.getGlsl)(u.session.backend.glContext.version),[y,w]=p(d,m);if(y.every(M=>M===1)&&m.coordinateTransformMode!=="tf_crop_and_resize")return Object.assign(Object.assign({},g),{output:{dims:w,type:d[0].type,textureType:a.TextureType.packed},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${b.texture2D}(X, TexCoords);
                    ${b.output} = v;
                }`});const x=w.length;if(x<2)throw new Error(`output dimension should be at least 2, but got ${x}`);const _=w[x-2],v=w[x-1],E=d[0].dims;if(x!==E.length)throw new Error(`output dimension should match input ${E.length}, but got ${x}`);const I=E[x-2],S=E[x-1],T=y[x-2],A=y[x-1];let O="";if(m.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${m.mode}'`);switch(m.coordinateTransformMode){case"asymmetric":O=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":O=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":O=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${v}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${_}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${v}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${_}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":O=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${v}.0 - 1.0, ${_}.0 - 1.0, ${v}.0 - 1.0,
                            ${_}.0 - 1.0);
                        vec4 original = vec4(${S}.0 - 1.0, ${I}.0 - 1.0, ${S}.0 - 1.0,
                            ${I}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${m.coordinateTransformMode}'`)}const $=(0,l.getCoordsDataType)(x),D=`
            const vec2 inputWH = vec2(${I}.0, ${S}.0);
            const vec4 scaleWHWH = vec4(float(${T}), float(${A}), float(${T}), float(${A}));
            ${(0,c.unpackFromChannel)()}
            ${O}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${$} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${_-1};
                bool hasNextCol = rc.z < ${v-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${b.output} = vec4(newValue);
            }
        `;return Object.assign(Object.assign({},g),{output:{dims:w,type:d[0].type,textureType:a.TextureType.packed},hasMain:!0,shaderSource:D})},p=(u,d)=>{const m=u[0].dims;let b,y=d.scales;if(y.length===0){const x=u[d.scalesInputIdx];if(x&&x.size!==0){if(u[d.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");y=s(x,d.mode,d.isResize)}else{const _=u[d.sizesInputIdx];if(!_||_.size===0)throw new Error("Either scales or sizes MUST be provided as input.");b=Array.from(_.integerData),y=r(b,m,d.mode,d.isResize)}}else if(u[d.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const w=b||m.map((x,_)=>Math.floor(x*y[_]));return[y,w]},s=(u,d,m)=>{const b=Array.from(u.floatData);return(0,f.scalesValidation)(b,d,m),b},r=(u,d,m,b)=>{const y=d.length,w=new Array(y);for(let x=0,_=y;x<_;x++)if(d[x]===0){if(u[x]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");w[x]=1}else w[x]=u[x]/d[x];return(0,f.scalesValidation)(w,m,b),w}},565:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.shape=void 0;const n=e(9240);t.shape=(l,c)=>(a(c),[new n.Tensor([c[0].dims.length],"int32",void 0,void 0,new Int32Array(c[0].dims))]);const a=l=>{if(!l||l.length!==1)throw new Error("Shape requires 1 input.")}},2444:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.sliceV10=t.parseSliceAttributes=t.slice=void 0;const n=e(4910),a=e(6145),l=e(7273),c=e(5639),f={name:"Slice",inputNames:["A"],inputTypes:[c.TextureType.unpacked]};t.slice=(r,u,d)=>(h(u),[r.run(Object.assign(Object.assign({},f),{cacheHint:d.cacheKey,get:()=>g(r,u[0],d)}),u)]),t.parseSliceAttributes=r=>{const u=r.attributes.getInts("starts"),d=r.attributes.getInts("ends"),m=r.attributes.getInts("axes",[]);return(0,n.createAttributeWithCacheKey)({starts:u,ends:d,axes:m})};const g=(r,u,d)=>{const m=d.axes.length===0?u.dims.slice(0).map((E,I)=>I):d.axes,b=l.ShapeUtil.normalizeAxes(m,u.dims.length),y=d.starts.map((E,I)=>E>u.dims[b[I]]-1?u.dims[b[I]]:l.ShapeUtil.normalizeAxis(E,u.dims[b[I]])),w=d.ends.map((E,I)=>E>u.dims[b[I]]-1?u.dims[b[I]]:l.ShapeUtil.normalizeAxis(E,u.dims[b[I]])),x=u.dims.slice(),_=[];for(let E=0;E<b.length;E++)x[b[E]]=w[E]-y[E],y[E]>0&&_.push(`outputIdx[${b[E]}] += ${y[E]};`);const v=`
      float process(int outputIdx[${x.length}]) {
        ${_.join(`
      `)}
        return _A(outputIdx);
      }`;return Object.assign(Object.assign({},f),{output:{dims:x,type:u.type,textureType:c.TextureType.unpacked},shaderSource:v})},h=r=>{if(!r||r.length!==1)throw new Error("Slice requires 1 input.");if(a.NUMBER_TYPES.indexOf(r[0].type)===-1)throw new Error("Invalid input type.")};t.sliceV10=(r,u)=>{s(u);const d=p(r,u);return[r.run(Object.assign(Object.assign({},f),{cacheHint:d.cacheKey,get:()=>g(r,u[0],d)}),[u[0]])]};const p=(r,u)=>{if(!r.session.isInitializer(u[1].dataId)||!r.session.isInitializer(u[2].dataId)||u.length>=4&&!r.session.isInitializer(u[3].dataId)||u.length>=5&&!r.session.isInitializer(u[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(u.length>=5&&u[4].integerData.some(y=>y!==1))throw new Error("currently non-1 steps is not supported for Slice");const d=Array.from(u[1].integerData),m=Array.from(u[2].integerData),b=u.length>=4?Array.from(u[3].integerData):[];return{starts:d,ends:m,axes:b,cacheKey:`${b};${d};${m}`}},s=r=>{if(!r||r.length<3||r.length>5)throw new Error("Invalid input number.");if(r[1].type!=="int32"||r[1].dims.length!==1)throw new Error("Invalid input type.");if(r[2].type!=="int32"||r[2].dims.length!==1)throw new Error("Invalid input type.");if(r.length>=4&&(r[3].type!=="int32"||r[3].dims.length!==1))throw new Error("Invalid input type.");if(r.length>=5&&(r[4].type!=="int32"||r[4].dims.length!==1))throw new Error("Invalid input type.")}},815:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.softmaxV13=t.parseSoftmaxAttributesV13=t.parseSoftmaxAttributes=t.softmax=void 0;const n=e(4910),a=e(7273),l=e(6757),c=e(5639),f=e(5707),g={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[c.TextureType.unpacked]},h={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[c.TextureType.unpacked,c.TextureType.unpacked]},p={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[c.TextureType.unpacked,c.TextureType.unpacked,c.TextureType.unpacked]};t.softmax=(b,y,w)=>{m(y);const x=y[0].dims.slice(),_=a.ShapeUtil.normalizeAxis(w.axis,x.length),v=a.ShapeUtil.sizeToDimension(x,_),E=a.ShapeUtil.sizeFromDimension(x,_);return s(b,y,w,v,E)},t.parseSoftmaxAttributes=b=>(0,n.createAttributeWithCacheKey)({axis:b.attributes.getInt("axis",1)}),t.parseSoftmaxAttributesV13=b=>(0,n.createAttributeWithCacheKey)({axis:b.attributes.getInt("axis",-1)}),t.softmaxV13=(b,y,w)=>{m(y);const x=y[0].dims.slice(),_=a.ShapeUtil.normalizeAxis(w.axis,x.length),v=x.length,E=_!==v-1,I=[];let S,T=[],A=[];E&&(T=Array.from({length:v}).map((M,F)=>F),T[_]=v-1,T[v-1]=_,T.map(M=>I.push(x[M])),S=(0,n.createAttributeWithCacheKey)({perm:T}),A=(0,f.transpose)(b,y,S));const O=E?a.ShapeUtil.sizeToDimension(I,v-1):a.ShapeUtil.sizeToDimension(x,v-1),$=E?a.ShapeUtil.sizeFromDimension(I,v-1):a.ShapeUtil.sizeFromDimension(x,v-1),D=s(b,E?A:y,w,O,$);return E?(0,f.transpose)(b,D,S):D};const s=(b,y,w,x,_)=>{const v=r(b,y[0],x,_,[x]),E=b.run(Object.assign(Object.assign({},g),{cacheHint:w.cacheKey,get:()=>v}),y),I=u(b,y[0],x,_,v.output.dims,[x]),S=b.run(Object.assign(Object.assign({},h),{cacheHint:w.cacheKey,get:()=>I}),[y[0],E]),T=d(b,y[0],x,_,v.output.dims,I.output.dims);return[b.run(Object.assign(Object.assign({},p),{cacheHint:w.cacheKey,get:()=>T}),[y[0],E,S])]},r=(b,y,w,x,_)=>{const[v,E]=b.calculateTextureWidthAndHeight(y.dims,c.TextureType.unpacked),I=_.length;if(w<1||x<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(_.length!==1)throw new Error("Dimensionality of the output should be 1");if(_[0]!==w)throw new Error("Shape of the output should be equal to logical row count");const S=(0,l.getGlsl)(b.session.backend.glContext.version),T=`
      float process(int[${I}] indices) {
        int logical_row_start_offset = indices[0] * ${x};

        float max = getColorAsFloat(${S.texture2D}(A, offsetToCoords(logical_row_start_offset, ${v},
        ${E} )));
        for(int i=1; i<${x}; ++i)
        {
          float current = getColorAsFloat(${S.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${v}, ${E})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return Object.assign(Object.assign({},g),{output:{dims:_,type:y.type,textureType:c.TextureType.unpacked},shaderSource:T})},u=(b,y,w,x,_,v)=>{const[E,I]=b.calculateTextureWidthAndHeight(y.dims,c.TextureType.unpacked),S=v.length;if(w<1||x<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(v.length!==1)throw new Error("Dimensionality of the output should be 1");if(v[0]!==w)throw new Error("Shape of the output should be equal to logical row count");if(_.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(_[0]!==w)throw new Error("Shape of the intermediate results should be equal to logical row count");const T=`
      float process(int[${S}] indices) {
        int logical_row_start_offset = indices[0] * ${x};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${x}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0,l.getGlsl)(b.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${E}, ${I}))) - max);
        }

        return norm_factor;
      }`;return Object.assign(Object.assign({},h),{output:{dims:v,type:y.type,textureType:c.TextureType.unpacked},shaderSource:T})},d=(b,y,w,x,_,v)=>{const[E,I]=b.calculateTextureWidthAndHeight(y.dims,c.TextureType.unpacked),S=y.dims.length;if(w<1||x<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(_.length!==1||v.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(_[0]!==w||v[0]!==w)throw new Error("Shape of the intermediate results should be equal to logical row count");const T=`
      float process(int[${S}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${E}, ${I});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${x};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return Object.assign(Object.assign({},p),{output:{dims:y.dims,type:y.type,textureType:c.TextureType.unpacked},shaderSource:T})},m=b=>{if(!b||b.length!==1)throw new Error("Softmax requires 1 input.");if(b[0].type!=="float32"&&b[0].type!=="float64")throw new Error("Invalid input type")}},564:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseSplitAttributes=t.split=void 0;const n=e(4910),a=e(7273),l=e(5639),c={name:"Split",inputNames:["A"],inputTypes:[l.TextureType.unpacked]};t.split=(p,s,r)=>{h(s);const u=a.ShapeUtil.normalizeAxis(r.axis,s[0].dims.length),d=f(p,s,u,r),m=[];for(let b=0;b<d;++b)m.push(p.run(Object.assign(Object.assign({},c),{cacheHint:`${r.cacheKey};${b}`,get:()=>g(p,s[0],r,u,b)}),s));return m},t.parseSplitAttributes=p=>{const s=p.attributes.getInt("axis",0),r=p.attributes.getInts("split",[]),u=p.outputs.length;return(0,n.createAttributeWithCacheKey)({axis:s,split:r,numOutputs:u})};const f=(p,s,r,u)=>{const[,d]=a.SplitUtil.splitShape(s[0].dims,r,u.split,u.numOutputs);return d.length},g=(p,s,r,u,d)=>{const[m,b]=a.SplitUtil.splitShape(s.dims,u,r.split,r.numOutputs),y=b[d],w=m[d],x=`
      float process(int indices[${w.length}]) {
        indices[${u}] += ${y};
        return _A(indices);
      }
    `;return Object.assign(Object.assign({},c),{cacheHint:`${r.cacheKey}:${d}`,output:{dims:w,type:s.type,textureType:l.TextureType.unpacked},shaderSource:x})},h=p=>{if(!p||p.length!==1)throw new Error("Split requires one input.");if(p[0].type!=="int8"&&p[0].type!=="uint8"&&p[0].type!=="int16"&&p[0].type!=="uint16"&&p[0].type!=="int32"&&p[0].type!=="uint32"&&p[0].type!=="float32"&&p[0].type!=="float64"&&p[0].type!=="bool")throw new Error("Invalid input type.")}},5416:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseSqueezeAttributes=t.squeezeV13=t.squeeze=void 0;const n=e(7273);t.squeeze=(c,f,g)=>{a(f);const h=n.ShapeUtil.squeezeShape(f[0].dims,g);return[c.reshapeUnpacked(f[0],h)]},t.squeezeV13=(c,f)=>(l(f),(0,t.squeeze)(c,[f[0]],Array.from(f[1].integerData))),t.parseSqueezeAttributes=c=>c.attributes.getInts("axes");const a=c=>{if(!c||c.length!==1)throw new Error("Squeeze requires 1 input.");if(c[0].type==="string")throw new Error("invalid input tensor types.")},l=c=>{if(!c||c.length!==2)throw new Error("Squeeze requires 2 inputs.");if(c[1].type!=="int32")throw new Error("Invalid input type.")}},1240:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.sum=void 0;const n=e(6757),a=e(5639);t.sum=(f,g)=>{c(g);const h={name:"Sum",inputNames:g.map((p,s)=>`X${s}`),inputTypes:new Array(g.length).fill(a.TextureType.unpacked)};return[f.run(Object.assign(Object.assign({},h),{get:()=>l(f,g,h)}),g)]};const l=(f,g,h)=>{const p=(0,n.getGlsl)(f.session.backend.glContext.version),s=g[0].dims.slice(),r=`
      void main() {
        vec4 result = ${g.map((u,d)=>`${p.texture2D}(X${d},TexCoords)`).join(" + ")};
        ${p.output} = result;
      }
    `;return Object.assign(Object.assign({},h),{output:{dims:s,type:g[0].type,textureType:a.TextureType.unpacked},hasMain:!0,shaderSource:r})},c=f=>{if(!f||f.length===0)throw new Error("Sum requires inputs.");const g=f[0].dims.length;for(let h=1;h<f.length;h++){if(g!==f[h].dims.length)throw new Error("Input shapes are mismatched.");for(let p=0;p<g;p++)if(f[0].dims[p]!==f[h].dims[p])throw new Error("Input shapes are not matched.")}if(f[0].type!=="float32"&&f[0].type!=="float64")throw new Error("Invalid input type.");for(let h=1;h<f.length;h++)if(f[0].type!==f[h].type)throw new Error("Input types are not matched.")}},5944:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.tile=void 0;const n=e(6145),a=e(5639);t.tile=(f,g)=>{c(g);const h={name:"Tile",inputNames:["A"],inputTypes:[a.TextureType.unpacked]};return[f.run(Object.assign(Object.assign({},h),{get:()=>l(f,g,h)}),g)]};const l=(f,g,h)=>{const p=g[0].dims.slice(),s=new Array(p.length),r=[];for(let m=0;m<p.length;m++)s[m]=p[m]*g[1].numberData[m],r.push(`inputIdx[${m}] = int(mod(float(outputIdx[${m}]), ${p[m]}.));`);const u=s.length,d=`
      float process(int outputIdx[${u}]) {
        int inputIdx[${u}];
        ${r.join(`
`)}
        return _A(inputIdx);
      }
    `;return Object.assign(Object.assign({},h),{output:{dims:s,type:g[0].type,textureType:a.TextureType.unpacked},shaderSource:d})},c=f=>{if(!f||f.length!==2)throw new Error("Tile requires 2 input.");if(f[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(f[1].dims[0]!==f[0].dims.length)throw new Error("Invalid input shape.");if(n.NUMBER_TYPES.indexOf(f[0].type)===-1)throw new Error("Invalid input type.");if(f[1].type!=="int32"&&f[1].type!=="int16")throw new Error("Invalid repeat type.")}},5707:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseTransposeAttributes=t.transpose=void 0;const n=e(4910),a=e(7273),l=e(5639),c={name:"Transpose",inputNames:["A"],inputTypes:[l.TextureType.unpacked]};t.transpose=(r,u,d)=>(s(u),[r.run(Object.assign(Object.assign({},c),{cacheHint:d.cacheKey,get:()=>f(r,u[0],d.perm)}),u)]),t.parseTransposeAttributes=r=>(0,n.createAttributeWithCacheKey)({perm:r.attributes.getInts("perm",[])});const f=(r,u,d)=>{const m=u.dims;d=g(m,d);const b=h(m,d),y=m.length,w=`
      ${p("perm",d,y)}
      float process(int indices[${y}]) {
        int a[${y}];
        perm(a, indices);
        return _A(a);
      }`;return Object.assign(Object.assign({},c),{output:{dims:b,type:u.type,textureType:l.TextureType.unpacked},shaderSource:w})},g=(r,u)=>(u&&u.length!==r.length&&(u=[...r.keys()].reverse()),u),h=(r,u)=>(u=g(r,u),a.ShapeUtil.sortBasedOnPerm(r,u)),p=(r,u,d)=>{const m=[];m.push(`void ${r}(out int a[${d}], int src[${d}]) {`);for(let b=0;b<d;++b)m.push(`	a[${u[b]}]=src[${b}];`);return m.push("	}"),m.join(`
`)},s=r=>{if(!r||r.length!==1)throw new Error("Transpose requires 1 input.");if(r[0].type!=="float32"&&r[0].type!=="float64")throw new Error("input should be float tensor")}},2488:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.encodeAsUint8=void 0;const n=e(6757),a=e(5639);t.encodeAsUint8=(l,c)=>{const f=c.shape,g=(0,n.getGlsl)(l.session.backend.glContext.version),h=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${g.texture2D}(X,TexCoords).r;
      ${g.output} = encodeAsUint8(value);
    }`,p={name:"Uint8Encode",inputTypes:[a.TextureType.unpacked],inputNames:["X"],output:{dims:f,type:c.tensor.type,textureType:a.TextureType.downloadUint8AsFloat},shaderSource:h,hasMain:!0};return l.executeProgram(p,[c.tensor])}},9087:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.tanh=t.tan=t.sqrt=t.sin=t.sigmoid=t.relu=t.not=t.neg=t.log=t.parseLeakyReluAttributes=t.leakyRelu=t.identity=t.floor=t.exp=t.parseEluAttributes=t.elu=t.cos=t.ceil=t.clipV11=t.parseClipAttributes=t.clip=t.atan=t.asin=t.acos=t.abs=t.glslTanh=t.glslTan=t.glslSqrt=t.glslSigmoid=t.glslRelu=t.glslSin=t.glslNot=t.glslNeg=t.glslLog=t.glslLeakyRelu=t.glslIdentity=t.glslClip=t.glslFloor=t.glslExp=t.glslElu=t.glslCos=t.glslCeil=t.glslAtan=t.glslAsin=t.glslAcos=t.glslAbs=void 0;const n=e(4910),a=e(7273),l=e(1997),c=e(6757),f=e(5639);function g(){return D("abs")}function h(){return D("acos")}function p(){return D("asin")}function s(){return D("atan")}function r(){return D("ceil")}function u(){return D("cos")}function d(C){const R="elu";return{body:`
  const float alpha = float(${C});

  float ${R}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${R}_(vec4 v) {
    return vec4(${R}_(v.x), ${R}_(v.y), ${R}_(v.z), ${R}_(v.w));
  }
  `,name:R,type:l.FunctionType.ValueBased}}function m(){return D("exp")}function b(){return D("floor")}function y(C,R){const j="clip";return{body:`
  const float min = float(${C});
  const float max = float(${R});

  float ${j}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${j}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:j,type:l.FunctionType.ValueBased}}function w(){const C="indentity";return{body:`
  float ${C}_(float a) {
    return a;
  }
  vec4 ${C}_(vec4 v) {
    return v;
  }
  `,name:C,type:l.FunctionType.ValueBased}}function x(C){const R="leakyRelu";return{body:`
  const float alpha = float(${C});

  float ${R}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${R}_(vec4 v) {
    return vec4(${R}_(v.x), ${R}_(v.y), ${R}_(v.z), ${R}_(v.w));
  }
  `,name:R,type:l.FunctionType.ValueBased}}function _(){return D("log")}function v(){const C="neg";return{body:`
  float ${C}_(float a) {
    return -a;
  }
  vec4 ${C}_(vec4 v) {
    return -v;
  }
  `,name:C,type:l.FunctionType.ValueBased}}function E(){const C="not";return{body:`
  float ${C}_(float a) {
    return float( ! bool(a) );
  }
  bool ${C}_(bool a) {
    return !a;
  }
  vec4 ${C}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${C}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:C,type:l.FunctionType.ValueBased}}function I(){return D("sin")}function S(){const C="relu";return{body:`
  float ${C}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${C}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:C,type:l.FunctionType.ValueBased}}function T(){const C="sigmoid";return{body:`
  float ${C}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${C}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:C,type:l.FunctionType.ValueBased}}function A(){return D("sqrt")}function O(){return D("tan")}function $(){const C="tanh";return{body:`
  float ${C}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${C}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:C,type:l.FunctionType.ValueBased}}function D(C){return{body:`
  float ${C}_(float a) {
    return ${C}(a);
  }
  vec4 ${C}_(vec4 v) {
    return ${C}(v);
  }
  `,name:C,type:l.FunctionType.ValueBased}}t.glslAbs=g,t.glslAcos=h,t.glslAsin=p,t.glslAtan=s,t.glslCeil=r,t.glslCos=u,t.glslElu=d,t.glslExp=m,t.glslFloor=b,t.glslClip=y,t.glslIdentity=w,t.glslLeakyRelu=x,t.glslLog=_,t.glslNeg=v,t.glslNot=E,t.glslSin=I,t.glslRelu=S,t.glslSigmoid=T,t.glslSqrt=A,t.glslTan=O,t.glslTanh=$;const M=(C,R,j,G)=>{const W=C.session.pack?f.TextureType.packed:f.TextureType.unpacked,Z={name:j.name,inputTypes:[W],inputNames:["A"],cacheHint:G};return Object.assign(Object.assign({},Z),{get:()=>((at,J,Y,K)=>{const it=at.session.pack?f.TextureType.packed:f.TextureType.unpacked,rt=(0,c.getGlsl)(at.session.backend.glContext.version);return Object.assign(Object.assign({},J),{output:{dims:Y.dims,type:Y.type,textureType:it},shaderSource:`
     ${K.body}
     void main() {
       vec4 v = ${rt.texture2D}(A, TexCoords);
       v = ${K.name}_(v);
       ${rt.output} = v;
     }
     `,hasMain:!0})})(C,Z,R,j)})};t.abs=(C,R)=>[C.run(M(C,R[0],g()),R)],t.acos=(C,R)=>[C.run(M(C,R[0],h()),R)],t.asin=(C,R)=>[C.run(M(C,R[0],p()),R)],t.atan=(C,R)=>[C.run(M(C,R[0],s()),R)],t.clip=(C,R,j)=>[C.run(M(C,R[0],y(j.min,j.max),j.cacheKey),R)],t.parseClipAttributes=C=>(0,n.createAttributeWithCacheKey)({min:C.attributes.getFloat("min",a.MIN_CLIP),max:C.attributes.getFloat("max",a.MAX_CLIP)}),t.clipV11=(C,R)=>{const j=F(C,R);return(0,t.clip)(C,[R[0]],j)};const F=(C,R)=>{if(R.length>=3&&(!C.session.isInitializer(R[1].dataId)||!C.session.isInitializer(R[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const j=R.length>=3?R[1].numberData[0]:a.MIN_CLIP,G=R.length>=3?R[2].numberData[0]:a.MAX_CLIP;return(0,n.createAttributeWithCacheKey)({min:j,max:G})};t.ceil=(C,R)=>[C.run(M(C,R[0],r()),R)],t.cos=(C,R)=>[C.run(M(C,R[0],u()),R)],t.elu=(C,R,j)=>[C.run(M(C,R[0],d(j.alpha),j.cacheKey),R)],t.parseEluAttributes=C=>(0,n.createAttributeWithCacheKey)({alpha:C.attributes.getFloat("alpha",1)}),t.exp=(C,R)=>[C.run(M(C,R[0],m()),R)],t.floor=(C,R)=>[C.run(M(C,R[0],b()),R)],t.identity=(C,R)=>[C.run(M(C,R[0],w()),R)],t.leakyRelu=(C,R,j)=>[C.run(M(C,R[0],x(j.alpha),j.cacheKey),R)],t.parseLeakyReluAttributes=C=>(0,n.createAttributeWithCacheKey)({alpha:C.attributes.getFloat("alpha",.01)}),t.log=(C,R)=>[C.run(M(C,R[0],_()),R)],t.neg=(C,R)=>[C.run(M(C,R[0],v()),R)],t.not=(C,R)=>[C.run(M(C,R[0],E()),R)],t.relu=(C,R)=>[C.run(M(C,R[0],S()),R)],t.sigmoid=(C,R)=>[C.run(M(C,R[0],T()),R)],t.sin=(C,R)=>[C.run(M(C,R[0],I()),R)],t.sqrt=(C,R)=>[C.run(M(C,R[0],A()),R)],t.tan=(C,R)=>[C.run(M(C,R[0],O()),R)],t.tanh=(C,R)=>[C.run(M(C,R[0],$()),R)]},540:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createUnpackProgramInfoLoader=t.createUnpackProgramInfo=void 0;const n=e(6757),a=e(5639),l=e(432),c=e(5614),f={name:"unpack",inputNames:["A"],inputTypes:[a.TextureType.packed]};t.createUnpackProgramInfo=(g,h)=>{const p=h.dims.length,s=(0,c.getChannels)("rc",p),r=s.slice(-2),u=(0,l.getCoordsDataType)(p),d=(0,c.unpackFromChannel)(),m=h.dims.length===0?"":function(w,x){if(w===1)return"rc";let _="";for(let v=0;v<w;v++)_+=x[v],v<w-1&&(_+=",");return _}(p,s),b=p<=1?"rc":`vec2(${r.join(",")})`,y=`
    ${d}
    void main() {
      ${u} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${m});

       ${(0,n.getGlsl)(g.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${b}), 0, 0, 0);
     }
   `;return Object.assign(Object.assign({},f),{hasMain:!0,output:{dims:h.dims,type:h.type,textureType:a.TextureType.unpacked},shaderSource:y})},t.createUnpackProgramInfoLoader=(g,h)=>Object.assign(Object.assign({},f),{get:()=>(0,t.createUnpackProgramInfo)(g,h)})},7862:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseUnsqueezeAttributes=t.unsqueezeV13=t.unsqueeze=void 0;const n=e(7273);t.unsqueeze=(c,f,g)=>{a(f);const h=n.ShapeUtil.unsqueezeShape(f[0].dims,g);return[c.reshapeUnpacked(f[0],h)]},t.unsqueezeV13=(c,f)=>(l(f),(0,t.unsqueeze)(c,[f[0]],Array.from(f[1].integerData))),t.parseUnsqueezeAttributes=c=>c.attributes.getInts("axes");const a=c=>{if(!c||c.length!==1)throw new Error("Unsqueeze requires 1 input.");if(c[0].type==="string")throw new Error("invalid input tensor types.")},l=c=>{if(!c||c.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(c[1].type!=="int32")throw new Error("Invalid input type.")}},3980:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.scalesValidation=t.validateInputs=t.parseUpsampleAttributes=t.parseUpsampleAttributesV9=t.parseUpsampleAttributesV7=t.upsample=void 0;const n=e(4910),a=e(6757),l=e(5639),c={name:"Upsample",inputNames:["X"],inputTypes:[l.TextureType.unpacked]};t.upsample=(g,h,p)=>((0,t.validateInputs)(h,p),[g.run(Object.assign(Object.assign({},c),{cacheHint:p.cacheKey,get:()=>f(g,h,p)}),h)]),t.parseUpsampleAttributesV7=g=>(0,t.parseUpsampleAttributes)(g,7),t.parseUpsampleAttributesV9=g=>(0,t.parseUpsampleAttributes)(g,9),t.parseUpsampleAttributes=(g,h)=>{const p=h>=10,s=g.attributes.getString("mode","nearest");if(s!=="nearest"&&s!=="linear"&&(h<11||s!=="cubic"))throw new Error(`unrecognized mode: ${s}`);let r=[];h<9&&(r=g.attributes.getFloats("scales"),(0,t.scalesValidation)(r,s,p));const u=g.attributes.getFloat("extrapolation_value",0),d=h>10?g.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(d)===-1)throw new Error(`coordinate_transform_mode '${d}' is not supported`);const m=d==="tf_crop_and_resize",b=m,y=s==="nearest"&&h>=11?g.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(y)===-1)throw new Error(`nearest_mode '${y}' is not supported`);const w=g.attributes.getFloat("cubic_coeff_a",-.75),x=g.attributes.getInt("exclude_outside",0)!==0;if(x&&s!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const _=h<11||s==="nearest"&&d==="asymmetric"&&y==="floor";let v=0,E=0,I=0;return h>10?g.inputs.length>2?(v=1,E=2,I=3):(E=1,I=2):h===9&&(E=1),(0,n.createAttributeWithCacheKey)({opset:h,isResize:p,mode:s,scales:r,extrapolationValue:u,coordinateTransformMode:d,useExtrapolation:b,needRoiInput:m,nearestMode:y,cubicCoefficientA:w,excludeOutside:x,useNearest2xOptimization:_,roiInputIdx:v,scalesInputIdx:E,sizesInputIdx:I})};const f=(g,h,p)=>{const s=(0,a.getGlsl)(g.session.backend.glContext.version),[r,u]=g.calculateTextureWidthAndHeight(h[0].dims,l.TextureType.unpacked),d=h[0].dims.map((I,S)=>Math.floor(I*p.scales[S])),[m,b]=g.calculateTextureWidthAndHeight(d,l.TextureType.unpacked),y=d.length,w=new Array(y),x=new Array(y);let _=`
      int output_pitches[${y}];
      int input_pitches[${y}];
      `;for(let I=y-1;I>=0;I--)w[I]=I===y-1?1:w[I+1]*d[I+1],x[I]=I===y-1?1:x[I+1]*h[0].dims[I+1],_+=`
        output_pitches[${I}] = ${w[I]};
        input_pitches[${I}] = ${x[I]};
        `;const v=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${r}, ${u});
        float value = getColorAsFloat(${s.texture2D}(X, coords));
        return value;
      }
      `,E=p.mode==="nearest"?`
    ${v}
    float process(int indices[${y}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${m}, ${b});

      ${_}

      int d, m;
      for (int dim = 0; dim < ${y}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:y===4?`
    ${v}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${m}, ${b});

      ${_}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${h[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${v}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${m}, ${b});

      ${_}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${h[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return Object.assign(Object.assign({},c),{output:{dims:d,type:h[0].type,textureType:l.TextureType.unpacked},shaderSource:E,variables:[{name:"scales",type:"int",arrayLength:p.scales.length,data:p.scales.map(I=>Math.ceil(I))}]})};t.validateInputs=(g,h)=>{if(!g||h.opset<9&&g.length!==1||h.opset>=9&&h.opset<11&&g.length!==2||h.opset>=11&&g.length<2)throw new Error("invalid inputs.");if(h.scales.length>0&&g[0].dims.length!==h.scales.length)throw new Error("Invalid input shape.");if(g[0].type==="string")throw new Error("Invalid input tensor types.")},t.scalesValidation=(g,h,p)=>{if(p){for(const s of g)if(s<=0)throw new Error("Scale value should be greater than 0.")}else for(const s of g)if(s<1)throw new Error("Scale value should be greater than or equal to 1.");if(!(h!=="linear"&&h!=="cubic"||g.length===2||g.length===4&&g[0]===1&&g[1]===1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${p?"Resize":"Upsample"} opeartor.`)}},2757:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ProgramManager=void 0;const n=e(8453),a=e(1315),l=e(8897),c=e(6757);t.ProgramManager=class{constructor(f,g,h){this.profiler=f,this.glContext=g,this.textureLayoutStrategy=h,this.repo=new Map,this.attributesBound=!1}getArtifact(f){return this.repo.get(f)}setArtifact(f,g){this.repo.set(f,g)}run(f,g,h){var p;this.profiler.event("op",`ProgramManager.run ${(p=f.programInfo.name)!==null&&p!==void 0?p:"unknown kernel"}`,()=>{var s;const r=this.glContext.gl,u=f.program;r.useProgram(u);try{this.bindOutput(h),this.attributesBound||this.bindAttributes(f.attribLocations),this.bindUniforms(f.uniformLocations,(s=f.programInfo.variables)!==null&&s!==void 0?s:[],g)}catch(d){throw a.Logger.error("ProgramManager",f.programInfo.shaderSource),d}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(f=>this.glContext.deleteProgram(f.program))}build(f,g,h){return this.profiler.event("backend","ProgramManager.build",()=>{const p=new l.GlslPreprocessor(this.glContext,f,g,h),s=p.preprocess(),r=this.compile(s);return{programInfo:f,program:r,uniformLocations:this.getUniformLocations(r,p.context.programInfo.inputNames,p.context.programInfo.variables),attribLocations:this.getAttribLocations(r)}})}compile(f){if(!this.vertexShader){a.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const p=(0,c.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(p,this.glContext.gl.VERTEX_SHADER)}n.env.debug&&a.Logger.verbose("ProrgramManager",`FragShader:
${f}
`);const g=this.glContext.compileShader(f,this.glContext.gl.FRAGMENT_SHADER),h=this.glContext.createProgram(this.vertexShader,g);return this.glContext.deleteShader(g),h}bindOutput(f){const g=f.width,h=f.height;a.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${g}/${h}, shape=${f.shape}, type=${f.tensor.type}`),this.glContext.attachFramebuffer(f.texture,g,h)}bindAttributes(f){const g=f.position,h=f.textureCoord;this.glContext.setVertexAttributes(g,h),this.attributesBound=!0}bindUniforms(f,g,h){var p;const s=this.glContext.gl;let r=0;for(const{name:u,type:d,location:m,arrayLength:b}of f){const y=(p=g.find(w=>w.name===u))===null||p===void 0?void 0:p.data;if(d!=="sampler2D"&&!y)throw new Error(`variable '${u}' does not have data defined in program info`);switch(d){case"sampler2D":this.bindTexture(h[r],m,r),r++;break;case"float":b?s.uniform1fv(m,y):s.uniform1f(m,y);break;case"int":b?s.uniform1iv(m,y):s.uniform1i(m,y);break;default:throw new Error(`Uniform not implemented: ${d}`)}}}bindTexture(f,g,h){this.glContext.bindTextureToUniform(f.texture,h,g)}getAttribLocations(f){return{position:this.getAttribLocation(f,"position"),textureCoord:this.getAttribLocation(f,"textureCoord")}}getUniformLocations(f,g,h){const p=[];if(g)for(const s of g)p.push({name:s,type:"sampler2D",location:this.getUniformLocation(f,s)});if(h)for(const s of h)p.push(Object.assign(Object.assign({},s),{location:this.getUniformLocation(f,s.name)}));return p}getUniformLocation(f,g){const h=this.glContext.gl.getUniformLocation(f,g);if(h===null)throw new Error(`Uniform ${g} not found.`);return h}getAttribLocation(f,g){return this.glContext.gl.getAttribLocation(f,g)}}},2171:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLSessionHandler=void 0;const n=e(1315),a=e(5881),l=e(7860),c=e(4110),f=e(2757),g=e(7618),h=e(5243);t.WebGLSessionHandler=class{constructor(p,s){this.backend=p,this.context=s,this.layoutStrategy=new g.PreferLogicalStrategy(p.glContext.maxTextureSize),this.programManager=new f.ProgramManager(this.context.profiler,p.glContext,this.layoutStrategy),this.textureManager=new h.TextureManager(p.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:p.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=p.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new l.WebGLInferenceHandler(this)}onGraphInitialized(p){const s=p.getValues().filter(r=>r.from===-1&&r.tensor).map(r=>r.tensor.dataId);this.initializers=new Set(s)}isInitializer(p){return!!this.initializers&&this.initializers.has(p)}addInitializer(p){this.initializers.add(p)}getTextureData(p,s){return s?this.packedTextureDataCache.get(p):this.unpackedTextureDataCache.get(p)}setTextureData(p,s,r=!1){n.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),r?this.packedTextureDataCache.set(p,s):this.unpackedTextureDataCache.set(p,s)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(p=>this.textureManager.releaseTexture(p,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(p=>this.textureManager.releaseTexture(p,!0)),this.unpackedTextureDataCache=new Map}resolve(p,s,r){const u=(0,a.resolveOperator)(p,s,c.WEBGL_OP_RESOLVE_RULES);return{impl:u.opImpl,context:u.opInit?u.opInit(p,r):p}}}},9622:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Uint8DataEncoder=t.RGBAFloatDataEncoder=t.RedFloat32DataEncoder=void 0;const n=e(1315);t.RedFloat32DataEncoder=class{constructor(a,l=1){if(l===1)this.internalFormat=a.R32F,this.format=a.RED,this.textureType=a.FLOAT,this.channelSize=l;else{if(l!==4)throw new Error(`Invalid number of channels: ${l}`);this.internalFormat=a.RGBA32F,this.format=a.RGBA,this.textureType=a.FLOAT,this.channelSize=l}}encode(a,l){let c,f;return a.constructor!==Float32Array&&(n.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),f=new Float32Array(a)),l*this.channelSize>a.length?(n.Logger.warning("Encoder","Source data too small. Allocating larger array"),f=a,c=this.allocate(l*this.channelSize),f.forEach((g,h)=>c[h]=g)):(f=a,c=f),c}allocate(a){return new Float32Array(4*a)}decode(a,l){return this.channelSize===1?a.filter((c,f)=>f%4==0).subarray(0,l):a.subarray(0,l)}},t.RGBAFloatDataEncoder=class{constructor(a,l=1,c){if(l!==1&&l!==4)throw new Error(`Invalid number of channels: ${l}`);this.internalFormat=a.RGBA,this.format=a.RGBA,this.channelSize=l,this.textureType=c||a.FLOAT}encode(a,l){let c=a;return this.channelSize===1&&(n.Logger.verbose("Encoder","Exploding into a larger array"),c=this.allocate(l),a.forEach((f,g)=>c[4*g]=f)),c}allocate(a){return new Float32Array(4*a)}decode(a,l){return this.channelSize===1?a.filter((c,f)=>f%4==0).subarray(0,l):a.subarray(0,l)}},t.Uint8DataEncoder=class{constructor(a,l=1){if(this.channelSize=4,l===1)this.internalFormat=a.ALPHA,this.format=a.ALPHA,this.textureType=a.UNSIGNED_BYTE,this.channelSize=l;else{if(l!==4)throw new Error(`Invalid number of channels: ${l}`);this.internalFormat=a.RGBA,this.format=a.RGBA,this.textureType=a.UNSIGNED_BYTE,this.channelSize=l}}encode(a,l){return new Uint8Array(a.buffer,a.byteOffset,a.byteLength)}allocate(a){return new Uint8Array(a*this.channelSize)}decode(a,l){if(a instanceof Uint8Array)return a.subarray(0,l);throw new Error(`Invalid array type: ${a.constructor}`)}}},7618:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.getBatchDim=t.sizeToSquarishShape=t.getRowsCols=t.sizeFromShape=t.isInt=t.parseAxisParam=t.squeezeShape=t.PreferLogicalStrategy=t.AlwaysKeepOriginalSizeStrategy=void 0;const n=e(1315),a=e(7273);function l(p,s){const r=[],u=[],d=s!=null&&Array.isArray(s)&&s.length===0,m=s==null||d?null:c(s,p).sort();let b=0;for(let y=0;y<p.length;++y){if(m!=null){if(m[b]===y&&p[y]!==1)throw new Error(`Can't squeeze axis ${y} since its dim '${p[y]}' is not 1`);(m[b]==null||m[b]>y)&&p[y]===1&&(r.push(p[y]),u.push(y)),m[b]<=y&&b++}p[y]!==1&&(r.push(p[y]),u.push(y))}return{newShape:r,keptDims:u}}function c(p,s){const r=s.length;return p=p==null?s.map((u,d)=>d):[].concat(p),(0,a.assert)(p.every(u=>u>=-r&&u<r),()=>`All values in axis param must be in range [-${r}, ${r}) but got axis ${p}`),(0,a.assert)(p.every(f),()=>`All values in axis param must be integers but got axis ${p}`),p.map(u=>u<0?r+u:u)}function f(p){return p%1==0}function g(p){if(p.length===0)return 1;let s=p[0];for(let r=1;r<p.length;r++)s*=p[r];return s}function h(p){const s=Math.ceil(Math.sqrt(p));return[s,Math.ceil(p/s)]}t.AlwaysKeepOriginalSizeStrategy=class{constructor(p){this.maxTextureSize=p}computeTextureWH(p,s){if(p.length===0)return[1,1];const r=this.maxTextureSize;if(s&&s.breakAxis!==void 0){const m=s.breakAxis>=p.length?1:p.slice(s.breakAxis).reduce((y,w)=>y*w),b=s.breakAxis<=0?1:p.slice(0,s.breakAxis).reduce((y,w)=>y*w);if(!(m>r||b>r))return[m,b];n.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${p}, breakAxis:${s.breakAxis}`)}const u=p.reduce((m,b)=>m*b);let d=Math.floor(Math.sqrt(u));for(;d<r&&d<u&&u%d!=0;d++);if(d>=r||u%d!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${p}`);return[d,u/d]}},t.PreferLogicalStrategy=class{constructor(p){this.maxTextureSize=p}computeTextureWH(p,s){const r=this.computeTexture(p,s);return s&&s.isPacked&&(r[0]/=2,r[1]/=2),s&&s.reverseWH?[r[1],r[0]]:r}computeTexture(p,s){const r=s&&s.isPacked;if(p.length===0)return r?[2,2]:[1,1];let u=this.maxTextureSize;if(s&&s.breakAxis!==void 0){const b=s.breakAxis>=p.length?1:p.slice(s.breakAxis).reduce((w,x)=>w*x),y=s.breakAxis<=0?1:p.slice(0,s.breakAxis).reduce((w,x)=>w*x);if(!(b>u||y>u))return[b,y];n.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${p}, breakAxis:${s.breakAxis}`)}let d=p.slice(0);r&&(u*=2,d=d.map((b,y)=>y>=d.length-2?d[y]%2==0?d[y]:d[y]+1:d[y]),d.length===1&&(d=[2,d[0]])),d.length!==2&&(d=l(d).newShape);const m=g(d);return d.length<=1&&m<=u?[1,m]:d.length===2&&d[0]<=u&&d[1]<=u?d:d.length===3&&d[0]*d[1]<=u&&d[2]<=u?[d[0]*d[1],d[2]]:d.length===3&&d[0]<=u&&d[1]*d[2]<=u?[d[0],d[1]*d[2]]:d.length===4&&d[0]*d[1]*d[2]<=u&&d[3]<=u?[d[0]*d[1]*d[2],d[3]]:d.length===4&&d[0]<=u&&d[1]*d[2]*d[3]<=u?[d[0],d[1]*d[2]*d[3]]:r?h(m/4).map(b=>2*b):h(m)}},t.squeezeShape=l,t.parseAxisParam=c,t.isInt=f,t.sizeFromShape=g,t.getRowsCols=function(p){if(p.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[p.length>1?p[p.length-2]:1,p[p.length-1]]},t.sizeToSquarishShape=h,t.getBatchDim=function(p,s=2){return g(p.slice(0,p.length-s))}},3314:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createTextureLayoutFromShape=t.calculateTextureWidthAndHeight=t.createTextureLayoutFromTextureType=void 0;const n=e(7273),a=e(5639);t.createTextureLayoutFromTextureType=(l,c,f)=>{const g=f===a.TextureType.unpacked||f===a.TextureType.unpackedReversed?1:4,h=f===a.TextureType.packed,p=f===a.TextureType.unpackedReversed||f===a.TextureType.packed,s=f===a.TextureType.packedLastDimension?c.length-1:void 0,r=f===a.TextureType.packedLastDimension?c.map((u,d)=>d===c.length-1?4*u:u):void 0;return(0,t.createTextureLayoutFromShape)(l,c,g,r,{isPacked:h,reverseWH:p,breakAxis:s})},t.calculateTextureWidthAndHeight=(l,c,f)=>{const g=(0,t.createTextureLayoutFromTextureType)(l,c,f);return[g.width,g.height]},t.createTextureLayoutFromShape=(l,c,f=1,g,h)=>{const p=!(!h||!h.isPacked),[s,r]=l.computeTextureWH(p&&g||c,h),u=c.length;let d=c.slice(0);if(u===0&&(d=[1]),f===1)g=c;else if(p){if(f!==4)throw new Error("a packed texture must be 4-channel");g=c,u>0&&(d[u-1]=Math.ceil(d[u-1]/2)),u>1&&(d[u-2]=Math.ceil(d[u-2]/2))}else if(!g)throw new Error("Unpacked shape is needed when using channels > 1");return{width:s,height:r,channels:f,isPacked:p,shape:d,strides:n.ShapeUtil.computeStrides(d),unpackedShape:g,reversedWH:h&&h.reverseWH}}},5243:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TextureManager=void 0;const n=e(1315);t.TextureManager=class{constructor(a,l,c,f){this.glContext=a,this.layoutStrategy=l,this.profiler=c,this.config=f,this.pendingRead=new Map,f.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(a,l,c,f){const g=this.toEncoderType(a),h=this.glContext.getEncoder(g,l.channels||1,f);if(l.isPacked&&f===1)throw new Error("not implemented");const p=l.width,s=l.height;let r,u;if(this.config.reuseTextures){r=`${p}x${s}_${h.format}_${h.internalFormat}_${h.textureType}`,u=this.inUseTextures.get(r),u||(u=[],this.inUseTextures.set(r,u));const m=this.idleTextures.get(r);if(m&&m.length>0){const b=m.pop();return u.push(b),f===1&&this.glContext.updateTexture(b,p,s,h,this.toTextureData(a,c)),b}}n.Logger.verbose("TextureManager",`Creating new texture of size ${l.width}x${l.height}`);const d=this.glContext.allocateTexture(p,s,h,this.toTextureData(a,c));return this.config.reuseTextures&&(u.push(d),this.textureLookup.set(d,r)),d}readTexture(a,l,c){return c||(c=1),this.profiler.event("backend","TextureManager.readTexture",()=>{const f=a.shape.reduce((h,p)=>h*p)*c,g=this.glContext.readTexture(a.texture,a.width,a.height,f,this.toEncoderType(l),c);return this.toTensorData(l,g)})}async readTextureAsync(a,l,c){const f=a.tensor.dataId;if(c||(c=1),this.pendingRead.has(f)){const g=this.pendingRead.get(f);return new Promise(h=>g==null?void 0:g.push(h))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(f,[]);const g=a.shape.reduce((r,u)=>r*u)*c;await this.glContext.createAndWaitForFence();const h=this.glContext.readTexture(a.texture,a.width,a.height,g,this.toEncoderType(l),c),p=this.toTensorData(l,h),s=this.pendingRead.get(f);return this.pendingRead.delete(f),s==null||s.forEach(r=>r(p)),p})}readUint8TextureAsFloat(a){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{const l=a.shape.reduce((f,g)=>f*g),c=this.glContext.readTexture(a.texture,a.width,a.height,4*l,"byte",4);return new Float32Array(c.buffer,c.byteOffset,l)})}releaseTexture(a,l){let c;if(this.config.reuseTextures&&(c=this.textureLookup.get(a.texture),c)){l&&this.textureLookup.delete(c);const f=this.inUseTextures.get(c);if(f){const g=f.indexOf(a.texture);if(g!==-1){f.splice(g,1);let h=this.idleTextures.get(c);h||(h=[],this.idleTextures.set(c,h)),h.push(a.texture)}}}c&&!l||(n.Logger.verbose("TextureManager",`Deleting texture of size ${a.width}x${a.height}`),this.glContext.deleteTexture(a.texture))}toTensorData(a,l){switch(a){case"int16":return l instanceof Int16Array?l:Int16Array.from(l);case"int32":return l instanceof Int32Array?l:Int32Array.from(l);case"int8":return l instanceof Int8Array?l:Int8Array.from(l);case"uint16":return l instanceof Uint16Array?l:Uint16Array.from(l);case"uint32":return l instanceof Uint32Array?l:Uint32Array.from(l);case"uint8":case"bool":return l instanceof Uint8Array?l:Uint8Array.from(l);case"float32":return l instanceof Float32Array?l:Float32Array.from(l);case"float64":return l instanceof Float64Array?l:Float64Array.from(l);default:throw new Error(`TensorData type ${a} is not supported`)}}toTextureData(a,l){if(l)return l instanceof Float32Array?l:new Float32Array(l)}toEncoderType(a){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},5639:(o,t)=>{var e;Object.defineProperty(t,"__esModule",{value:!0}),t.TextureType=void 0,(e=t.TextureType||(t.TextureType={}))[e.unpacked=0]="unpacked",e[e.unpackedReversed=1]="unpackedReversed",e[e.packed=2]="packed",e[e.downloadUint8AsFloat=3]="downloadUint8AsFloat",e[e.packedLastDimension=4]="packedLastDimension"},432:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.getGlChannels=t.getCoordsDataType=t.getSqueezedParams=t.squeezeInputShape=t.generateShaderFuncNameFromInputSamplerNameAtOutCoords=t.generateShaderFuncNameFromInputSamplerName=t.repeatedTry=t.getPackedShape=void 0;const n=e(7273);t.getPackedShape=function(a){const l=a.length;return a.slice(0,l-1).concat(a[l-1]/4)},t.repeatedTry=async function(a,l=f=>0,c){return new Promise((f,g)=>{let h=0;const p=()=>{if(a())return void f();h++;const s=l(h);c!=null&&h>=c?g():setTimeout(p,s)};p()})},t.generateShaderFuncNameFromInputSamplerName=function(a){return(0,n.assert)(a!==void 0&&a.length!==0,()=>"empty string found for sampler name"),"get"+a.charAt(0).toUpperCase()+a.slice(1)},t.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(a){return(0,n.assert)(a!==void 0&&a.length!==0,()=>"empty string found for sampler name"),"get"+a.charAt(0).toUpperCase()+a.slice(1)+"AtOutCoords"},t.squeezeInputShape=function(a,l){let c=JSON.parse(JSON.stringify(a));return c=l,c},t.getSqueezedParams=function(a,l){return l.map(c=>a[c]).join(", ")},t.getCoordsDataType=function(a){if(a<=1)return"int";if(a===2)return"ivec2";if(a===3)return"ivec3";if(a===4)return"ivec4";if(a===5)return"ivec5";if(a===6)return"ivec6";throw Error(`GPU for rank ${a} is not yet supported`)},t.getGlChannels=function(a=6){return["x","y","z","w","u","v"].slice(0,a)}},3389:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createNewWebGLContext=t.createWebGLContext=void 0;const n=e(1315),a=e(3524),l={};function c(f){const g=function(){if(typeof document>"u"){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}const s=document.createElement("canvas");return s.width=1,s.height=1,s}();let h;const p={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!f||f==="webgl2")&&(h=g.getContext("webgl2",p),h))try{return new a.WebGLContext(h,2)}catch(s){n.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${s}`)}if((!f||f==="webgl")&&(h=g.getContext("webgl",p)||g.getContext("experimental-webgl",p),h))try{return new a.WebGLContext(h,1)}catch(s){n.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${s}`)}throw new Error("WebGL is not supported")}t.createWebGLContext=function f(g){let h;g&&g!=="webgl2"||!("webgl2"in l)?g&&g!=="webgl"||!("webgl"in l)||(h=l.webgl):h=l.webgl2,h=h||c(g),g=g||h.version===1?"webgl":"webgl2";const p=h.gl;return l[g]=h,p.isContextLost()?(delete l[g],f(g)):(p.disable(p.DEPTH_TEST),p.disable(p.STENCIL_TEST),p.disable(p.BLEND),p.disable(p.DITHER),p.disable(p.POLYGON_OFFSET_FILL),p.disable(p.SAMPLE_COVERAGE),p.enable(p.SCISSOR_TEST),p.enable(p.CULL_FACE),p.cullFace(p.BACK),h)},t.createNewWebGLContext=c},3524:function(o,t,e){var n=this&&this.__createBinding||(Object.create?function(p,s,r,u){u===void 0&&(u=r);var d=Object.getOwnPropertyDescriptor(s,r);d&&!("get"in d?!s.__esModule:d.writable||d.configurable)||(d={enumerable:!0,get:function(){return s[r]}}),Object.defineProperty(p,u,d)}:function(p,s,r,u){u===void 0&&(u=r),p[u]=s[r]}),a=this&&this.__setModuleDefault||(Object.create?function(p,s){Object.defineProperty(p,"default",{enumerable:!0,value:s})}:function(p,s){p.default=s}),l=this&&this.__importStar||function(p){if(p&&p.__esModule)return p;var s={};if(p!=null)for(var r in p)r!=="default"&&Object.prototype.hasOwnProperty.call(p,r)&&n(s,p,r);return a(s,p),s};Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLContext=t.linearSearchLastTrue=void 0;const c=e(8453),f=l(e(9622)),g=e(432);function h(p){let s=0;for(;s<p.length&&p[s]();++s);return s-1}t.linearSearchLastTrue=h,t.WebGLContext=class{constructor(p,s){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=p,this.version=s,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(p,s,r,u){const d=this.gl,m=d.createTexture();d.bindTexture(d.TEXTURE_2D,m),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.NEAREST),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,d.NEAREST),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE);const b=u?r.encode(u,p*s):null;return d.texImage2D(d.TEXTURE_2D,0,r.internalFormat,p,s,0,r.format,r.textureType,b),this.checkError(),m}updateTexture(p,s,r,u,d){const m=this.gl;m.bindTexture(m.TEXTURE_2D,p);const b=u.encode(d,s*r);m.texSubImage2D(m.TEXTURE_2D,0,0,0,s,r,u.format,u.textureType,b),this.checkError()}attachFramebuffer(p,s,r){const u=this.gl;u.bindTexture(u.TEXTURE_2D,p),u.bindFramebuffer(u.FRAMEBUFFER,this.framebuffer),u.framebufferTexture2D(u.FRAMEBUFFER,u.COLOR_ATTACHMENT0,u.TEXTURE_2D,p,0),this.checkError(),u.viewport(0,0,s,r),u.scissor(0,0,s,r)}readTexture(p,s,r,u,d,m){const b=this.gl;m||(m=1),this.frameBufferBound||this.attachFramebuffer(p,s,r);const y=this.getEncoder(d,m),w=y.allocate(s*r);return b.bindTexture(b.TEXTURE_2D,p),b.framebufferTexture2D(b.FRAMEBUFFER,b.COLOR_ATTACHMENT0,b.TEXTURE_2D,p,0),b.readPixels(0,0,s,r,b.RGBA,y.textureType,w),this.checkError(),y.decode(w,u)}isFramebufferReady(){return!0}getActiveTexture(){const p=this.gl;return"TEXTURE"+(p.getParameter(this.gl.ACTIVE_TEXTURE)-p.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(p,s){const r=this.gl;r.vertexAttribPointer(p,3,r.FLOAT,!1,20,0),r.enableVertexAttribArray(p),s!==-1&&(r.vertexAttribPointer(s,2,r.FLOAT,!1,20,12),r.enableVertexAttribArray(s)),this.checkError()}createProgram(p,s){const r=this.gl,u=r.createProgram();return r.attachShader(u,p),r.attachShader(u,s),r.linkProgram(u),u}compileShader(p,s){const r=this.gl,u=r.createShader(s);if(!u)throw new Error(`createShader() returned null with type ${s}`);if(r.shaderSource(u,p),r.compileShader(u),r.getShaderParameter(u,r.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${r.getShaderInfoLog(u)}
Shader source:
${p}`);return u}deleteShader(p){this.gl.deleteShader(p)}bindTextureToUniform(p,s,r){const u=this.gl;u.activeTexture(u.TEXTURE0+s),this.checkError(),u.bindTexture(u.TEXTURE_2D,p),this.checkError(),u.uniform1i(r,s),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(c.env.debug){const p=this.gl,s=p.getError();let r="";switch(s){case p.NO_ERROR:return;case p.INVALID_ENUM:r="INVALID_ENUM";break;case p.INVALID_VALUE:r="INVALID_VALUE";break;case p.INVALID_OPERATION:r="INVALID_OPERATION";break;case p.INVALID_FRAMEBUFFER_OPERATION:r="INVALID_FRAMEBUFFER_OPERATION";break;case p.OUT_OF_MEMORY:r="OUT_OF_MEMORY";break;case p.CONTEXT_LOST_WEBGL:r="CONTEXT_LOST_WEBGL";break;default:r=`Unknown WebGL Error: ${s.toString(16)}`}throw new Error(r)}}deleteTexture(p){this.gl.deleteTexture(p)}deleteProgram(p){this.gl.deleteProgram(p)}getEncoder(p,s,r=0){if(this.version===2)return new f.RedFloat32DataEncoder(this.gl,s);switch(p){case"float":return r===1||this.isRenderFloat32Supported?new f.RGBAFloatDataEncoder(this.gl,s):new f.RGBAFloatDataEncoder(this.gl,s,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new f.Uint8DataEncoder(this.gl,s);default:throw new Error(`Invalid dataType: ${p}`)}}clearActiveTextures(){const p=this.gl;for(let s=0;s<this.maxTextureImageUnits;++s)p.activeTexture(p.TEXTURE0+s),p.bindTexture(p.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const p=this.gl;p.bindFramebuffer(p.FRAMEBUFFER,null),p.deleteFramebuffer(this.framebuffer),p.bindBuffer(p.ARRAY_BUFFER,null),p.deleteBuffer(this.vertexbuffer),p.bindBuffer(p.ELEMENT_ARRAY_BUFFER,null),p.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const p=this.gl,s=p.createBuffer();if(!s)throw new Error("createBuffer() returned null");const r=this.createDefaultGeometry();return p.bindBuffer(p.ARRAY_BUFFER,s),p.bufferData(p.ARRAY_BUFFER,r,p.STATIC_DRAW),this.checkError(),s}createFramebuffer(){const p=this.gl.createFramebuffer();if(!p)throw new Error("createFramebuffer returned null");return p}queryVitalParameters(){const p=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=p.getParameter(p.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=p.getParameter(p.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const p=this.gl,s=p.createTexture();p.bindTexture(p.TEXTURE_2D,s);const r=this.version===2?p.RGBA32F:p.RGBA;p.texImage2D(p.TEXTURE_2D,0,r,1,1,0,p.RGBA,p.FLOAT,null);const u=p.createFramebuffer();p.bindFramebuffer(p.FRAMEBUFFER,u),p.framebufferTexture2D(p.FRAMEBUFFER,p.COLOR_ATTACHMENT0,p.TEXTURE_2D,s,0);const d=p.checkFramebufferStatus(p.FRAMEBUFFER)===p.FRAMEBUFFER_COMPLETE;return p.bindTexture(p.TEXTURE_2D,null),p.bindFramebuffer(p.FRAMEBUFFER,null),p.deleteTexture(s),p.deleteFramebuffer(u),d}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const p=this.gl;let s,r,u,d,m;try{s=p.createTexture(),r=p.createFramebuffer(),p.bindTexture(p.TEXTURE_2D,s);const b=this.version===2?p.RGBA32F:p.RGBA;return p.texImage2D(p.TEXTURE_2D,0,b,1,1,0,p.RGBA,p.FLOAT,null),p.bindFramebuffer(p.FRAMEBUFFER,r),p.framebufferTexture2D(p.FRAMEBUFFER,p.COLOR_ATTACHMENT0,p.TEXTURE_2D,s,0),p.enable(p.BLEND),u=p.createShader(p.VERTEX_SHADER),!!u&&(p.shaderSource(u,"void main(){}"),p.compileShader(u),d=p.createShader(p.FRAGMENT_SHADER),!!d&&(p.shaderSource(d,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),p.compileShader(d),m=p.createProgram(),!!m&&(p.attachShader(m,u),p.attachShader(m,d),p.linkProgram(m),p.useProgram(m),p.drawArrays(p.POINTS,0,1),p.getError()===p.NO_ERROR)))}finally{p.disable(p.BLEND),m&&p.deleteProgram(m),u&&p.deleteShader(u),d&&p.deleteShader(d),r&&(p.bindFramebuffer(p.FRAMEBUFFER,null),p.deleteFramebuffer(r)),s&&(p.bindTexture(p.TEXTURE_2D,null),p.deleteTexture(s))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){const p=this.gl,s=this.disjointTimerQueryWebgl2Extension,r=p.createQuery();return p.beginQuery(s.TIME_ELAPSED_EXT,r),r}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const p=this.gl,s=this.disjointTimerQueryWebgl2Extension;p.endQuery(s.TIME_ELAPSED_EXT)}}isTimerResultAvailable(p){let s=!1,r=!1;if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const u=this.gl,d=this.disjointTimerQueryWebgl2Extension;s=u.getQueryParameter(p,u.QUERY_RESULT_AVAILABLE),r=u.getParameter(d.GPU_DISJOINT_EXT)}return s&&!r}getTimerResult(p){let s=0;if(this.version!==2)throw new Error("WebGL1 profiling currently not supported");{const r=this.gl;s=r.getQueryParameter(p,r.QUERY_RESULT),r.deleteQuery(p)}return s/1e6}async waitForQueryAndGetTime(p){return await(0,g.repeatedTry)(()=>this.isTimerResultAvailable(p)),this.getTimerResult(p)}async createAndWaitForFence(){const p=this.createFence(this.gl);return this.pollFence(p)}createFence(p){let s;const r=p,u=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);return p.flush(),s=u===null?()=>!0:()=>{const d=r.clientWaitSync(u,0,0);return d===r.ALREADY_SIGNALED||d===r.CONDITION_SATISFIED},{query:u,isFencePassed:s}}async pollFence(p){return new Promise(s=>{this.addItemToPoll(()=>p.isFencePassed(),()=>s())})}pollItems(){const p=h(this.itemsToPoll.map(s=>s.isDoneFn));for(let s=0;s<=p;++s){const{resolveFn:r}=this.itemsToPoll[s];r()}this.itemsToPoll=this.itemsToPoll.slice(p+1)}async addItemToPoll(p,s){this.itemsToPoll.push({isDoneFn:p,resolveFn:s}),this.itemsToPoll.length>1||await(0,g.repeatedTry)(()=>(this.pollItems(),this.itemsToPoll.length===0))}}},6496:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ExecutionPlan=void 0;const n=e(1315);class a{constructor(c,f){this.op=c,this.node=f}}t.ExecutionPlan=class{constructor(l,c,f){this.graph=l,this.profiler=f,this.initialize(c)}initialize(l){this.profiler.event("session","ExecutionPlan.initialize",()=>{const c=this.graph.getNodes();if(c.length!==l.length)throw new Error("The size of nodes and OPs do not match.");this._ops=l.map((f,g)=>new a(f,c[g])),this.reset(),this._starter=[],this._ops.forEach((f,g)=>{let h=!0;for(const p of f.node.inputs)if(!this._values[p]&&this.graph.getInputIndices().indexOf(p)===-1){h=!1;break}h&&this._starter.push(g)})})}reset(){this._values=this.graph.getValues().map(l=>l.tensor)}async execute(l,c){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();const f=l.createInferenceHandler(),g=this.graph.getInputIndices();if(c.length!==g.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${c.length} expected: ${g.length}`);c.forEach((d,m)=>{const b=g[m];this._values[b]=d});const h=this._starter.slice(0),p=this.graph.getValues(),s=this.graph.getNodes();let r=0;for(;r<h.length;){const d=h[r++],m=this._ops[d],b=m.node.inputs.map(_=>this._values[_]);if(b.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${m.node}`);const y=b;n.Logger.verbose("ExecPlan",`Runing op:${m.node.name} (${y.map((_,v)=>`'${m.node.inputs[v]}': ${_.type}[${_.dims.join(",")}]`).join(", ")})`);const w=await this.profiler.event("node",m.node.name,async()=>m.op.impl(f,y,m.op.context));if(w.length!==m.node.outputs.length)throw new Error("the size of output does not match model definition.");w.forEach((_,v)=>{const E=m.node.outputs[v];if(this._values[E])throw new Error(`output [${E}] already has value: op:${m.node.name}`);this._values[E]=_});const x=new Set;w.forEach((_,v)=>{const E=m.node.outputs[v];for(const I of p[E].to){const S=s[I];let T=!0;for(const A of S.inputs)if(!this._values[A]){T=!1;break}T&&x.add(I)}}),h.push(...x)}const u=[];for(let d=0;d<this.graph.getOutputIndices().length;d++){const m=this.graph.getOutputIndices()[d],b=this._values[m];if(b===void 0)throw new Error(`required output [${m}] does not have value`);m===0?await b.getData():b.data,u.push(b)}return n.Logger.verbose("ExecPlan","disposing of inferenceHandler"),f.dispose(),u})}}},4662:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Graph=void 0;const n=e(1446),a=e(6874),l=e(1287),c=e(9240),f=e(7273);var g=l.onnxruntime.experimental.fbs;t.Graph={from:(r,u)=>new s(r,u)};class h{constructor(u){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,u&&(this.type=f.ProtoUtil.tensorValueTypeFromProto(u.type.tensorType))}get from(){return this._from}get to(){return this._to}}class p{constructor(u,d){u instanceof n.onnx.NodeProto?(this.name=u.name,this.opType=u.opType,this.attributes=new a.Attribute(u.attribute)):u instanceof g.Node&&(this.name=d??u.name(),this.opType=u.opType(),this.attributes=new a.Attribute(f.ProtoUtil.tensorAttributesFromORTFormat(u))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class s{constructor(u,d){if(!u)throw new TypeError("graph is empty");this.buildGraph(u),this.transformGraph(d),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(u){if(u instanceof n.onnx.GraphProto)this.buildGraphFromOnnxFormat(u);else{if(!(u instanceof g.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(u)}}buildGraphFromOnnxFormat(u){const d=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const m=new Map;if(!u.input)throw new Error("missing information in graph: input");const b=[];for(const y of u.input){if(d.has(y.name))throw new Error(`duplicated input name: ${y.name}`);const w=this._allData.push(new h(y))-1;d.set(y.name,w),b.push(y.name)}if(!u.initializer)throw new Error("missing information in graph: initializer");for(const y of u.initializer){let w=d.get(y.name);if(w===void 0){const x=new h;x.type={shape:{dims:f.ProtoUtil.tensorDimsFromProto(y.dims)},tensorType:f.ProtoUtil.tensorDataTypeFromProto(y.dataType)},w=this._allData.push(x)-1,d.set(y.name,w)}this._allData[w]._from=-1,this._allData[w].tensor=c.Tensor.fromProto(y)}for(let y=0;y<this._allData.length;y++)this._allData[y].tensor||(this._allInputIndices.push(y),this._allInputNames.push(b[y]));if(!u.output)throw new Error("missing information in graph: output");for(const y of u.output){if(d.has(y.name))throw new Error(`duplicated output name: ${y.name}`);const w=this._allData.push(new h(y))-1;d.set(y.name,w),this._allOutputIndices.push(w),this._allOutputNames.push(y.name)}if(!u.node)throw new Error("missing information in graph: node");for(const y of u.node){if(!y.name)for(let x=0;;x++){const _=`unnamed_${y.opType}_${x}`;if(!m.has(_)){y.name=_;break}}if(m.has(y.name))throw new Error(`duplicated node name: ${y.name}`);const w=this._nodes.push(new p(y))-1;m.set(y.name,w)}for(let y=0;y<this._nodes.length;y++){const w=this._nodes[y],x=u.node[y];if(!x.output)throw new Error(`missing output for node: ${x.name}`);for(const _ of x.output){let v=d.get(_);if(v===void 0&&(v=this._allData.push(new h)-1,d.set(_,v)),w.outputs.push(v),this._allData[v]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${v}`);if(this._allData[v]._from=y,x.opType==="Constant"){if(!x.attribute||x.attribute.length!==1||!x.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!x.output||x.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");w.outputs.pop(),w.executeNode=!1,this._allData[v]._from=-1,this._allData[v].tensor=c.Tensor.fromProto(x.attribute[0].t)}}}for(let y=0;y<this._nodes.length;y++){const w=this._nodes[y],x=u.node[y];if(!x.input)throw new Error(`missing input for node: ${x.name}`);for(const _ of x.input){const v=d.get(_);if(v===void 0){if(_===""&&x.input.length===3&&x.opType==="Resize")continue;throw new Error(`unrecognized input '${_}' for node: ${x.name}`)}w.inputs.push(v),this._allData[v]._to.push(y)}}return!0}buildGraphFromOrtFormat(u){var d,m,b;const y=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const w=new Map,x=[];for(let _=0;_<u.inputsLength();_++){const v=u.inputs(_);if(y.has(v))throw new Error(`duplicated input name: ${v}`);for(let E=0;E<u.nodeArgsLength();E++)if(((d=u.nodeArgs(E))===null||d===void 0?void 0:d.name())===v){const I=new h;if(((b=(m=u.nodeArgs(E))===null||m===void 0?void 0:m.type())===null||b===void 0?void 0:b.valueType())!==g.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const S=u.nodeArgs(E).type().value(new g.TensorTypeAndShape),T=f.ProtoUtil.tensorDataTypeFromProto(S.elemType()),A=S.shape(),O=[];for(let D=0;D<A.dimLength();D++)O.push(f.LongUtil.longToNumber(A.dim(D).value().dimValue()));I.type={shape:{dims:O},tensorType:T};const $=this._allData.push(I)-1;y.set(v,$),x.push(v)}}for(let _=0;_<u.initializersLength();_++){const v=u.initializers(_);let E=y.get(v.name());if(E===void 0){const I=new h,S=f.ProtoUtil.tensorDimsFromORTFormat(v),T=f.ProtoUtil.tensorDataTypeFromProto(v.dataType());I.type={shape:{dims:S},tensorType:T},E=this._allData.push(I)-1,y.set(v.name(),E)}this._allData[E]._from=-1,this._allData[E].tensor=c.Tensor.fromOrtTensor(v)}for(let _=0;_<this._allData.length;_++)this._allData[_].tensor||(this._allInputIndices.push(_),this._allInputNames.push(x[_]));for(let _=0;_<u.outputsLength();_++){const v=u.outputs(_);if(y.has(v))throw new Error(`duplicated output name: ${v}`);const E=this._allData.push(new h)-1;y.set(v,E),this._allOutputIndices.push(E),this._allOutputNames.push(v)}if(!u.nodes)throw new Error("missing information in graph: node");for(let _=0;_<u.nodesLength();_++){const v=u.nodes(_);let E=v.name();if(!E)for(let S=0;E=`unnamed_${v.opType()}_${S}`,w.has(E);S++);if(w.has(E))throw new Error(`duplicated node name: ${E}`);const I=this._nodes.push(new p(v,E))-1;w.set(E,I)}for(let _=0;_<this._nodes.length;_++){const v=this._nodes[_],E=u.nodes(_);if(E==null)throw new Error(`No node exists at index ${_}`);if((E==null?void 0:E.outputsLength())===0)throw new Error(`missing output for node: ${E.name}`);for(let I=0;I<(E==null?void 0:E.outputsLength());I++){const S=E==null?void 0:E.outputs(I);let T=y.get(S);if(T===void 0&&(T=this._allData.push(new h)-1,y.set(S,T)),v.outputs.push(T),this._allData[T]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${T}`);if(this._allData[T]._from=_,E.opType()==="Constant"){if(E.attributesLength()!==1||!E.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(E.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");v.outputs.pop(),v.executeNode=!1,this._allData[T]._from=-1,this._allData[T].tensor=c.Tensor.fromOrtTensor(E.attributes(0).t())}}}for(let _=0;_<this._nodes.length;_++){const v=this._nodes[_],E=u.nodes(_);if(E.inputsLength()===0)throw new Error(`missing input for node: ${E.name}`);for(let I=0;I<E.inputsLength();I++){const S=E.inputs(I),T=y.get(S);if(T===void 0)throw new Error(`unrecognized input '${S}' for node: ${E.name()}`);v.inputs.push(T),this._allData[T]._to.push(_)}}}checkIsAcyclic(){const u=new Set;this._allInputIndices.forEach(b=>{this._allData[b]._to.forEach(y=>{u.add(y)})});const d=Array.from(u),m=new Array(this._nodes.length).fill("white");for(;d.length>0;){const b=d.pop();m[b]==="gray"?m[b]="black":(d.push(b),m[b]="gray",this._nodes[b].outputs.forEach(y=>{const w=this._allData[y];if(w.tensor!==void 0)throw new Error("node outputs should not be initialized");if(w._from!==b)throw new Error("from property of the Value object doesn't match index of Node being processed");w._to.forEach(x=>{if(m[x]==="gray")throw new Error("model graph is cyclic");m[x]==="white"&&d.push(x)})}))}}transformGraph(u){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),u&&u.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let u=0;const d=new Array(this._nodes.length,0);let m=0;for(let b=0;b<this._nodes.length;b++)d[b]=m,this._nodes[b].executeNode?(m!==b&&(this._nodes[m]=this._nodes[b]),m++):this._nodes[b].outputs.forEach(y=>{this._allData[y]._from=-2});this._nodes.splice(m,this._nodes.length-m);for(let b=0;b<this._allData.length;b++){const y=this._allData[b];y._from!==void 0&&y._from!==-1&&y._from!==-2&&(y._from=d[y._from]);for(let w=0;w<y._to.length;w++){if(!(y._to[w]>=0))throw new Error("Trying to update a removed node");y._to[w]=d[y._to[w]]}}u=0;for(let b=0;b<this._allData.length;b++)if(this._allData[b].from!==-2||this._allOutputIndices.indexOf(b+u)!==-1){if(u>0){let y=-1;this._allData[b].from!==void 0&&this._allData[b].from!==-1?(y=this._nodes[this._allData[b].from].outputs.indexOf(b+u),y!==-1&&(this._nodes[this._allData[b].from].outputs[y]=b)):(y=this._allInputIndices.indexOf(b+u),y!==-1&&(this._allInputIndices[y]=b)),this._allData[b].to.forEach(w=>{y=this._nodes[w].inputs.indexOf(b+u),y!==-1&&(this._nodes[w].inputs[y]=b)}),this._allData[b].to.length===0&&(y=this._allOutputIndices.indexOf(b+u),y!==-1&&(this._allOutputIndices[y]=b))}}else u++,this._allData.splice(b,1),b--}deleteNode(u){const d=this._nodes[u];if(d.outputs.length>1){for(let x=1;x<d.outputs.length;x++)if(this._allData[d.outputs[x]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}d.executeNode=!1;const m=d.inputs[0],b=d.outputs[0],y=this._allData[b].to;for(let x=0;x<d.inputs.length;x++){const _=this._allData[d.inputs[x]].to.indexOf(u);if(_===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[d.inputs[x]].to.splice(_,1)}this._allData[b]._to=[];const w=this._allOutputIndices.indexOf(b);if(w!==-1&&(this._allOutputIndices[w]=m),y&&y.length>0)for(const x of y){const _=this._nodes[x].inputs.indexOf(b);if(_===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[x].inputs[_]=m,this._allData[m].to.push(x)}}removeAllDropoutNodes(){let u=0;for(const d of this._nodes){if(d.opType==="Dropout"){if(d.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(d.outputs.length!==1&&d.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(d.outputs.length===2&&this._allData[d.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(u)}u++}}removeAllIdentityNodes(){let u=0;for(const d of this._nodes)d.opType==="Identity"&&this.deleteNode(u),u++}isActivation(u){switch(u.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const u of this._nodes)if(u.opType==="Conv"){const d=this._allData[u.outputs[0]]._to;if(d.length===1&&this.isActivation(this._nodes[d[0]])){const m=this._nodes[d[0]];if(m.opType==="Clip")if(m.inputs.length===1)try{u.attributes.set("activation_params","floats",[m.attributes.getFloat("min"),m.attributes.getFloat("max")])}catch{u.attributes.set("activation_params","floats",[f.MIN_CLIP,f.MAX_CLIP])}else{if(!(m.inputs.length>=3&&this._allData[m.inputs[1]].tensor!==void 0&&this._allData[m.inputs[2]].tensor!==void 0))continue;u.attributes.set("activation_params","floats",[this._allData[m.inputs[1]].tensor.floatData[0],this._allData[m.inputs[2]].tensor.floatData[0]])}u.attributes.set("activation","string",m.opType),this.deleteNode(d[0])}}}}},1315:(o,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.now=t.Profiler=t.Logger=void 0;const e={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},n={none:new class{log(p,s,r){}},console:new class{log(p,s,r){console.log(`${this.color(p)} ${r?"\x1B[35m"+r+"\x1B[0m ":""}${s}`)}color(p){switch(p){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${p}`)}}}},a={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let l={"":a};function c(p,s,r,u){if(s===void 0)return d=p,{verbose:c.verbose.bind(null,d),info:c.info.bind(null,d),warning:c.warning.bind(null,d),error:c.error.bind(null,d),fatal:c.fatal.bind(null,d)};if(r===void 0)f(p,s);else if(typeof r=="number"&&u===void 0)f(p,s);else if(typeof r=="string"&&u===void 0)f(p,r,0,s);else{if(typeof r!="string"||typeof u!="number")throw new TypeError("input is valid");f(p,r,0,s)}var d}function f(p,s,r,u){const d=l[u||""]||l[""];e[p]<e[d.minimalSeverity]||(d.logDateTime&&(s=`${new Date().toISOString()}|${s}`),d.logSourceLocation,n[d.provider].log(p,s,u))}(function(p){function s(u){l={},r("",u||{})}function r(u,d){if(u==="*")s(d);else{const m=l[u]||a;l[u]={provider:d.provider||m.provider,minimalSeverity:d.minimalSeverity||m.minimalSeverity,logDateTime:d.logDateTime===void 0?m.logDateTime:d.logDateTime,logSourceLocation:d.logSourceLocation===void 0?m.logSourceLocation:d.logSourceLocation}}}p.verbose=function(u,d){p("verbose",u,d)},p.info=function(u,d){p("info",u,d)},p.warning=function(u,d){p("warning",u,d)},p.error=function(u,d){p("error",u,d)},p.fatal=function(u,d){p("fatal",u,d)},p.reset=s,p.set=r,p.setWithEnv=function(u){const d={};u.logLevel&&(d.minimalSeverity=u.logLevel),r("",d)}})(c||(c={})),t.Logger=c;class g{constructor(s,r,u,d,m,b){this.category=s,this.name=r,this.startTime=u,this.endCallback=d,this.timer=m,this.ctx=b}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class h{constructor(s,r,u,d){this.category=s,this.name=r,this.startTime=u,this.endTime=d}}t.Profiler=class{static create(p){return p===void 0?new this:new this(p.maxNumberEvents,p.flushBatchSize,p.flushIntervalInMilliseconds)}constructor(p,s,r){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=p===void 0?1e4:p,this._flushBatchSize=s===void 0?10:s,this._flushIntervalInMilliseconds=r===void 0?5e3:r}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,t.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(p,s,r,u){const d=this._started?this.begin(p,s,u):void 0;let m=!1;const b=r();if(b&&typeof b.then=="function")return m=!0,new Promise((y,w)=>{b.then(async x=>{d&&await d.end(),y(x)},async x=>{d&&await d.end(),w(x)})});if(!m&&d){const y=d.end();if(y&&typeof y.then=="function")return new Promise((w,x)=>{y.then(()=>{w(b)},_=>{x(_)})})}return b}begin(p,s,r){if(!this._started)throw new Error("profiler is not started yet");if(r===void 0){const u=(0,t.now)();return this.flush(u),new g(p,s,u,d=>this.endSync(d))}{const u=r.beginTimer();return new g(p,s,0,async d=>this.end(d),u,r)}}async end(p){const s=await p.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new h(p.category,p.name,p.startTime,s)),this.flush(s))}endSync(p){const s=(0,t.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new h(p.category,p.name,p.startTime,s)),this.flush(s))}logOneEvent(p){t.Logger.verbose(`Profiler.${p.category}`,`${(p.endTime-p.startTime).toFixed(2)}ms on event '${p.name}' at ${p.endTime.toFixed(2)}`)}flush(p){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||p-this._flushTime>=this._flushIntervalInMilliseconds){for(const s=this._flushPointer;this._flushPointer<s+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,t.now)()}}get started(){return this._started}},t.now=typeof performance<"u"&&performance.now?()=>performance.now():Date.now},1745:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Model=void 0;const n=e(5686),a=e(1446),l=e(4662),c=e(1287),f=e(7273);var g=c.onnxruntime.experimental.fbs;t.Model=class{constructor(){}load(h,p,s){if(!s)try{return void this.loadFromOnnxFormat(h,p)}catch(r){if(s!==void 0)throw r}this.loadFromOrtFormat(h,p)}loadFromOnnxFormat(h,p){const s=a.onnx.ModelProto.decode(h);if(f.LongUtil.longToNumber(s.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=s.opsetImport.map(r=>({domain:r.domain,version:f.LongUtil.longToNumber(r.version)})),this._graph=l.Graph.from(s.graph,p)}loadFromOrtFormat(h,p){const s=new n.flatbuffers.ByteBuffer(h),r=g.InferenceSession.getRootAsInferenceSession(s).model();if(f.LongUtil.longToNumber(r.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let u=0;u<r.opsetImportLength();u++){const d=r.opsetImport(u);this._opsets.push({domain:d==null?void 0:d.domain(),version:f.LongUtil.longToNumber(d.version())})}this._graph=l.Graph.from(r.graph(),p)}get graph(){return this._graph}get opsets(){return this._opsets}}},6145:(o,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.FLOAT_TYPES=t.INT_TYPES=t.NUMBER_TYPES=void 0,t.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],t.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],t.FLOAT_TYPES=["float32","float64"]},5881:(o,t)=>{function e(n,a){if(a.endsWith("+")){const l=Number.parseInt(a.substring(0,a.length-1),10);return!isNaN(l)&&l<=n}if(a.split("-").length===2){const l=a.split("-"),c=Number.parseInt(l[0],10),f=Number.parseInt(l[1],10);return!isNaN(c)&&!isNaN(f)&&c<=n&&n<=f}return Number.parseInt(a,10)===n}Object.defineProperty(t,"__esModule",{value:!0}),t.resolveOperator=void 0,t.resolveOperator=function(n,a,l){for(const c of l){const f=c[0],g=c[1],h=c[2],p=c[3],s=c[4];if(n.opType===f){for(const r of a)if((r.domain===g||r.domain==="ai.onnx"&&g==="")&&e(r.version,h))return{opImpl:p,opInit:s}}}throw new TypeError(`cannot resolve operator '${n.opType}' with opsets: ${a.map(c=>`${c.domain||"ai.onnx"} v${c.version}`).join(", ")}`)}},1287:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.onnxruntime=void 0;const n=e(5686);var a,l;a=t.onnxruntime||(t.onnxruntime={}),function(c){(function(f){f[f.UNDEFINED=0]="UNDEFINED",f[f.FLOAT=1]="FLOAT",f[f.INT=2]="INT",f[f.STRING=3]="STRING",f[f.TENSOR=4]="TENSOR",f[f.GRAPH=5]="GRAPH",f[f.FLOATS=6]="FLOATS",f[f.INTS=7]="INTS",f[f.STRINGS=8]="STRINGS",f[f.TENSORS=9]="TENSORS",f[f.GRAPHS=10]="GRAPHS",f[f.SPARSE_TENSOR=11]="SPARSE_TENSOR",f[f.SPARSE_TENSORS=12]="SPARSE_TENSORS"})(c.AttributeType||(c.AttributeType={}))}((l=a.experimental||(a.experimental={})).fbs||(l.fbs={})),function(c){(function(f){(function(g){(function(h){h[h.UNKNOWN=0]="UNKNOWN",h[h.VALUE=1]="VALUE",h[h.PARAM=2]="PARAM"})(g.DimensionValueType||(g.DimensionValueType={}))})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){(function(h){h[h.UNDEFINED=0]="UNDEFINED",h[h.FLOAT=1]="FLOAT",h[h.UINT8=2]="UINT8",h[h.INT8=3]="INT8",h[h.UINT16=4]="UINT16",h[h.INT16=5]="INT16",h[h.INT32=6]="INT32",h[h.INT64=7]="INT64",h[h.STRING=8]="STRING",h[h.BOOL=9]="BOOL",h[h.FLOAT16=10]="FLOAT16",h[h.DOUBLE=11]="DOUBLE",h[h.UINT32=12]="UINT32",h[h.UINT64=13]="UINT64",h[h.COMPLEX64=14]="COMPLEX64",h[h.COMPLEX128=15]="COMPLEX128",h[h.BFLOAT16=16]="BFLOAT16"})(g.TensorDataType||(g.TensorDataType={}))})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){(function(h){h[h.Primitive=0]="Primitive",h[h.Fused=1]="Fused"})(g.NodeType||(g.NodeType={}))})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){(function(h){h[h.NONE=0]="NONE",h[h.tensor_type=1]="tensor_type",h[h.sequence_type=2]="sequence_type",h[h.map_type=3]="map_type"})(g.TypeInfoValue||(g.TypeInfoValue={}))})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsShape(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsShape(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}dim(s,r){let u=this.bb.__offset(this.bb_pos,4);return u?(r||new c.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*s),this.bb):null}dimLength(){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__vector_len(this.bb_pos+s):0}static startShape(s){s.startObject(1)}static addDim(s,r){s.addFieldOffset(0,r,0)}static createDimVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addOffset(r[u]);return s.endVector()}static startDimVector(s,r){s.startVector(4,r,4)}static endShape(s){return s.endObject()}static createShape(s,r){return h.startShape(s),h.addDim(s,r),h.endShape(s)}}g.Shape=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsDimension(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsDimension(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}value(s){let r=this.bb.__offset(this.bb_pos,4);return r?(s||new c.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}denotation(s){let r=this.bb.__offset(this.bb_pos,6);return r?this.bb.__string(this.bb_pos+r,s):null}static startDimension(s){s.startObject(2)}static addValue(s,r){s.addFieldOffset(0,r,0)}static addDenotation(s,r){s.addFieldOffset(1,r,0)}static endDimension(s){return s.endObject()}static createDimension(s,r,u){return h.startDimension(s),h.addValue(s,r),h.addDenotation(s,u),h.endDimension(s)}}g.Dimension=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsDimensionValue(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsDimensionValue(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}dimType(){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readInt8(this.bb_pos+s):c.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readInt64(this.bb_pos+s):this.bb.createLong(0,0)}dimParam(s){let r=this.bb.__offset(this.bb_pos,8);return r?this.bb.__string(this.bb_pos+r,s):null}static startDimensionValue(s){s.startObject(3)}static addDimType(s,r){s.addFieldInt8(0,r,c.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(s,r){s.addFieldInt64(1,r,s.createLong(0,0))}static addDimParam(s,r){s.addFieldOffset(2,r,0)}static endDimensionValue(s){return s.endObject()}static createDimensionValue(s,r,u,d){return h.startDimensionValue(s),h.addDimType(s,r),h.addDimValue(s,u),h.addDimParam(s,d),h.endDimensionValue(s)}}g.DimensionValue=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsTensorTypeAndShape(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsTensorTypeAndShape(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}elemType(){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readInt32(this.bb_pos+s):c.experimental.fbs.TensorDataType.UNDEFINED}shape(s){let r=this.bb.__offset(this.bb_pos,6);return r?(s||new c.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}static startTensorTypeAndShape(s){s.startObject(2)}static addElemType(s,r){s.addFieldInt32(0,r,c.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(s,r){s.addFieldOffset(1,r,0)}static endTensorTypeAndShape(s){return s.endObject()}static createTensorTypeAndShape(s,r,u){return h.startTensorTypeAndShape(s),h.addElemType(s,r),h.addShape(s,u),h.endTensorTypeAndShape(s)}}g.TensorTypeAndShape=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsMapType(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsMapType(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}keyType(){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readInt32(this.bb_pos+s):c.experimental.fbs.TensorDataType.UNDEFINED}valueType(s){let r=this.bb.__offset(this.bb_pos,6);return r?(s||new c.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}static startMapType(s){s.startObject(2)}static addKeyType(s,r){s.addFieldInt32(0,r,c.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(s,r){s.addFieldOffset(1,r,0)}static endMapType(s){return s.endObject()}static createMapType(s,r,u){return h.startMapType(s),h.addKeyType(s,r),h.addValueType(s,u),h.endMapType(s)}}g.MapType=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsSequenceType(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsSequenceType(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}elemType(s){let r=this.bb.__offset(this.bb_pos,4);return r?(s||new c.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}static startSequenceType(s){s.startObject(1)}static addElemType(s,r){s.addFieldOffset(0,r,0)}static endSequenceType(s){return s.endObject()}static createSequenceType(s,r){return h.startSequenceType(s),h.addElemType(s,r),h.endSequenceType(s)}}g.SequenceType=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(f.fbs||(f.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(g,h){return this.bb_pos=g,this.bb=h,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(g,h,p,s){return g.prep(4,12),g.writeInt32(s),g.writeInt32(p),g.writeInt32(h),g.offset()}}})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsNodeEdge(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsNodeEdge(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}nodeIndex(){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readUint32(this.bb_pos+s):0}inputEdges(s,r){let u=this.bb.__offset(this.bb_pos,6);return u?(r||new c.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+u)+12*s,this.bb):null}inputEdgesLength(){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__vector_len(this.bb_pos+s):0}outputEdges(s,r){let u=this.bb.__offset(this.bb_pos,8);return u?(r||new c.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+u)+12*s,this.bb):null}outputEdgesLength(){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__vector_len(this.bb_pos+s):0}static startNodeEdge(s){s.startObject(3)}static addNodeIndex(s,r){s.addFieldInt32(0,r,0)}static addInputEdges(s,r){s.addFieldOffset(1,r,0)}static startInputEdgesVector(s,r){s.startVector(12,r,4)}static addOutputEdges(s,r){s.addFieldOffset(2,r,0)}static startOutputEdgesVector(s,r){s.startVector(12,r,4)}static endNodeEdge(s){return s.endObject()}static createNodeEdge(s,r,u,d){return h.startNodeEdge(s),h.addNodeIndex(s,r),h.addInputEdges(s,u),h.addOutputEdges(s,d),h.endNodeEdge(s)}}g.NodeEdge=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsNode(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsNode(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}name(s){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,s):null}docString(s){let r=this.bb.__offset(this.bb_pos,6);return r?this.bb.__string(this.bb_pos+r,s):null}domain(s){let r=this.bb.__offset(this.bb_pos,8);return r?this.bb.__string(this.bb_pos+r,s):null}sinceVersion(){let s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readInt32(this.bb_pos+s):0}index(){let s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readUint32(this.bb_pos+s):0}opType(s){let r=this.bb.__offset(this.bb_pos,14);return r?this.bb.__string(this.bb_pos+r,s):null}type(){let s=this.bb.__offset(this.bb_pos,16);return s?this.bb.readInt32(this.bb_pos+s):c.experimental.fbs.NodeType.Primitive}executionProviderType(s){let r=this.bb.__offset(this.bb_pos,18);return r?this.bb.__string(this.bb_pos+r,s):null}inputs(s,r){let u=this.bb.__offset(this.bb_pos,20);return u?this.bb.__string(this.bb.__vector(this.bb_pos+u)+4*s,r):null}inputsLength(){let s=this.bb.__offset(this.bb_pos,20);return s?this.bb.__vector_len(this.bb_pos+s):0}outputs(s,r){let u=this.bb.__offset(this.bb_pos,22);return u?this.bb.__string(this.bb.__vector(this.bb_pos+u)+4*s,r):null}outputsLength(){let s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__vector_len(this.bb_pos+s):0}attributes(s,r){let u=this.bb.__offset(this.bb_pos,24);return u?(r||new c.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*s),this.bb):null}attributesLength(){let s=this.bb.__offset(this.bb_pos,24);return s?this.bb.__vector_len(this.bb_pos+s):0}inputArgCounts(s){let r=this.bb.__offset(this.bb_pos,26);return r?this.bb.readInt32(this.bb.__vector(this.bb_pos+r)+4*s):0}inputArgCountsLength(){let s=this.bb.__offset(this.bb_pos,26);return s?this.bb.__vector_len(this.bb_pos+s):0}inputArgCountsArray(){let s=this.bb.__offset(this.bb_pos,26);return s?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+s),this.bb.__vector_len(this.bb_pos+s)):null}implicitInputs(s,r){let u=this.bb.__offset(this.bb_pos,28);return u?this.bb.__string(this.bb.__vector(this.bb_pos+u)+4*s,r):null}implicitInputsLength(){let s=this.bb.__offset(this.bb_pos,28);return s?this.bb.__vector_len(this.bb_pos+s):0}static startNode(s){s.startObject(13)}static addName(s,r){s.addFieldOffset(0,r,0)}static addDocString(s,r){s.addFieldOffset(1,r,0)}static addDomain(s,r){s.addFieldOffset(2,r,0)}static addSinceVersion(s,r){s.addFieldInt32(3,r,0)}static addIndex(s,r){s.addFieldInt32(4,r,0)}static addOpType(s,r){s.addFieldOffset(5,r,0)}static addType(s,r){s.addFieldInt32(6,r,c.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(s,r){s.addFieldOffset(7,r,0)}static addInputs(s,r){s.addFieldOffset(8,r,0)}static createInputsVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addOffset(r[u]);return s.endVector()}static startInputsVector(s,r){s.startVector(4,r,4)}static addOutputs(s,r){s.addFieldOffset(9,r,0)}static createOutputsVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addOffset(r[u]);return s.endVector()}static startOutputsVector(s,r){s.startVector(4,r,4)}static addAttributes(s,r){s.addFieldOffset(10,r,0)}static createAttributesVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addOffset(r[u]);return s.endVector()}static startAttributesVector(s,r){s.startVector(4,r,4)}static addInputArgCounts(s,r){s.addFieldOffset(11,r,0)}static createInputArgCountsVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addInt32(r[u]);return s.endVector()}static startInputArgCountsVector(s,r){s.startVector(4,r,4)}static addImplicitInputs(s,r){s.addFieldOffset(12,r,0)}static createImplicitInputsVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addOffset(r[u]);return s.endVector()}static startImplicitInputsVector(s,r){s.startVector(4,r,4)}static endNode(s){return s.endObject()}static createNode(s,r,u,d,m,b,y,w,x,_,v,E,I,S){return h.startNode(s),h.addName(s,r),h.addDocString(s,u),h.addDomain(s,d),h.addSinceVersion(s,m),h.addIndex(s,b),h.addOpType(s,y),h.addType(s,w),h.addExecutionProviderType(s,x),h.addInputs(s,_),h.addOutputs(s,v),h.addAttributes(s,E),h.addInputArgCounts(s,I),h.addImplicitInputs(s,S),h.endNode(s)}}g.Node=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsValueInfo(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsValueInfo(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}name(s){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,s):null}docString(s){let r=this.bb.__offset(this.bb_pos,6);return r?this.bb.__string(this.bb_pos+r,s):null}type(s){let r=this.bb.__offset(this.bb_pos,8);return r?(s||new c.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}static startValueInfo(s){s.startObject(3)}static addName(s,r){s.addFieldOffset(0,r,0)}static addDocString(s,r){s.addFieldOffset(1,r,0)}static addType(s,r){s.addFieldOffset(2,r,0)}static endValueInfo(s){return s.endObject()}static createValueInfo(s,r,u,d){return h.startValueInfo(s),h.addName(s,r),h.addDocString(s,u),h.addType(s,d),h.endValueInfo(s)}}g.ValueInfo=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsTypeInfo(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsTypeInfo(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}denotation(s){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,s):null}valueType(){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readUint8(this.bb_pos+s):c.experimental.fbs.TypeInfoValue.NONE}value(s){let r=this.bb.__offset(this.bb_pos,8);return r?this.bb.__union(s,this.bb_pos+r):null}static startTypeInfo(s){s.startObject(3)}static addDenotation(s,r){s.addFieldOffset(0,r,0)}static addValueType(s,r){s.addFieldInt8(1,r,c.experimental.fbs.TypeInfoValue.NONE)}static addValue(s,r){s.addFieldOffset(2,r,0)}static endTypeInfo(s){return s.endObject()}static createTypeInfo(s,r,u,d){return h.startTypeInfo(s),h.addDenotation(s,r),h.addValueType(s,u),h.addValue(s,d),h.endTypeInfo(s)}}g.TypeInfo=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsOperatorSetId(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsOperatorSetId(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}domain(s){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,s):null}version(){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readInt64(this.bb_pos+s):this.bb.createLong(0,0)}static startOperatorSetId(s){s.startObject(2)}static addDomain(s,r){s.addFieldOffset(0,r,0)}static addVersion(s,r){s.addFieldInt64(1,r,s.createLong(0,0))}static endOperatorSetId(s){return s.endObject()}static createOperatorSetId(s,r,u){return h.startOperatorSetId(s),h.addDomain(s,r),h.addVersion(s,u),h.endOperatorSetId(s)}}g.OperatorSetId=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsTensor(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsTensor(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}name(s){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,s):null}docString(s){let r=this.bb.__offset(this.bb_pos,6);return r?this.bb.__string(this.bb_pos+r,s):null}dims(s){let r=this.bb.__offset(this.bb_pos,8);return r?this.bb.readInt64(this.bb.__vector(this.bb_pos+r)+8*s):this.bb.createLong(0,0)}dimsLength(){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__vector_len(this.bb_pos+s):0}dataType(){let s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readInt32(this.bb_pos+s):c.experimental.fbs.TensorDataType.UNDEFINED}rawData(s){let r=this.bb.__offset(this.bb_pos,12);return r?this.bb.readUint8(this.bb.__vector(this.bb_pos+r)+s):0}rawDataLength(){let s=this.bb.__offset(this.bb_pos,12);return s?this.bb.__vector_len(this.bb_pos+s):0}rawDataArray(){let s=this.bb.__offset(this.bb_pos,12);return s?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+s),this.bb.__vector_len(this.bb_pos+s)):null}stringData(s,r){let u=this.bb.__offset(this.bb_pos,14);return u?this.bb.__string(this.bb.__vector(this.bb_pos+u)+4*s,r):null}stringDataLength(){let s=this.bb.__offset(this.bb_pos,14);return s?this.bb.__vector_len(this.bb_pos+s):0}static startTensor(s){s.startObject(6)}static addName(s,r){s.addFieldOffset(0,r,0)}static addDocString(s,r){s.addFieldOffset(1,r,0)}static addDims(s,r){s.addFieldOffset(2,r,0)}static createDimsVector(s,r){s.startVector(8,r.length,8);for(let u=r.length-1;u>=0;u--)s.addInt64(r[u]);return s.endVector()}static startDimsVector(s,r){s.startVector(8,r,8)}static addDataType(s,r){s.addFieldInt32(3,r,c.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(s,r){s.addFieldOffset(4,r,0)}static createRawDataVector(s,r){s.startVector(1,r.length,1);for(let u=r.length-1;u>=0;u--)s.addInt8(r[u]);return s.endVector()}static startRawDataVector(s,r){s.startVector(1,r,1)}static addStringData(s,r){s.addFieldOffset(5,r,0)}static createStringDataVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addOffset(r[u]);return s.endVector()}static startStringDataVector(s,r){s.startVector(4,r,4)}static endTensor(s){return s.endObject()}static createTensor(s,r,u,d,m,b,y){return h.startTensor(s),h.addName(s,r),h.addDocString(s,u),h.addDims(s,d),h.addDataType(s,m),h.addRawData(s,b),h.addStringData(s,y),h.endTensor(s)}}g.Tensor=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsSparseTensor(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsSparseTensor(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}values(s){let r=this.bb.__offset(this.bb_pos,4);return r?(s||new c.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}indices(s){let r=this.bb.__offset(this.bb_pos,6);return r?(s||new c.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}dims(s){let r=this.bb.__offset(this.bb_pos,8);return r?this.bb.readInt64(this.bb.__vector(this.bb_pos+r)+8*s):this.bb.createLong(0,0)}dimsLength(){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__vector_len(this.bb_pos+s):0}static startSparseTensor(s){s.startObject(3)}static addValues(s,r){s.addFieldOffset(0,r,0)}static addIndices(s,r){s.addFieldOffset(1,r,0)}static addDims(s,r){s.addFieldOffset(2,r,0)}static createDimsVector(s,r){s.startVector(8,r.length,8);for(let u=r.length-1;u>=0;u--)s.addInt64(r[u]);return s.endVector()}static startDimsVector(s,r){s.startVector(8,r,8)}static endSparseTensor(s){return s.endObject()}static createSparseTensor(s,r,u,d){return h.startSparseTensor(s),h.addValues(s,r),h.addIndices(s,u),h.addDims(s,d),h.endSparseTensor(s)}}g.SparseTensor=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsAttribute(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsAttribute(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}name(s){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,s):null}docString(s){let r=this.bb.__offset(this.bb_pos,6);return r?this.bb.__string(this.bb_pos+r,s):null}type(){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readInt32(this.bb_pos+s):c.experimental.fbs.AttributeType.UNDEFINED}f(){let s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readFloat32(this.bb_pos+s):0}i(){let s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readInt64(this.bb_pos+s):this.bb.createLong(0,0)}s(s){let r=this.bb.__offset(this.bb_pos,14);return r?this.bb.__string(this.bb_pos+r,s):null}t(s){let r=this.bb.__offset(this.bb_pos,16);return r?(s||new c.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}g(s){let r=this.bb.__offset(this.bb_pos,18);return r?(s||new c.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}floats(s){let r=this.bb.__offset(this.bb_pos,20);return r?this.bb.readFloat32(this.bb.__vector(this.bb_pos+r)+4*s):0}floatsLength(){let s=this.bb.__offset(this.bb_pos,20);return s?this.bb.__vector_len(this.bb_pos+s):0}floatsArray(){let s=this.bb.__offset(this.bb_pos,20);return s?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+s),this.bb.__vector_len(this.bb_pos+s)):null}ints(s){let r=this.bb.__offset(this.bb_pos,22);return r?this.bb.readInt64(this.bb.__vector(this.bb_pos+r)+8*s):this.bb.createLong(0,0)}intsLength(){let s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__vector_len(this.bb_pos+s):0}strings(s,r){let u=this.bb.__offset(this.bb_pos,24);return u?this.bb.__string(this.bb.__vector(this.bb_pos+u)+4*s,r):null}stringsLength(){let s=this.bb.__offset(this.bb_pos,24);return s?this.bb.__vector_len(this.bb_pos+s):0}tensors(s,r){let u=this.bb.__offset(this.bb_pos,26);return u?(r||new c.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*s),this.bb):null}tensorsLength(){let s=this.bb.__offset(this.bb_pos,26);return s?this.bb.__vector_len(this.bb_pos+s):0}graphs(s,r){let u=this.bb.__offset(this.bb_pos,28);return u?(r||new c.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*s),this.bb):null}graphsLength(){let s=this.bb.__offset(this.bb_pos,28);return s?this.bb.__vector_len(this.bb_pos+s):0}static startAttribute(s){s.startObject(13)}static addName(s,r){s.addFieldOffset(0,r,0)}static addDocString(s,r){s.addFieldOffset(1,r,0)}static addType(s,r){s.addFieldInt32(2,r,c.experimental.fbs.AttributeType.UNDEFINED)}static addF(s,r){s.addFieldFloat32(3,r,0)}static addI(s,r){s.addFieldInt64(4,r,s.createLong(0,0))}static addS(s,r){s.addFieldOffset(5,r,0)}static addT(s,r){s.addFieldOffset(6,r,0)}static addG(s,r){s.addFieldOffset(7,r,0)}static addFloats(s,r){s.addFieldOffset(8,r,0)}static createFloatsVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addFloat32(r[u]);return s.endVector()}static startFloatsVector(s,r){s.startVector(4,r,4)}static addInts(s,r){s.addFieldOffset(9,r,0)}static createIntsVector(s,r){s.startVector(8,r.length,8);for(let u=r.length-1;u>=0;u--)s.addInt64(r[u]);return s.endVector()}static startIntsVector(s,r){s.startVector(8,r,8)}static addStrings(s,r){s.addFieldOffset(10,r,0)}static createStringsVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addOffset(r[u]);return s.endVector()}static startStringsVector(s,r){s.startVector(4,r,4)}static addTensors(s,r){s.addFieldOffset(11,r,0)}static createTensorsVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addOffset(r[u]);return s.endVector()}static startTensorsVector(s,r){s.startVector(4,r,4)}static addGraphs(s,r){s.addFieldOffset(12,r,0)}static createGraphsVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addOffset(r[u]);return s.endVector()}static startGraphsVector(s,r){s.startVector(4,r,4)}static endAttribute(s){return s.endObject()}static createAttribute(s,r,u,d,m,b,y,w,x,_,v,E,I,S){return h.startAttribute(s),h.addName(s,r),h.addDocString(s,u),h.addType(s,d),h.addF(s,m),h.addI(s,b),h.addS(s,y),h.addT(s,w),h.addG(s,x),h.addFloats(s,_),h.addInts(s,v),h.addStrings(s,E),h.addTensors(s,I),h.addGraphs(s,S),h.endAttribute(s)}}g.Attribute=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsGraph(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsGraph(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}initializers(s,r){let u=this.bb.__offset(this.bb_pos,4);return u?(r||new c.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*s),this.bb):null}initializersLength(){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__vector_len(this.bb_pos+s):0}nodeArgs(s,r){let u=this.bb.__offset(this.bb_pos,6);return u?(r||new c.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*s),this.bb):null}nodeArgsLength(){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__vector_len(this.bb_pos+s):0}nodes(s,r){let u=this.bb.__offset(this.bb_pos,8);return u?(r||new c.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*s),this.bb):null}nodesLength(){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__vector_len(this.bb_pos+s):0}maxNodeIndex(){let s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readUint32(this.bb_pos+s):0}nodeEdges(s,r){let u=this.bb.__offset(this.bb_pos,12);return u?(r||new c.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*s),this.bb):null}nodeEdgesLength(){let s=this.bb.__offset(this.bb_pos,12);return s?this.bb.__vector_len(this.bb_pos+s):0}inputs(s,r){let u=this.bb.__offset(this.bb_pos,14);return u?this.bb.__string(this.bb.__vector(this.bb_pos+u)+4*s,r):null}inputsLength(){let s=this.bb.__offset(this.bb_pos,14);return s?this.bb.__vector_len(this.bb_pos+s):0}outputs(s,r){let u=this.bb.__offset(this.bb_pos,16);return u?this.bb.__string(this.bb.__vector(this.bb_pos+u)+4*s,r):null}outputsLength(){let s=this.bb.__offset(this.bb_pos,16);return s?this.bb.__vector_len(this.bb_pos+s):0}sparseInitializers(s,r){let u=this.bb.__offset(this.bb_pos,18);return u?(r||new c.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*s),this.bb):null}sparseInitializersLength(){let s=this.bb.__offset(this.bb_pos,18);return s?this.bb.__vector_len(this.bb_pos+s):0}static startGraph(s){s.startObject(8)}static addInitializers(s,r){s.addFieldOffset(0,r,0)}static createInitializersVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addOffset(r[u]);return s.endVector()}static startInitializersVector(s,r){s.startVector(4,r,4)}static addNodeArgs(s,r){s.addFieldOffset(1,r,0)}static createNodeArgsVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addOffset(r[u]);return s.endVector()}static startNodeArgsVector(s,r){s.startVector(4,r,4)}static addNodes(s,r){s.addFieldOffset(2,r,0)}static createNodesVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addOffset(r[u]);return s.endVector()}static startNodesVector(s,r){s.startVector(4,r,4)}static addMaxNodeIndex(s,r){s.addFieldInt32(3,r,0)}static addNodeEdges(s,r){s.addFieldOffset(4,r,0)}static createNodeEdgesVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addOffset(r[u]);return s.endVector()}static startNodeEdgesVector(s,r){s.startVector(4,r,4)}static addInputs(s,r){s.addFieldOffset(5,r,0)}static createInputsVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addOffset(r[u]);return s.endVector()}static startInputsVector(s,r){s.startVector(4,r,4)}static addOutputs(s,r){s.addFieldOffset(6,r,0)}static createOutputsVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addOffset(r[u]);return s.endVector()}static startOutputsVector(s,r){s.startVector(4,r,4)}static addSparseInitializers(s,r){s.addFieldOffset(7,r,0)}static createSparseInitializersVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addOffset(r[u]);return s.endVector()}static startSparseInitializersVector(s,r){s.startVector(4,r,4)}static endGraph(s){return s.endObject()}static createGraph(s,r,u,d,m,b,y,w,x){return h.startGraph(s),h.addInitializers(s,r),h.addNodeArgs(s,u),h.addNodes(s,d),h.addMaxNodeIndex(s,m),h.addNodeEdges(s,b),h.addInputs(s,y),h.addOutputs(s,w),h.addSparseInitializers(s,x),h.endGraph(s)}}g.Graph=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsModel(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsModel(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}irVersion(){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readInt64(this.bb_pos+s):this.bb.createLong(0,0)}opsetImport(s,r){let u=this.bb.__offset(this.bb_pos,6);return u?(r||new c.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*s),this.bb):null}opsetImportLength(){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__vector_len(this.bb_pos+s):0}producerName(s){let r=this.bb.__offset(this.bb_pos,8);return r?this.bb.__string(this.bb_pos+r,s):null}producerVersion(s){let r=this.bb.__offset(this.bb_pos,10);return r?this.bb.__string(this.bb_pos+r,s):null}domain(s){let r=this.bb.__offset(this.bb_pos,12);return r?this.bb.__string(this.bb_pos+r,s):null}modelVersion(){let s=this.bb.__offset(this.bb_pos,14);return s?this.bb.readInt64(this.bb_pos+s):this.bb.createLong(0,0)}docString(s){let r=this.bb.__offset(this.bb_pos,16);return r?this.bb.__string(this.bb_pos+r,s):null}graph(s){let r=this.bb.__offset(this.bb_pos,18);return r?(s||new c.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}graphDocString(s){let r=this.bb.__offset(this.bb_pos,20);return r?this.bb.__string(this.bb_pos+r,s):null}static startModel(s){s.startObject(9)}static addIrVersion(s,r){s.addFieldInt64(0,r,s.createLong(0,0))}static addOpsetImport(s,r){s.addFieldOffset(1,r,0)}static createOpsetImportVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addOffset(r[u]);return s.endVector()}static startOpsetImportVector(s,r){s.startVector(4,r,4)}static addProducerName(s,r){s.addFieldOffset(2,r,0)}static addProducerVersion(s,r){s.addFieldOffset(3,r,0)}static addDomain(s,r){s.addFieldOffset(4,r,0)}static addModelVersion(s,r){s.addFieldInt64(5,r,s.createLong(0,0))}static addDocString(s,r){s.addFieldOffset(6,r,0)}static addGraph(s,r){s.addFieldOffset(7,r,0)}static addGraphDocString(s,r){s.addFieldOffset(8,r,0)}static endModel(s){return s.endObject()}static createModel(s,r,u,d,m,b,y,w,x,_){return h.startModel(s),h.addIrVersion(s,r),h.addOpsetImport(s,u),h.addProducerName(s,d),h.addProducerVersion(s,m),h.addDomain(s,b),h.addModelVersion(s,y),h.addDocString(s,w),h.addGraph(s,x),h.addGraphDocString(s,_),h.endModel(s)}}g.Model=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsKernelCreateInfos(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsKernelCreateInfos(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}nodeIndices(s){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.readUint32(this.bb.__vector(this.bb_pos+r)+4*s):0}nodeIndicesLength(){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__vector_len(this.bb_pos+s):0}nodeIndicesArray(){let s=this.bb.__offset(this.bb_pos,4);return s?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+s),this.bb.__vector_len(this.bb_pos+s)):null}kernelDefHashes(s){let r=this.bb.__offset(this.bb_pos,6);return r?this.bb.readUint64(this.bb.__vector(this.bb_pos+r)+8*s):this.bb.createLong(0,0)}kernelDefHashesLength(){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__vector_len(this.bb_pos+s):0}static startKernelCreateInfos(s){s.startObject(2)}static addNodeIndices(s,r){s.addFieldOffset(0,r,0)}static createNodeIndicesVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addInt32(r[u]);return s.endVector()}static startNodeIndicesVector(s,r){s.startVector(4,r,4)}static addKernelDefHashes(s,r){s.addFieldOffset(1,r,0)}static createKernelDefHashesVector(s,r){s.startVector(8,r.length,8);for(let u=r.length-1;u>=0;u--)s.addInt64(r[u]);return s.endVector()}static startKernelDefHashesVector(s,r){s.startVector(8,r,8)}static endKernelCreateInfos(s){return s.endObject()}static createKernelCreateInfos(s,r,u){return h.startKernelCreateInfos(s),h.addNodeIndices(s,r),h.addKernelDefHashes(s,u),h.endKernelCreateInfos(s)}}g.KernelCreateInfos=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsSubGraphSessionState(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsSubGraphSessionState(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}graphId(s){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,s):null}sessionState(s){let r=this.bb.__offset(this.bb_pos,6);return r?(s||new c.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}static startSubGraphSessionState(s){s.startObject(2)}static addGraphId(s,r){s.addFieldOffset(0,r,0)}static addSessionState(s,r){s.addFieldOffset(1,r,0)}static endSubGraphSessionState(s){let r=s.endObject();return s.requiredField(r,4),r}static createSubGraphSessionState(s,r,u){return h.startSubGraphSessionState(s),h.addGraphId(s,r),h.addSessionState(s,u),h.endSubGraphSessionState(s)}}g.SubGraphSessionState=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsSessionState(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsSessionState(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}kernels(s){let r=this.bb.__offset(this.bb_pos,4);return r?(s||new c.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}subGraphSessionStates(s,r){let u=this.bb.__offset(this.bb_pos,6);return u?(r||new c.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+u)+4*s),this.bb):null}subGraphSessionStatesLength(){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__vector_len(this.bb_pos+s):0}static startSessionState(s){s.startObject(2)}static addKernels(s,r){s.addFieldOffset(0,r,0)}static addSubGraphSessionStates(s,r){s.addFieldOffset(1,r,0)}static createSubGraphSessionStatesVector(s,r){s.startVector(4,r.length,4);for(let u=r.length-1;u>=0;u--)s.addOffset(r[u]);return s.endVector()}static startSubGraphSessionStatesVector(s,r){s.startVector(4,r,4)}static endSessionState(s){return s.endObject()}static createSessionState(s,r,u){return h.startSessionState(s),h.addKernels(s,r),h.addSubGraphSessionStates(s,u),h.endSessionState(s)}}g.SessionState=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(c){(function(f){(function(g){class h{constructor(){this.bb=null,this.bb_pos=0}__init(s,r){return this.bb_pos=s,this.bb=r,this}static getRootAsInferenceSession(s,r){return(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static getSizePrefixedRootAsInferenceSession(s,r){return s.setPosition(s.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new h).__init(s.readInt32(s.position())+s.position(),s)}static bufferHasIdentifier(s){return s.__has_identifier("ORTM")}ortVersion(s){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,s):null}model(s){let r=this.bb.__offset(this.bb_pos,6);return r?(s||new c.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}sessionState(s){let r=this.bb.__offset(this.bb_pos,8);return r?(s||new c.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}static startInferenceSession(s){s.startObject(3)}static addOrtVersion(s,r){s.addFieldOffset(0,r,0)}static addModel(s,r){s.addFieldOffset(1,r,0)}static addSessionState(s,r){s.addFieldOffset(2,r,0)}static endInferenceSession(s){return s.endObject()}static finishInferenceSessionBuffer(s,r){s.finish(r,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(s,r){s.finish(r,"ORTM",!0)}static createInferenceSession(s,r,u,d){return h.startInferenceSession(s),h.addOrtVersion(s,r),h.addModel(s,u),h.addSessionState(s,d),h.endInferenceSession(s)}}g.InferenceSession=h})(f.fbs||(f.fbs={}))})(c.experimental||(c.experimental={}))}(t.onnxruntime||(t.onnxruntime={}))},1723:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.OnnxjsSessionHandler=void 0;const n=e(8453),a=e(9240);t.OnnxjsSessionHandler=class{constructor(l){this.session=l,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(l,c,f){const g=new Map;for(const s in l)if(Object.hasOwnProperty.call(l,s)){const r=l[s];g.set(s,new a.Tensor(r.dims,r.type,void 0,void 0,r.data))}const h=await this.session.run(g),p={};return h.forEach((s,r)=>{p[r]=new n.Tensor(s.type,s.data,s.dims)}),p}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6027:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Session=void 0;const n=e(7067),a=e(1296),l=e(1975),c=e(6496),f=e(1315),g=e(1745);t.Session=class{constructor(h={}){this._initialized=!1,this.backendHint=h.backendHint,this.profiler=f.Profiler.create(h.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(h,p,s){await this.profiler.event("session","Session.loadModel",async()=>{const r=await(0,l.resolveBackend)(this.backendHint);if(this.sessionHandler=r.createSessionHandler(this.context),this._model=new g.Model,typeof h=="string"){const u=h.endsWith(".ort");if(typeof fetch>"u"){const d=await(0,a.promisify)(n.readFile)(h);this.initialize(d,u)}else{const d=await fetch(h),m=await d.arrayBuffer();this.initialize(new Uint8Array(m),u)}}else if(ArrayBuffer.isView(h))this.initialize(h);else{const u=new Uint8Array(h,p||0,s||h.byteLength);this.initialize(u)}})}initialize(h,p){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{const s=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(h,s,p),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new c.ExecutionPlan(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(h){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{const p=this.normalizeAndValidateInputs(h),s=await this._executionPlan.execute(this.sessionHandler,p);return this.createOutput(s)})}normalizeAndValidateInputs(h){const p=this._model.graph.getInputNames();if(Array.isArray(h)){if(h.length!==p.length)throw new Error(`incorrect input array length: expected ${p.length} but got ${h.length}`)}else{if(h.size!==p.length)throw new Error(`incorrect input map size: expected ${p.length} but got ${h.size}`);const s=new Array(h.size);let r=0;for(let u=0;u<p.length;++u){const d=h.get(p[u]);if(!d)throw new Error(`missing input tensor for: '${name}'`);s[r++]=d}h=s}if(this.context.graphInputTypes&&this.context.graphInputTypes.length!==0&&this.context.graphInputDims&&this.context.graphInputDims.length!==0)this.validateInputTensorDims(this.context.graphInputDims,h,!1);else{const s=this._model.graph.getInputIndices(),r=this._model.graph.getValues(),u=new Array(s.length);for(let d=0;d<s.length;++d){const m=r[s[d]];u[d]=m.type.shape.dims,this.context.graphInputTypes.push(m.type.tensorType),this.context.graphInputDims.push(h[d].dims)}this.validateInputTensorDims(u,h,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,h),h}validateInputTensorTypes(h,p){for(let s=0;s<p.length;s++){const r=h[s],u=p[s].type;if(r!==u)throw new Error(`input tensor[${s}] check failed: expected type '${r}' but got ${u}`)}}validateInputTensorDims(h,p,s){for(let r=0;r<p.length;r++){const u=h[r],d=p[r].dims;if(!this.compareTensorDims(u,d,s))throw new Error(`input tensor[${r}] check failed: expected shape '[${u.join(",")}]' but got [${d.join(",")}]`)}}compareTensorDims(h,p,s){if(h.length!==p.length)return!1;for(let r=0;r<h.length;++r)if(h[r]!==p[r]&&(!s||h[r]!==0))return!1;return!0}createOutput(h){const p=this._model.graph.getOutputNames();if(h.length!==p.length)throw new Error("expected number of outputs do not match number of generated outputs");const s=new Map;for(let r=0;r<p.length;++r)s.set(p[r],h[r]);return s}initializeOps(h){const p=h.getNodes();this._ops=new Array(p.length);for(let s=0;s<p.length;s++)this._ops[s]=this.sessionHandler.resolve(p[s],this._model.opsets,h)}}},9240:function(o,t,e){var n=this&&this.__importDefault||function(m){return m&&m.__esModule?m:{default:m}};Object.defineProperty(t,"__esModule",{value:!0}),t.Tensor=void 0;const a=e(3442),l=n(e(3720)),c=e(1446),f=e(1287),g=e(7273);var h=f.onnxruntime.experimental.fbs;class p{get data(){if(this.cache===void 0){const b=this.dataProvider(this.dataId);if(b.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=b}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(b){return this.data[g.ShapeUtil.indicesToOffset(b,this.strides)]}set(b,y){this.data[g.ShapeUtil.indicesToOffset(b,this.strides)]=y}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=g.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(b,y,w,x,_,v=a.Guid.create()){this.dims=b,this.type=y,this.dataProvider=w,this.asyncDataProvider=x,this.cache=_,this.dataId=v,this.size=g.ShapeUtil.validateDimsAndCalcSize(b);const E=this.size,I=w===void 0&&x===void 0&&_===void 0;if(_!==void 0&&_.length!==E)throw new RangeError("Input dims doesn't match data length.");if(y==="string"){if(!(_===void 0||Array.isArray(_)&&_.every(S=>typeof S=="string")))throw new TypeError("cache should be a string array");I&&(this.cache=new Array(E))}else{if(_!==void 0){const S=r(y);if(!(_ instanceof S))throw new TypeError(`cache should be type ${S.name}`)}if(I){const S=new ArrayBuffer(E*function(T){switch(T){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${T}`)}}(y));this.cache=function(T,A){return new(r(A))(T)}(S,y)}}}static fromProto(b){if(!b)throw new Error("cannot construct Value from an empty tensor");const y=g.ProtoUtil.tensorDataTypeFromProto(b.dataType),w=g.ProtoUtil.tensorDimsFromProto(b.dims),x=new p(w,y);if(y==="string")b.stringData.forEach((_,v)=>{x.data[v]=(0,g.decodeUtf8String)(_)});else if(b.rawData&&typeof b.rawData.byteLength=="number"&&b.rawData.byteLength>0){const _=x.data,v=new DataView(b.rawData.buffer,b.rawData.byteOffset,b.rawData.byteLength),E=s(b.dataType),I=b.rawData.byteLength/E;if(b.rawData.byteLength%E!=0)throw new Error("invalid buffer length");if(_.length!==I)throw new Error("buffer length mismatch");for(let S=0;S<I;S++){const T=d(v,b.dataType,S*E);_[S]=T}}else{let _;switch(b.dataType){case c.onnx.TensorProto.DataType.FLOAT:_=b.floatData;break;case c.onnx.TensorProto.DataType.INT32:case c.onnx.TensorProto.DataType.INT16:case c.onnx.TensorProto.DataType.UINT16:case c.onnx.TensorProto.DataType.INT8:case c.onnx.TensorProto.DataType.UINT8:case c.onnx.TensorProto.DataType.BOOL:_=b.int32Data;break;case c.onnx.TensorProto.DataType.INT64:_=b.int64Data;break;case c.onnx.TensorProto.DataType.DOUBLE:_=b.doubleData;break;case c.onnx.TensorProto.DataType.UINT32:case c.onnx.TensorProto.DataType.UINT64:_=b.uint64Data;break;default:throw new Error("unspecific error")}if(_==null)throw new Error("failed to populate data from a tensorproto value");const v=x.data;if(v.length!==_.length)throw new Error("array length mismatch");for(let E=0;E<_.length;E++){const I=_[E];l.default.isLong(I)?v[E]=u(I,b.dataType):v[E]=I}}return x}static fromData(b,y,w){return new p(y,w,void 0,void 0,b)}static fromOrtTensor(b){if(!b)throw new Error("cannot construct Value from an empty tensor");const y=g.ProtoUtil.tensorDimsFromORTFormat(b),w=g.ProtoUtil.tensorDataTypeFromProto(b.dataType()),x=new p(y,w);if(w==="string")for(let _=0;_<b.stringDataLength();_++)x.data[_]=b.stringData(_);else if(b.rawDataArray()&&typeof b.rawDataLength()=="number"&&b.rawDataLength()>0){const _=x.data,v=new DataView(b.rawDataArray().buffer,b.rawDataArray().byteOffset,b.rawDataLength()),E=s(b.dataType()),I=b.rawDataLength()/E;if(b.rawDataLength()%E!=0)throw new Error("invalid buffer length");if(_.length!==I)throw new Error("buffer length mismatch");for(let S=0;S<I;S++){const T=d(v,b.dataType(),S*E);_[S]=T}}return x}}function s(m){switch(m){case c.onnx.TensorProto.DataType.UINT8:case c.onnx.TensorProto.DataType.INT8:case c.onnx.TensorProto.DataType.BOOL:return 1;case c.onnx.TensorProto.DataType.UINT16:case c.onnx.TensorProto.DataType.INT16:return 2;case c.onnx.TensorProto.DataType.FLOAT:case c.onnx.TensorProto.DataType.INT32:case c.onnx.TensorProto.DataType.UINT32:return 4;case c.onnx.TensorProto.DataType.INT64:case c.onnx.TensorProto.DataType.DOUBLE:case c.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${c.onnx.TensorProto.DataType[m]}`)}}function r(m){switch(m){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function u(m,b){if(b===c.onnx.TensorProto.DataType.INT64||b===h.TensorDataType.INT64){if(m.greaterThanOrEqual(2147483648)||m.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(b!==c.onnx.TensorProto.DataType.UINT32&&b!==h.TensorDataType.UINT32&&b!==c.onnx.TensorProto.DataType.UINT64&&b!==h.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${c.onnx.TensorProto.DataType[b]}`);if(m.greaterThanOrEqual(4294967296)||m.lessThan(0))throw new TypeError("uint64 is not supported")}return m.toNumber()}function d(m,b,y){switch(b){case c.onnx.TensorProto.DataType.BOOL:case c.onnx.TensorProto.DataType.UINT8:return m.getUint8(y);case c.onnx.TensorProto.DataType.INT8:return m.getInt8(y);case c.onnx.TensorProto.DataType.UINT16:return m.getUint16(y,!0);case c.onnx.TensorProto.DataType.INT16:return m.getInt16(y,!0);case c.onnx.TensorProto.DataType.FLOAT:return m.getFloat32(y,!0);case c.onnx.TensorProto.DataType.INT32:return m.getInt32(y,!0);case c.onnx.TensorProto.DataType.UINT32:return m.getUint32(y,!0);case c.onnx.TensorProto.DataType.INT64:return u(l.default.fromBits(m.getUint32(y,!0),m.getUint32(y+4,!0),!1),b);case c.onnx.TensorProto.DataType.DOUBLE:return m.getFloat64(y,!0);case c.onnx.TensorProto.DataType.UINT64:return u(l.default.fromBits(m.getUint32(y,!0),m.getUint32(y+4,!0),!0),b);default:throw new Error(`cannot read from DataView for type ${c.onnx.TensorProto.DataType[b]}`)}}t.Tensor=p},7273:function(o,t,e){var n=this&&this.__importDefault||function(b){return b&&b.__esModule?b:{default:b}};Object.defineProperty(t,"__esModule",{value:!0}),t.decodeUtf8String=t.MAX_CLIP=t.MIN_CLIP=t.PoolConvUtil=t.ReduceUtil=t.SplitUtil=t.MathUtil=t.ShapeUtil=t.LongUtil=t.ProtoUtil=t.GemmUtil=t.arrayCopyHelper=t.BroadcastUtil=t.MatMulUtil=t.ArrayUtil=t.assert=t.checkInputsShape=void 0;const a=e(5686),l=n(e(3720)),c=e(1446),f=e(9240);t.checkInputsShape=function(b,...y){if(!b||b.length!==y.length)return!1;for(let w=0;w<b.length;w++)if(!b[w].dims||b[w].dims.length!==y[w])return!1;return!0},t.assert=function(b,y){if(!b)throw new Error(typeof y=="string"?y:y())},t.ArrayUtil=class{static arraysEqual(b,y){if(b.length!==y.length)return!1;for(let w=0;w<b.length;w++)if(b[w]!==y[w])return!1;return!0}};class g{static preprocessInputShapes(y,w){return[y.length===1?[1,y[0]]:y,w.length===1?[w[0],1]:w]}static postprocessOutputShape(y,w,x){w===1&&y.splice(y.length-2,1),x===1&&y.pop()}static calcMatMulShape(y,w){return y[1]!==w[0]?void 0:[y[0],w[1]]}}t.MatMulUtil=g;class h{static calcShape(y,w,x=!1){const _=y.length,v=w.length;if(_===0)return w;if(v===0)return y;const E=Math.max(y.length,w.length),I=new Array(E);if(x){if(_<2||v<2)return;const S=g.calcMatMulShape([y[_-2],y[_-1]],[w[v-2],w[v-1]]);if(S===void 0)return;[I[E-2],I[E-1]]=S}for(let S=x?3:1;S<=E;S++){const T=_-S<0?1:y[_-S],A=v-S<0?1:w[v-S];if(T!==A&&T>1&&A>1)return;I[E-S]=Math.max(T,A)}return I}static index(y,w){const x=new Array(w.length);return h.fillIndex(y,w,x),x}static fillIndex(y,w,x){const _=y.length-w.length;for(let v=0;v<w.length;v++)x[v]=y[_+v]%w[v]}static calc(y,w,x,_,v){const E=h.calcShape(y.dims,w.dims);if(E){if(_&&!r.areEqual(E,y.dims))return;const I=r.size(E),S=_?y:new f.Tensor(E,v||y.type);if(E.length===0)S.set([],x(y.get([]),w.get([])));else{const T=new Array(E.length),A=new Array(y.dims.length),O=new Array(w.dims.length);let $,D=0,M=0,F=!1,C=!1;y.dims.length===0&&(D=y.get([]),F=!0),w.dims.length===0&&(M=w.get([]),C=!0);for(let R=0;R<I;R++){$=R;for(let j=E.length-1;j>=0;j--)T[j]=$%E[j],$=Math.floor($/E[j]);F||(h.fillIndex(T,y.dims,A),D=y.get(A)),C||(h.fillIndex(T,w.dims,O),M=w.get(O)),S.set(T,x(D,M))}}return S}}static isValidBroadcast(y,w){const x=y.length,_=w.length;if(x>_)return!1;for(let v=1;v<=x;v++)if(y[x-v]!==1&&y[x-v]!==w[_-v])return!1;return!0}static getBroadcastDims(y,w){const x=y.length,_=[];for(let v=0;v<x;v++){const E=x-1-v,I=y[E]||1;(w[w.length-1-v]||1)>1&&I===1&&_.unshift(E)}return _}}t.BroadcastUtil=h,t.arrayCopyHelper=function(b,y,w,x,_){if(x<0||x>=y.length)throw new Error("sourceIndex out of bounds");if(w<0||w>=b.length)throw new Error("targetIndex out of bounds");if(x+_>y.length)throw new Error("source indices to be copied are outside bounds");if(w+_>b.length)throw new Error("target array is too small to hold result");for(let v=0;v<_;v++)b[w+v]=y[x+v]},t.GemmUtil=class{static getShapeOfGemmResult(b,y,w,x,_){if(b.length!==2||w.length!==2)throw new Error("shape need to be of size 2");let v,E,I;y?(v=b[1],E=b[0]):(v=b[0],E=b[1]);let S=-1;if(x?(I=w[0],S=1):(I=w[1],S=0),w[S]!==E)throw new Error("dimension mismatch");if(v<=0||I<=0||E<=0)throw new Error("invalid shape specified");if(_&&!h.isValidBroadcast(_,[v,I]))throw new Error("gemm: invalid bias shape for broadcast");return[v,I,E]}};class p{static tensorDataTypeFromProto(y){switch(y){case c.onnx.TensorProto.DataType.INT8:return"int8";case c.onnx.TensorProto.DataType.UINT8:return"uint8";case c.onnx.TensorProto.DataType.BOOL:return"bool";case c.onnx.TensorProto.DataType.INT16:return"int16";case c.onnx.TensorProto.DataType.UINT16:return"uint16";case c.onnx.TensorProto.DataType.INT32:return"int32";case c.onnx.TensorProto.DataType.UINT32:return"uint32";case c.onnx.TensorProto.DataType.FLOAT:return"float32";case c.onnx.TensorProto.DataType.DOUBLE:return"float64";case c.onnx.TensorProto.DataType.STRING:return"string";case c.onnx.TensorProto.DataType.INT64:return"int32";case c.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${c.onnx.TensorProto.DataType[y]}`)}}static tensorDataTypeStringToEnum(y){switch(y){case"int8":return c.onnx.TensorProto.DataType.INT8;case"uint8":return c.onnx.TensorProto.DataType.UINT8;case"bool":return c.onnx.TensorProto.DataType.BOOL;case"int16":return c.onnx.TensorProto.DataType.INT16;case"uint16":return c.onnx.TensorProto.DataType.UINT16;case"int32":return c.onnx.TensorProto.DataType.INT32;case"uint32":return c.onnx.TensorProto.DataType.UINT32;case"float32":return c.onnx.TensorProto.DataType.FLOAT;case"float64":return c.onnx.TensorProto.DataType.DOUBLE;case"string":return c.onnx.TensorProto.DataType.STRING;case"int64":return c.onnx.TensorProto.DataType.INT64;case"uint64":return c.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${y}`)}}static tensorDimsFromProto(y){return y.map(w=>l.default.isLong(w)?w.toNumber():w)}static tensorValueTypeFromProto(y){return{tensorType:p.tensorDataTypeFromProto(y.elemType),shape:{dims:p.tensorDimsFromProto(y.shape.dim.map(w=>w.dimValue))}}}static tensorDimsFromORTFormat(y){const w=[];for(let x=0;x<y.dimsLength();x++)w.push(s.longToNumber(y.dims(x)));return w}static tensorAttributesFromORTFormat(y){const w=[];for(let x=0;x<y.attributesLength();x++)w.push(y.attributes(x));return w}}t.ProtoUtil=p;class s{static longToNumber(y,w){return l.default.isLong(y)?y.toNumber():y instanceof a.flatbuffers.Long?l.default.fromValue({low:y.low,high:y.high,unsigned:w!=null&&w}).toNumber():y}static isLong(y){return l.default.isLong(y)||y instanceof a.flatbuffers.Long}}t.LongUtil=s;class r{static size(y){return r.getSizeFromDimensionRange(y,0,y.length)}static sizeFromDimension(y,w){if(w<0||w>y.length)throw new Error(`invalid dimension of ${w} for sizeFromDimension as Tensor has ${y.length} dimensions.`);return r.getSizeFromDimensionRange(y,w,y.length)}static sizeToDimension(y,w){if(w<0||w>y.length)throw new Error(`invalid dimension of ${w} for sizeToDimension as Tensor has ${y.length} dimensions.`);return r.getSizeFromDimensionRange(y,0,w)}static getSizeFromDimensionRange(y,w,x){let _=1;for(let v=w;v<x;v++){if(y[v]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");_*=y[v]}return _}static computeStrides(y){const w=y.length;if(w===0)return[];if(w===1)return[1];const x=new Array(w);x[w-1]=1,x[w-2]=y[w-1];for(let _=w-3;_>=0;--_)x[_]=x[_+1]*y[_+1];return x}static transpose(y){return y.slice().reverse()}static indicesToOffset(y,w,x){x===void 0&&(x=y.length);let _=0;for(let v=0;v<x;++v)_+=w[v]*y[v];return _}static offsetToIndices(y,w){const x=w.length;if(x===0)return[];if(x===1)return[y*w[0]];const _=new Array(w.length);for(let v=0;v<_.length-1;++v)_[v]=Math.floor(y/w[v]),y-=_[v]*w[v];return _[_.length-1]=y,_}static normalizeAxis(y,w){if(y<-w&&y>=w)throw new Error("unsupported axis for this operation.");return y<0?y+w:y}static normalizeAxes(y,w){return y.map(x=>this.normalizeAxis(x,w))}static incrementIndex(y,w,x){if(w.length===0||y.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(x===void 0)x=w.length;else if(x<=0||x>w.length)throw new Error("Incorrect axis to increment on");for(let _=x-1;_>=0&&(y[_]++,!(y[_]<w[_]));--_)y[_]=0}static calculateReshapedDims(y,w){if(w.length===0){if(y.length===0||r.size(y)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}const x=w.length,_=new Array(x);let v=-1,E=1;for(let S=0;S<x;S++){if(w[S]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(w[S]===-1){if(v!==-1)throw new Error("at most one dimension in shape hints can be -1");v=S}else{if(w[S]===0){if(S>=y.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");_[S]=y[S]}else _[S]=w[S];E*=_[S]}}const I=r.size(y);if(v!==-1){if(I%E!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${y}] Output shape: [${w}]`);_[v]=I/E}else if(E!==I)throw new Error("reshapedDims and originalDims don't have matching sizes");return _}static sortBasedOnPerm(y,w){return w?w.map(x=>y[x]):y.slice().reverse()}static padShape(y,w){const x=y.length;return y.map((_,v)=>_+w[v]+w[v+x])}static areEqual(y,w){return y.length===w.length&&y.every((x,_)=>x===w[_])}static validateDimsAndCalcSize(y){if(y.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let w=1;for(const x of y){if(!Number.isInteger(x))throw new TypeError(`Invalid shape: ${x} is not an integer`);if(x<0||x>2147483647)throw new TypeError(`Invalid shape: length ${x} is not allowed`);w*=x}return w}static flattenShape(y,w){w<0&&(w+=y.length);const x=y.reduce((v,E)=>v*E,1),_=y.slice(w).reduce((v,E)=>v*E,1);return[x/_,_]}static squeezeShape(y,w){const x=new Array;w=r.normalizeAxes(w,y.length);for(let _=0;_<y.length;_++){const v=w.indexOf(_)>=0;if(v&&y[_]!==1)throw new Error("squeeze an axis of size different than 1");(w.length===0&&y[_]>1||w.length>0&&!v)&&x.push(y[_])}return x}static unsqueezeShape(y,w){const x=new Array(y.length+w.length);x.fill(0);for(let v=0;v<w.length;v++){const E=r.normalizeAxis(w[v],x.length);if(E>=x.length)throw new Error("'axes' has an out of range axis");if(x[E]!==0)throw new Error("'axes' has a duplicate axis");x[E]=1}let _=0;for(let v=0;v<x.length;v++)x[v]===0&&(x[v]=y[_++]);if(_!==y.length)throw new Error("the unsqueezed dimension could not be established");return x}}t.ShapeUtil=r,t.MathUtil=class{static sqr(b,y,w,x,_){if(x<0||x>=y.length)throw new Error("sourceIndex out of bounds");if(w<0||w>=b.length)throw new Error("targetIndex out of bounds");if(x+_>y.length)throw new Error("source indices to be copied are outside bounds");if(w+_>b.length)throw new Error("target array is too small to hold result");for(let v=0;v<_;v++)b[w+v]+=Math.pow(y[x+v],2)}static axpy(b,y,w,x,_,v){if(x<0||x>=y.length)throw new Error("sourceIndex out of bounds");if(w<0||w>=b.length)throw new Error("targetIndex out of bounds");if(x+_>y.length)throw new Error("source indices to be copied are outside bounds");if(w+_>b.length)throw new Error("target array is too small to hold result");for(let E=0;E<_;E++)b[w+E]+=v*y[x+E]}static powx(b,y,w,x,_,v){if(x<0||x>=y.length)throw new Error("sourceIndex out of bounds");if(w<0||w>=b.length)throw new Error("targetIndex out of bounds");if(x+_>y.length)throw new Error("source indices to be copied are outside bounds");if(w+_>b.length)throw new Error("target array is too small to hold result");for(let E=0;E<_;E++)b[w+E]=Math.pow(y[x+E],v)}static mul(b,y,w,x,_){if(x<0||x>=y.length)throw new Error("sourceIndex out of bounds");if(w<0||w>=b.length)throw new Error("targetIndex out of bounds");if(x+_>y.length)throw new Error("source indices to be copied are outside bounds");if(w+_>b.length)throw new Error("target array is too small to hold result");for(let v=0;v<_;v++)b[w+v]=y[x+v]*b[w+v]}};class u{static splitShape(y,w,x,_){if(x.length===0){if(!_)throw new Error("need to know number of outputs when the 'split' attribute is not specified");u.determineSplit(y[w],_,x)}const v=[],E=[0];for(let I=0;I<x.length;++I){I!==0&&E.push(E[I-1]+x[I-1]);const S=y.slice();S[w]=x[I],v.push(S)}return[v,E]}static determineSplit(y,w,x){if(y%w!=0)throw new Error("cannot split tensor to equal sized parts");for(let _=0;_<w;++_)x.push(y/w)}}t.SplitUtil=u;class d{static calcReduce(y,w,x,_,v){const E=y.dims.slice(0);w.length===0&&E.forEach((D,M)=>w.push(M));const I=d.calcReduceShape(E,w,!0),S=r.size(I),T=new f.Tensor(I,y.type),A=r.computeStrides(I),O=r.computeStrides(E),$=new Array(E.length);for(let D=0;D<S;D++){const M=r.offsetToIndices(D,A);h.fillIndex(M,E,$),T.set(M,d.calcReduceByAxis(y.numberData,w,E,0,r.indicesToOffset($,O),_,v))}return x?T:new f.Tensor(d.calcReduceShape(E,w,x),T.type,void 0,void 0,T.data,T.dataId)}static calcReduceByAxis(y,w,x,_,v,E,I){let S=0;if(_>=w.length)return E(y[v]);const T=w[_],A=T>=x.length?1:r.size(x.slice(T+1));for(let O=0;O<x[T];O++)S=O===0?d.calcReduceByAxis(y,w,x,_+1,v,E,I):I(S,d.calcReduceByAxis(y,w,x,_+1,v,E,I)),v+=A;return S}static calcReduceShape(y,w,x){const _=y.slice();for(let v=0;v<w.length;v++)_[w[v]]=x?1:0;return _.filter(v=>v!==0)}}t.ReduceUtil=d;class m{static adjustPoolAttributes(y,w,x,_,v,E){if(!y&&x.length!==w.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(y)for(let I=0;I<w.length-2;I++)I>=x.length?x.push(w[I+2]):x[I]=w[I+2];for(let I=0;I<x.length;I++)if(I<_.length){if(_[I]<0)throw new Error("strides should be greater than or equal to 1")}else _.push(1);for(let I=0;I<x.length;I++)if(I<v.length){if(v[I]<0)throw new Error("dilations should be greater than or equal to 1")}else v.push(1);for(let I=0;I<2*x.length;I++)if(I<E.length){if(E[I]<0)throw new Error("pad should be greater than or equal to 1")}else E.push(0);for(let I=0;I<x.length;I++){if(x[I]<=0)throw new Error("kernel shapes need to be greater than 0");if(E[I]>=x[I]||E[I+x.length]>=x[I])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(y,w,x,_,v,E){if(E){if(v.length!==2*(y.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(w.length!==y.length-2)throw new Error("length of strides should be the length of data dimensions");if(_.length!==y.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let I=0;I<y.length-2;I++)m.adjustPadAndReturnShape(y[I+2],w[I],x[I],_[I],v,I,I+y.length-2,E)}}static computePoolOutputShape(y,w,x,_,v,E,I){if(w.length<=0)throw new Error("input shape must be of size greater than 0");const S=[w[0],w[1]];return m.computeShapeHelper(y,w,S,x,_,v,E,I),S}static computeConvOutputShape(y,w,x,_,v,E,I){if(y.length<=0||w.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const S=[y[0],w[0]];return m.computeShapeHelper(!1,y,S,x,_,v,E,I),S}static computeShapeHelper(y,w,x,_,v,E,I,S){if(y)for(let T=0;T<w.length-2;T++)x.push(1);else for(let T=0;T<w.length-2;T++)x.push(m.adjustPadAndReturnShape(w[T+2],_[T],v[T],E[T],I,T,T+w.length-2,S))}static adjustPadAndReturnShape(y,w,x,_,v,E,I,S){const T=x*(_-1)+1;if(!S||S==="NOTSET")return Math.floor((y+v[E]+v[I]-T)/w+1);switch(S){case"VALID":return v[E]=0,v[I]=0,Math.floor((y-T)/w+1);case"SAME_LOWER":case"SAME_UPPER":if(x!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const A=((y+w-1)/w-1)*w+_-y;return v[E]=Math.floor(S==="SAME_LOWER"?(A+1)/2:A/2),v[I]=A-v[E],Math.floor((y+A-_)/w+1)}default:throw new Error("Unsupported AutoPad type")}}}t.PoolConvUtil=m,t.MIN_CLIP=-34028234663852886e22,t.MAX_CLIP=34028234663852886e22,t.decodeUtf8String=function(b){return new TextDecoder().decode(b)}},3838:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.WebGpuBackend=void 0;const n=e(8453),a=e(4955),l=e(7771),c=e(8510),f=e(8305);t.WebGpuBackend=class{constructor(){this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.pendingDispatchNumber=0,this.profilingEnabled=!1}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let g=this.kernelCustomData.get(this.currentKernelId);return g||(g={},this.kernelCustomData.set(this.currentKernelId,g)),g}async initialize(){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");const g=await navigator.gpu.requestAdapter();if(!g)throw new Error("WebGpuBackend: Failed to get GPU adapter.");const h={requiredLimits:{maxComputeWorkgroupStorageSize:g.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:g.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:g.limits.maxStorageBufferBindingSize}};g.features.has("timestamp-query-inside-passes")&&n.env.webgpu.profilingMode==="default"&&(this.profilingEnabled=!0,h.requiredFeatures=["timestamp-query-inside-passes"]),this.device=await g.requestDevice(h),this.gpuDataManager=(0,l.createGpuDataManager)(this),this.programManager=new f.ProgramManager(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,this.device.onuncapturederror=p=>{p.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${p.error.message}`)},this.profilingEnabled&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2}))}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0}run(g,h,p,s,r){if(h.length!==g.inputTypes.length)throw new Error(`Input size must be equal to ${g.inputTypes.length}.`);const u=[];for(let v=0;v<h.length;++v){const E=this.gpuDataManager.get(h[v].data);if(!E)throw new Error(`no GPU data for input: ${h[v].data}`);u[v]=E}const d=((v,E,I)=>{const S=E.map(O=>`${O.join(",")}`).join("_"),T=I.join("_");let A=v.name;return v.cacheHint&&(A+="["+v.cacheHint+"]"),A+=":"+S+";"+T,A})(g,h.map(v=>v.dims),u.map(v=>v.type));let m=this.programManager.getArtifact(d);const b=m?m.programInfo:typeof g.get=="function"?g.get():g,y=p.length===0?b.outputs.map((v,E)=>E):p;if(y.length!==b.outputs.length)throw new Error(`Output size ${y.length} must be equal to ${b.outputs.length}.`);const w=[],x=[];for(let v=0;v<b.outputs.length;++v){if(!Number.isInteger(y[v])||y[v]<-2||y[v]>=b.outputs.length)throw new Error(`Invalid output index: ${y[v]}`);const E=y[v]===-1,I=y[v]===-2,S=E||I?r(b.outputs[v].dataType,b.outputs[v].dims):s(y[v],b.outputs[v].dataType,b.outputs[v].dims),T=this.gpuDataManager.get(S.data);if(!T)throw new Error(`no GPU data for output: ${S.data}`);if(E&&this.temporaryData.push(T),I){let A=this.kernelPersistentData.get(this.currentKernelId);A||(A=[],this.kernelPersistentData.set(this.currentKernelId,A)),A.push(T)}w.push(S),x.push(T)}const _=this.programManager.normalizeDispatchGroupSize(b.dispatchGroup(h));return m||(m=this.programManager.build(b,_),this.programManager.setArtifact(d,m)),(0,a.LOG_DEBUG)("info",()=>`[ProgramManager] run "${b.name}" (key=${d}) with ${_[0]}x${_[1]}x${_[2]}`),this.programManager.run(m,u,x,_),w}upload(g,h){this.gpuDataManager.upload(g,h)}memcpy(g,h){this.gpuDataManager.memcpy(g,h)}async download(g,h){const p=await this.gpuDataManager.download(g);h().set(new Uint8Array(p))}alloc(g){return this.gpuDataManager.create(g).id}free(g){return this.gpuDataManager.release(g)}createKernel(g,h,p){const s=c.WEBGPU_OP_RESOLVE_RULES.get(g);if(!s)throw new Error(`kernel not implemented: ${g}`);this.kernels.set(h,[g,s[0],[s[1],p]])}releaseKernel(g){const h=this.kernelPersistentData.get(g);if(h){for(const p of h)this.gpuDataManager.release(p.id);this.kernelPersistentData.delete(g)}this.kernelCustomData.delete(g),this.kernels.delete(g)}computeKernel(g,h){const p=this.kernels.get(g);if(!p)throw new Error(`kernel not created: ${g}`);const[s,r,u]=p;if(this.currentKernelId!==null)throw new Error(`kernel "${s}" is not allowed to be called recursively`);this.currentKernelId=g,u[0]&&(u[1]=u[0](u[1]),u[0]=void 0),(0,a.LOG_DEBUG)("info",()=>`[WebGPU] Start to run kernel "${s}"...`),this.temporaryData=[];try{return r(h,u[1]),0}catch(d){return(0,a.LOG_DEBUG)("warning",`[WebGPU] Kernel "${s}" failed. Error: ${d}`),1}finally{for(const d of this.temporaryData)this.gpuDataManager.release(d.id);this.temporaryData=[],this.currentKernelId=null}}}},7675:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.init=void 0;const n=e(7917),a=e(3838),l=e(4955),c=e(6952);class f{constructor(p,s,r,u){this.module=p,this.dataType=s,this.data=r,this.dims=u}getFloat32Array(){return new Float32Array(this.module.HEAP8.buffer,this.data,c.ShapeUtil.size(this.dims))}reshape(p){if(c.ShapeUtil.size(p)!==c.ShapeUtil.size(this.dims))throw new Error("Invalid new shape");return new f(this.module,this.dataType,this.data,p)}}class g{get customData(){return this.backend.currentKernelCustomData}constructor(p,s,r){this.module=p,this.backend=s;const u=p.HEAPU32;let d=r>>2;this.opKernelContext=u[d++];const m=u[d++],b=[];for(let y=0;y<m;y++){const w=u[d++],x=u[d++],_=u[d++],v=[];for(let E=0;E<_;E++)v.push(u[d++]);b.push(new f(p,w,x,v))}this.inputs=b}compute(p,s){var r,u,d;const m=(u=(r=s==null?void 0:s.inputs)===null||r===void 0?void 0:r.map(y=>typeof y=="number"?this.inputs[y]:y))!==null&&u!==void 0?u:this.inputs,b=(d=s==null?void 0:s.outputs)!==null&&d!==void 0?d:[];return this.backend.run(p,m,b,(y,w,x)=>new f(this.module,w,this.output(y,x),x),(y,w)=>{const x=(0,n.getTensorElementSize)(y);if(!x)throw new Error(`Unsupported data type: ${y}`);const _=x*c.ShapeUtil.size(w);return new f(this.module,y,this.backend.gpuDataManager.create(_).id,w)})}output(p,s){const r=this.module.stackSave();try{const u=this.module.stackAlloc(4*(1+s.length));let d=u>>2;this.module.HEAPU32[d++]=s.length;for(let m=0;m<s.length;m++)this.module.HEAPU32[d++]=s[m];return this.module._JsepOutput(this.opKernelContext,p,u)}finally{this.module.stackRestore(r)}}}t.init=async h=>{const p=h.jsepInit;if(p&&navigator.gpu){const s=new a.WebGpuBackend;await s.initialize(),p({backend:s},r=>s.alloc(r),r=>s.free(r),(r,u,d,m=!1)=>{if(m)(0,l.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${r}, dst=${u}, size=${d}`),s.memcpy(r,u);else{(0,l.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${r}, gpuDataId=${u}, size=${d}`);const b=h.HEAPU8.subarray(r,r+d);s.upload(u,b)}},async(r,u,d)=>{(0,l.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${r}, dataOffset=${u}, size=${d}`),await s.download(r,()=>h.HEAPU8.subarray(u,u+d))},(r,u,d)=>s.createKernel(r,u,d),r=>s.releaseKernel(r),(r,u)=>{(0,l.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepRun: kernel=${r}, contextDataOffset=${u}`);const d=new g(h,s,u);return s.computeKernel(r,d)})}}},4955:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.LOG_DEBUG=t.LOG=void 0;const n=e(8453),a=e(7917),l=["V","I","W","E","F"];t.LOG=(c,f)=>{const g=(0,a.logLevelStringToEnum)(c);var h,p;g>=(0,a.logLevelStringToEnum)(n.env.logLevel)&&(h=g,p=typeof f=="function"?f():f,console.log(`[${l[h]},${new Date().toISOString()}]${p}`))},t.LOG_DEBUG=(...c)=>{n.env.debug&&(0,t.LOG)(...c)}},6952:(o,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.MAX_CLIP=t.MIN_CLIP=t.GemmUtil=t.PoolConvUtil=t.ShapeUtil=t.BroadcastUtil=t.MatMulUtil=void 0;class e{static calcMatMulShape(f,g){return f[1]!==g[0]?void 0:[f[0],g[1]]}}t.MatMulUtil=e;class n{static calcShape(f,g,h=!1){const p=f.length,s=g.length;if(p===0)return g;if(s===0)return f;const r=Math.max(f.length,g.length),u=new Array(r);if(h){if(p<2||s<2)return;const d=e.calcMatMulShape([f[p-2],f[p-1]],[g[s-2],g[s-1]]);if(d===void 0)return;[u[r-2],u[r-1]]=d}for(let d=h?3:1;d<=r;d++){const m=p-d<0?1:f[p-d],b=s-d<0?1:g[s-d];if(m!==b&&m>1&&b>1)return;u[r-d]=Math.max(m,b)}return u}static isValidBroadcast(f,g){const h=f.length,p=g.length;if(h>p)return!1;for(let s=1;s<=h;s++)if(f[h-s]!==1&&f[h-s]!==g[p-s])return!1;return!0}}t.BroadcastUtil=n;class a{static size(f){return a.getSizeFromDimensionRange(f,0,f.length)}static sizeFromDimension(f,g){if(g<0||g>f.length)throw new Error(`invalid dimension of ${g} for sizeFromDimension as Tensor has ${f.length} dimensions.`);return a.getSizeFromDimensionRange(f,g,f.length)}static sizeToDimension(f,g){if(g<0||g>f.length)throw new Error(`invalid dimension of ${g} for sizeToDimension as Tensor has ${f.length} dimensions.`);return a.getSizeFromDimensionRange(f,0,g)}static getSizeFromDimensionRange(f,g,h){let p=1;for(let s=g;s<h;s++){if(f[s]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");p*=f[s]}return p}static computeStrides(f){const g=f.length;if(g===0)return[];if(g===1)return[1];const h=new Array(g);h[g-1]=1,h[g-2]=f[g-1];for(let p=g-3;p>=0;--p)h[p]=h[p+1]*f[p+1];return h}static normalizeAxis(f,g){if(f<-g&&f>=g)throw new Error("unsupported axis for this operation.");return f<0?f+g:f}static normalizeAxes(f,g){return f.map(h=>this.normalizeAxis(h,g??f.length))}static sortBasedOnPerm(f,g){return g?g.map(h=>f[h]):f.slice().reverse()}static padShape(f,g){const h=f.length;return f.map((p,s)=>p+g[s]+g[s+h])}static areEqual(f,g){return f.length===g.length&&f.every((h,p)=>h===g[p])}}t.ShapeUtil=a;class l{static adjustPoolAttributes(f,g,h,p,s,r){if(!f&&h.length!==g.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(f)for(let u=0;u<g.length-2;u++)u>=h.length?h.push(g[u+2]):h[u]=g[u+2];for(let u=0;u<h.length;u++)if(u<p.length){if(p[u]<0)throw new Error("strides should be greater than or equal to 1")}else p.push(1);for(let u=0;u<h.length;u++)if(u<s.length){if(s[u]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let u=0;u<2*h.length;u++)if(u<r.length){if(r[u]<0)throw new Error("pad should be greater than or equal to 1")}else r.push(0);for(let u=0;u<h.length;u++){if(h[u]<=0)throw new Error("kernel shapes need to be greater than 0");if(r[u]>=h[u]||r[u+h.length]>=h[u])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(f,g,h,p,s,r,u){if(u){if(s.length!==2*(f.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(g.length!==f.length-2)throw new Error("length of strides should be the length of data dimensions");if(p.length!==f.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let d=0;d<f.length-2;d++)l.adjustPadAndReturnShape(f[d+(r?1:2)],g[d],h[d],p[d],s,d,d+f.length-2,u)}}static computePoolOutputShape(f,g,h,p,s,r,u){if(g.length<=0)throw new Error("input shape must be of size greater than 0");const d=[g[0],g[1]];return l.computeShapeHelper(f,g,d,h,p,s,r,u),d}static computeConvOutputShape(f,g,h,p,s,r,u){if(f.length<=0||g.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const d=[f[0],g[0]];return l.computeShapeHelper(!1,f,d,h,p,s,r,u),d}static computeShapeHelper(f,g,h,p,s,r,u,d){if(f)for(let m=0;m<g.length-2;m++)h.push(1);else for(let m=0;m<g.length-2;m++)h.push(l.adjustPadAndReturnShape(g[m+2],p[m],s[m],r[m],u,m,m+g.length-2,d))}static adjustPadAndReturnShape(f,g,h,p,s,r,u,d){const m=h*(p-1)+1;if(!d||d==="NOTSET")return Math.floor((f+s[r]+s[u]-m)/g+1);switch(d){case"VALID":return s[r]=0,s[u]=0,Math.floor((f-m)/g+1);case"SAME_LOWER":case"SAME_UPPER":if(h!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const b=((f+g-1)/g-1)*g+p-f;return s[r]=Math.floor(d==="SAME_LOWER"?(b+1)/2:b/2),s[u]=b-s[r],Math.floor((f+b-p)/g+1)}default:throw new Error("Unsupported AutoPad type")}}}t.PoolConvUtil=l,t.GemmUtil=class{static getShapeOfGemmResult(c,f,g,h,p){if(c.length!==2||g.length!==2)throw new Error("shape need to be of size 2");let s,r,u;f?(s=c[1],r=c[0]):(s=c[0],r=c[1]);let d=-1;if(h?(u=g[0],d=1):(u=g[1],d=0),g[d]!==r)throw new Error("dimension mismatch");if(s<=0||u<=0||r<=0)throw new Error("invalid shape specified");if(p&&!n.isValidBroadcast(p,[s,u]))throw new Error("gemm: invalid bias shape for broadcast");return[s,u,r]}},t.MIN_CLIP=-34028234663852886e22,t.MAX_CLIP=34028234663852886e22},387:(o,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createAttributeWithCacheKey=void 0;class e{constructor(a){Object.assign(this,a)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(a=>`${this[a]}`).join(";")),this._cacheKey}}t.createAttributeWithCacheKey=n=>new e(n)},7771:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createGpuDataManager=void 0;const n=e(4955),a=e(1163),l=g=>16*Math.ceil(g/16);let c=0;class f{constructor(h){this.backend=h,this.storageCache=new Map,this.downloadCache=new Map,this.buffersForUploadingPending=[],this.buffersPending=[]}upload(h,p){const s=p.buffer,r=p.byteOffset,u=p.byteLength,d=l(u),m=this.storageCache.get(h);if(!m)throw new Error("gpu data for uploading does not exist");if(m.originalSize!==u)throw new Error(`inconsistent data size. gpu data size=${m.originalSize}, data size=${u}`);const b=this.backend.device.createBuffer({mappedAtCreation:!0,size:d,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),y=b.getMappedRange();new Uint8Array(y).set(new Uint8Array(s,r,u)),b.unmap();const w=this.backend.getCommandEncoder();this.backend.endComputePass(),w.copyBufferToBuffer(b,0,m.gpuData.buffer,0,d),(0,n.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${h})`),this.buffersForUploadingPending.push(b)}memcpy(h,p){const s=this.storageCache.get(h);if(!s)throw new Error("source gpu data for memcpy does not exist");const r=this.storageCache.get(p);if(!r)throw new Error("destination gpu data for memcpy does not exist");if(s.originalSize!==r.originalSize)throw new Error("inconsistent source and destination gpu data size");const u=l(s.originalSize);this.backend.getCommandEncoder().copyBufferToBuffer(s.gpuData.buffer,0,r.gpuData.buffer,0,u)}create(h,p=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){const s=l(h),r=this.backend.device.createBuffer({size:s,usage:p}),u={id:c++,type:a.GpuDataType.default,buffer:r};return this.storageCache.set(u.id,{gpuData:u,originalSize:h}),(0,n.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.create(size=${h}) => id=${u.id}`),u}get(h){var p;return(p=this.storageCache.get(h))===null||p===void 0?void 0:p.gpuData}release(h){const p=this.storageCache.get(h);if(!p)throw new Error("releasing data does not exist");return(0,n.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.release(id=${h}), gpuDataId=${p.gpuData.id}`),this.storageCache.delete(h),this.buffersPending.push(p.gpuData.buffer),this.downloadCache.get(h)&&this.downloadCache.delete(h),p.originalSize}async download(h){const p=this.downloadCache.get(h);if(p)return p.data;const s=this.storageCache.get(h);if(!s)throw new Error("data does not exist");const r=this.backend.getCommandEncoder();this.backend.endComputePass();const u=this.backend.device.createBuffer({size:s.originalSize,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});r.copyBufferToBuffer(s.gpuData.buffer,0,u,0,s.originalSize),this.backend.flush();const d=new Promise(m=>{u.mapAsync(GPUMapMode.READ).then(()=>{const b=u.getMappedRange().slice(0);u.destroy(),m(b)})});return this.downloadCache.set(h,{data:d}),d}refreshPendingBuffers(){for(const h of this.buffersForUploadingPending)h.destroy();for(const h of this.buffersPending)h.destroy()}}t.createGpuDataManager=(...g)=>new f(...g)},8510:function(o,t,e){var n=this&&this.__createBinding||(Object.create?function(u,d,m,b){b===void 0&&(b=m);var y=Object.getOwnPropertyDescriptor(d,m);y&&!("get"in y?!d.__esModule:y.writable||y.configurable)||(y={enumerable:!0,get:function(){return d[m]}}),Object.defineProperty(u,b,y)}:function(u,d,m,b){b===void 0&&(b=m),u[b]=d[m]}),a=this&&this.__setModuleDefault||(Object.create?function(u,d){Object.defineProperty(u,"default",{enumerable:!0,value:d})}:function(u,d){u.default=d}),l=this&&this.__importStar||function(u){if(u&&u.__esModule)return u;var d={};if(u!=null)for(var m in u)m!=="default"&&Object.prototype.hasOwnProperty.call(u,m)&&n(d,u,m);return a(d,u),d};Object.defineProperty(t,"__esModule",{value:!0}),t.WEBGPU_OP_RESOLVE_RULES=void 0;const c=l(e(504)),f=e(9770),g=e(4271),h=e(1522),p=l(e(5262)),s=e(2625),r=l(e(9302));t.WEBGPU_OP_RESOLVE_RULES=new Map([["Abs",[r.abs]],["Acos",[r.acos]],["Acosh",[r.acosh]],["Add",[c.add]],["Asin",[r.asin]],["Asinh",[r.asinh]],["Atan",[r.atan]],["Atanh",[r.atanh]],["AveragePool",[p.averagePool,p.parseAveragePoolAttributes]],["Ceil",[r.ceil]],["ClipV10",[r.clipV10]],["Clip",[r.clip]],["Conv",[f.conv,f.parseConvAttributes]],["Cos",[r.cos]],["Cosh",[r.cosh]],["Div",[c.div]],["Elu",[r.elu,r.parseAlphaAttributes]],["Erf",[r.erf]],["Exp",[r.exp]],["Floor",[r.floor]],["Gemm",[g.gemm,g.parseGemmAttributes]],["GlobalAveragePool",[p.globalAveragePool,p.parseGlobalAveragePoolAttributes]],["GlobalMaxPool",[p.globalMaxPool,p.parseGlobalMaxPoolAttributes]],["LeakyRelu",[r.leakyRelu,r.parseAlphaAttributes]],["MatMul",[h.matMul]],["MaxPool",[p.maxPool,p.parseMaxPoolAttributes]],["Mul",[c.mul]],["Neg",[r.neg]],["Pow",[c.pow]],["Reciprocal",[r.reciprocal]],["Relu",[r.relu]],["Sigmoid",[r.sigmoid]],["Sin",[r.sin]],["Sinh",[r.sinh]],["Sqrt",[r.sqrt]],["Sub",[c.sub]],["Tan",[r.tan]],["Tanh",[r.tanh]],["ThresholdedRelu",[r.thresholdedRelu,r.parseAlphaAttributes]],["Transpose",[s.transpose,s.parseTransposeAttributes]]])},1427:(o,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.biasActivationSnippet=t.activationFnSnippet=t.typeSnippet=void 0,t.typeSnippet=e=>{switch(e){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${e}-component is not supported.`)}},t.activationFnSnippet=(e,n=!1,a=!1,l=3)=>"",t.biasActivationSnippet=(e,n)=>`
      ${e?"value = value + getBiasByOutputCoords(coords);":""}
      ${n?"value = activation(value, coords);":""}
      `},9456:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createConv2DMatMulProgramInfo=void 0;const n=e(4955),a=e(6952),l=e(1163),c=e(1427),f=e(4085),g=e(158);t.createConv2DMatMulProgramInfo=(h,p,s,r,u,d,m,b,y)=>{const w=s.format==="NHWC",x=w?h[0].dims[3]:h[0].dims[1],_=r[0],v=w?r[2]:r[3],E=w?r[1]:r[2],I=w?r[3]:r[1],S=((x%4==0||x%3==0)&&w||v%4==0&&!w)&&I%4==0,T=w?I:v*E,A=w?v*E:I,O=S?[8,8,1]:[T<=4?4:16,T>4&&A<=4?4:16,1],$=S?[4,4,1]:[T<=4?1:2,T>4&&A<=4?1:2,1],D=[Math.ceil(T/O[0]/$[0]),Math.ceil(A/O[1]/$[1]),Math.ceil(_/O[2]/$[1])];(0,n.LOG_DEBUG)("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${D}`);const M=S?w&&x%4!=0?3:4:$[0],F=O[1]*$[1],C=O[0]*$[0],R=Math.max(O[0]*M,O[1]),j=u%F==0,G=d%C==0,W=m%R==0,Z=S?[M,4,4]:[1,1,1],at=[`@group(0) @binding(0) var<storage, read> x: array<${S&&M===4?"vec4<f32>":"f32"}>;`,`@group(0) @binding(1) var<storage, read> w: array<${S?"vec4<f32>":"f32"}>;`];let J=`
      fn setOutputAtIndex(flatIndex : i32, value : ${S?"vec4<f32>":"f32"}) {
        result[flatIndex] = ${S?"vec4<f32>":"f32"}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${S?"vec4<f32>":"f32"}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${S?"/ 4":""}, value);
      }`;return b&&(at.push(`@group(0) @binding(2) var<storage, read> bias: array<${S?"vec4<f32>":"f32"}>;`),J+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${S?"vec4<f32>":"f32"} {
          return bias[coords.${w?"w":"y"}${S?"/ 4":""}];
        }`),Object.assign(Object.assign({},p),{outputs:[{dims:r,dataType:h[0].dataType,gpuDataType:l.GpuDataType.default}],dispatchGroup:()=>({x:D[0],y:D[1],z:D[2]}),getShaderSource:()=>`
        ${f.utilFunctions}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${at.join("")}
        @group(0) @binding(${at.length}) var<storage, read_write> result: array<${S?"vec4<f32>":"f32"}>;
        //@group(0) @binding(${at.length+1}) var<uniform> uniforms: Uniforms;

        const xShape : vec4<i32> = vec4<i32>(${h[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${h[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${a.ShapeUtil.computeStrides(r).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${s.kernelShape[0]}, ${s.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${s.pads[0]}, ${s.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${s.strides[0]}, ${s.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${s.dilations[0]}, ${s.dilations[1]});
        const dimAOuter : i32 = ${u};
        const dimBOuter : i32 = ${d};
        const dimInner : i32 = ${m};
        ${J}
        ${((Y,K,it,rt,yt=!1,ut,St=!1,gt=4,Ot=4,pt=4)=>{const ct=Y?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,ot=Y?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,Mt=Y?"xShape[1]":"xShape[2]",It=Y?"xShape[2]":"xShape[3]",Dt=Y?"row":"col",H=Y?"col":"row",ft=`
    let inChannels = wShape[2];
    let outWidth = ${Y?"outShape[2]":"outShape[3]"};
    let outRow = ${Dt} / outWidth;
    let outCol = ${Dt} % outWidth;

    let WRow = ${H} / (filterDims[1] * inChannels);
    let WCol = ${H} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${H} % inChannels;
    var resData = ${(0,c.typeSnippet)(gt)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${Mt} && xCol >= 0 && xCol < ${It}) {
      ${ct}
      let xIndex = getIndexFromCoords4D(coord, xShape);
      ${(mt=>{switch(mt){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${mt} is not supported.`)}})(gt)}
    }
    return resData;`,xt=Y?K&&rt?`
    let col = colIn * ${gt};
    ${ft}`:`
    let col = colIn * ${gt};
    if (row < dimAOuter && col < dimInner) {
      ${ft}
    }
    return ${(0,c.typeSnippet)(gt)}(0.0);`:rt&&it?`
    let col = colIn * ${gt};
    ${ft}`:`
    let col = colIn * ${gt};
    if (row < dimInner && col < dimBOuter) {
      ${ft}
    }
    return ${(0,c.typeSnippet)(gt)}(0.0);`,_t=`${(mt=>{switch(mt){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${mt} is not supported.`)}})(Ot)}`,et=(0,c.typeSnippet)(pt),Ct=Y?(0,c.typeSnippet)(gt):(0,c.typeSnippet)(Ot),Pt=Y?(0,c.typeSnippet)(Ot):(0,c.typeSnippet)(gt);return`
    ${(0,c.activationFnSnippet)(ut,St,pt===4,4)}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${Ct} {
      ${Y?xt:_t}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${Pt} {
      ${Y?_t:xt}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${et}) {
      let col = colIn * ${pt};
      if (row < dimAOuter && col < dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${Y?"outShape[2]":"outShape[3]"};
      ${ot}
      ${(0,c.biasActivationSnippet)(yt,ut)}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`})(w,j,G,W,b,void 0,!1,Z[0],Z[1],Z[2])}
            ${S?(0,g.makeMatMulPackedVec4Source)($,O,!w,R):(0,g.makeMatMulPackedSource)($,O,!w,R,!1,void 0,y)}`})}},4085:(o,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.utilFunctions=void 0,t.utilFunctions=`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));
}
`},158:(o,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.makeMatMulPackedSource=t.makeMatMulPackedVec4Source=void 0,t.makeMatMulPackedVec4Source=(n,a,l=!1,c=32,f=!1,g=32,h=!1)=>{const p=a[1]*n[1],s=a[0]*n[0],r=l?p:c,u=l?c:p,d=r/a[0],m=c/a[1];if((!l||d!==4||n[1]!==4)&&(l||d!==3&&d!==4)||r%a[0]!=0||c%a[1]!=0||n[0]!==4)throw new Error(`If transposeA ${l} is true, innerElementSize ${d} and workPerThread[1] ${n[1]} must be 4.
      Otherwise, innerElementSize ${d} must be 3 or 4.
  tileAWidth ${r} must be divisible by workgroupSize[0]${a[0]}. tileInner ${c} must be divisible by workgroupSize[1] ${a[1]}. colPerThread ${n[0]} must be 4.`);return`
var<workgroup> mm_Asub : array<array<vec${d}<f32>, ${r/d}>, ${u}>;
var<workgroup> mm_Bsub : array<array<vec4<f32>, ${s/n[0]}>, ${c}>;

const rowPerThread = ${n[1]};
const colPerThread = ${n[0]};
const innerElementSize = ${d};
const tileInner = ${c};

@compute @workgroup_size(${a[0]}, ${a[1]}, ${a[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = ${h?"0":"localRow * rowPerThread"};
  let tileCol = i32(localId.x);

  let globalRow = ${h?"0":"i32(globalId.y) * rowPerThread"};
  let globalCol = i32(globalId.x);
  let batch = ${f?"0":"i32(globalId.z)"};
  let globalRowStart = i32(workgroupId.y) * ${p};

  let numTiles = ${f?`${Math.ceil(g/c)}`:"(dimInner - 1) / tileInner + 1"};
  var kStart = ${f?`i32(globalId.z) * ${g}`:"0"};

  var acc: array<vec4<f32>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${m};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${b=l,b?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol);
        `}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${d===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${((y,w)=>y?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${w===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${w===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${w===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`)(l,d)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`;var b};const e=n=>n?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol);
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol);
            `;t.makeMatMulPackedSource=(n,a,l=!1,c=32,f=!1,g=32,h=!1)=>{const p=n[1]*a[1],s=n[0]*a[0],r=l?p:c,u=l?c:p;if(u%a[1]!=0||r%a[0]!=0||c%a[1]!=0)throw new Error(`tileAHight ${u} must be divisible by workgroupSize[1]${a[1]}, tileAWidth ${r} must be divisible by workgroupSize[0]${a[0]}, tileInner ${c} must be divisible by workgroupSize[1]${a[1]}`);const d=u/a[1],m=r/a[0],b=c/a[1],y=h?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${p};
    let globalColStart = i32(workgroupId.x) * ${s};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${u}; inputRow = inputRow + ${a[1]}) {
        for (var inputCol = localCol; inputCol < ${r}; inputCol = inputCol + ${a[0]}) {
          ${e(l)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${c}; inputRow = inputRow + ${a[1]}) {
            for (var inputCol = localCol; inputCol < ${s}; inputCol = inputCol + ${a[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol);
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<f32, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${a[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${l?`mm_Asub[k][localRow + innerRow * ${a[1]}];`:`mm_Asub[localRow + innerRow * ${a[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${a[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${a[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${p};

let tileRowA = i32(localId.y) * ${d};
let tileColA = i32(localId.x) * ${m};
let tileRowB = i32(localId.y) * ${b};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${d}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${m}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${e(l)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${b}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol);
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<f32, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${(w=>w?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(l)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${u}>;
  var<workgroup> mm_Bsub : array<array<f32, ${s}>, ${c}>;
  const rowPerThread = ${n[1]};
  const colPerThread = ${n[0]};
  const tileInner = ${c};

@compute @workgroup_size(${a[0]}, ${a[1]}, ${a[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${f?"0":"i32(globalId.z)"};
    let numTiles = ${f?`${Math.ceil(g/c)}`:"(dimInner - 1) / tileInner + 1"};
    var kStart = ${f?`i32(globalId.z) * ${g}`:"0"};

    var acc : array<array<f32, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${y}
  }
`}},504:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.sub=t.pow=t.mul=t.div=t.add=void 0;const n=e(6952),a=e(1163),l=e(2075),c=(f,g,h,p,s)=>{const r={name:g,inputTypes:[a.GpuDataType.default,a.GpuDataType.default],cacheHint:s};return Object.assign(Object.assign({},r),{get:()=>((u,d,m,b,y,w=d.dataType)=>{var x,_;const v=!n.ShapeUtil.areEqual(d.dims,m.dims);let E=d.dims,I=n.ShapeUtil.size(d.dims),S=!1;if(v){const T=n.BroadcastUtil.calcShape(d.dims,m.dims,!1);if(!T)throw new Error("Can't perform binary op on the given tensors");E=T,I=n.ShapeUtil.size(E);let A=1;for(let O=0;O<E.length;O++){const $=(x=d.dims[d.dims.length-O])!==null&&x!==void 0?x:1;if($!==((_=m.dims[m.dims.length-O])!==null&&_!==void 0?_:1))break;A*=$}A%4==0&&(S=!0)}else S=!0;return Object.assign(Object.assign({},u),{getShaderSource:T=>((A,O,$,D,M,F,C,R,j="f32",G="f32",W="f32")=>{const Z=n.ShapeUtil.size(D),at=Math.ceil(Z/4);let J,Y;typeof C=="string"?J=Y=(yt,ut)=>`${C}((${yt}),(${ut}))`:typeof C=="function"?J=Y=C:(J=C.scalar,Y=C.vector);let K="";const it=(0,l.createIndicesHelper)("output",D);if(F){const yt=ut=>{const St=n.ShapeUtil.computeStrides(ut),gt=[];for(let Ot=ut.length-1;Ot>=0;Ot--){const pt=D.length===0?"0u":D.length===1?"(*outputIndices)":`(*outputIndices)[${Ot+D.length-ut.length}]`;gt.push(`${St[Ot]}u * (${pt} % ${ut[Ot]}u)`)}return gt.length>0?gt.join("+"):"0u"};K=`
  ${it.o2iImpl}

  fn calcOffsetA(outputIndices: ptr<function, ${it.iType}>) -> u32 {
    return ${yt(O)};
  }

  fn calcOffsetB(outputIndices: ptr<function, ${it.iType}>) -> u32 {
    return ${yt($)};
  }
  `}let rt;if(M)rt=F?`
      ${it.indicesVariableDeclaration("outputIndices")}
      ${it.o2iCall("global_idx * 4u","outputIndices")}
      let offsetA = calcOffsetA(&outputIndices);
      let offsetB = calcOffsetB(&outputIndices);
      outputData[global_idx] = ${Y("aData[offsetA / 4u]","bData[offsetB / 4u]")};`:`outputData[global_idx] = ${Y("aData[global_idx]","bData[global_idx]")};`;else{if(!F)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");const yt=ut=>{const St=`aData[indexA${ut}][componentA${ut}]`,gt=`bData[indexB${ut}][componentB${ut}]`;return`
      ${it.o2iCall(`global_idx * 4u + ${ut}u`,"outputIndices")}
      let offsetA${ut} = calcOffsetA(&outputIndices);
      let offsetB${ut} = calcOffsetB(&outputIndices);
      let indexA${ut} = offsetA${ut} / 4u;
      let indexB${ut} = offsetB${ut} / 4u;
      let componentA${ut} = offsetA${ut} % 4u;
      let componentB${ut} = offsetB${ut} % 4u;
      outputData[global_idx][${ut}] = ${J(St,gt)};`};rt=`
      ${it.indicesVariableDeclaration("outputIndices")}
      ${yt(0)}
      ${yt(1)}
      ${yt(2)}
      ${yt(3)}`}return`
  @group(0) @binding(0) var<storage, read> aData : array<vec4<${j}>>;
  @group(0) @binding(1) var<storage, read> bData : array<vec4<${G}>>;
  @group(0) @binding(2) var<storage, read_write> outputData : array<vec4<${W}>>;

  ${R??""}
  ${K}

  ${A.mainStart()}
    ${A.guardAgainstOutOfBoundsWorkgroupSizes(at)}
    ${rt}
  }`})(T,d.dims,m.dims,E,S,v,b,y),outputs:[{dims:E,dataType:w,gpuDataType:a.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(I/64/(S?4:1))})})})(r,f[0],f[1],h,p)})};t.add=f=>{f.compute(c(f.inputs,"Add",(g,h)=>`${g}+${h}`))},t.div=f=>{f.compute(c(f.inputs,"Div",(g,h)=>`${g}/${h}`))},t.mul=f=>{f.compute(c(f.inputs,"Mul",(g,h)=>`${g}*${h}`))},t.pow=f=>{f.compute(c(f.inputs,"Pow",{scalar:(g,h)=>`pow_f32(${g},${h})`,vector:(g,h)=>`pow_vf32(${g},${h})`},`
    fn pow_f32(a : f32, b : f32) -> f32 {
      if (b == 0.0) {
        return 1.0;
      } else if (a < 0.0 && b != floor(b)) {
        return pow(a, b); // NaN
      }
      return select(sign(a), 1.0, round(abs(b) % 2.0) != 1.0) * pow(abs(a), b);
    }
    fn pow_vf32(a : vec4<f32>, b : vec4<f32>) -> vec4<f32> {
      // TODO: implement vectorized pow
      return vec4<f32>(pow_f32(a.x, b.x), pow_f32(a.y, b.y), pow_f32(a.z, b.z), pow_f32(a.w, b.w));
    }
      `))},t.sub=f=>{f.compute(c(f.inputs,"Sub",(g,h)=>`${g}-${h}`))}},2075:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createShaderHelper=t.createIndicesHelper=t.WORKGROUP_SIZE=void 0;const n=e(6952);t.WORKGROUP_SIZE=64,t.createIndicesHelper=(l,c)=>{const f=c.length<2?"u32":`array<u32, ${c.length}>`,g=n.ShapeUtil.computeStrides(c);let h="";for(let r=0;r<c.length-1;r++)h+=`
    let dim${r} = current / ${g[r]}u;
    let rest${r} = current % ${g[r]}u;
    (*indices)[${r}] = dim${r};
    current = rest${r};
    `;h+=`(*indices)[${c.length-1}] = current;`;const p=c.length<2?"":`
  fn ih_o2i_${l}(offset: u32, indices: ptr<function, ${f}>) {
    var current = offset;
    ${h}
  }`,s=[];if(c.length===0)s.push("0u");else if(c.length<2)s.push("(*indices)");else for(let r=c.length-1;r>=0;r--)s.push(`${g[r]}u * ((*indices)[${r}])`);return{o2iImpl:p,o2iCall:(r,u)=>c.length<2?`${u}=${r};`:`ih_o2i_${l}(${r}, &${u});`,i2oImpl:c.length<2?"":`
  fn ih_i2o_${l}(indices: ptr<function, ${f}>) -> u32 {
    return ${s.join("+")};
  }`,i2oExpression:(r,u)=>c.length<2?`(${u?"*":""}${r})`:`ih_i2o_${l}(${u?"":"&"}${r})`,indicesVariableDeclaration:(r,u)=>`var ${r}:${f}${u?`=${f}(${u.join(",")})`:""};`,iType:f}};class a{constructor(c){this.normalizedDispatchGroup=c}guardAgainstOutOfBoundsWorkgroupSizes(c){return`if (global_idx >= ${typeof c=="number"?`${c}u`:c}) { return; }`}mainStart(c=t.WORKGROUP_SIZE){const f=typeof c=="number"?c:c[0],g=typeof c=="number"?1:c[1],h=typeof c=="number"?1:c[2],p=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1;return`@compute @workgroup_size(${f}, ${g}, ${h})
  fn main(${p?"@builtin(global_invocation_id) global_id : vec3<u32>":`@builtin(local_invocation_index) local_index : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>`}) {
    ${p?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +
          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${f*g*h}u + local_index;`}
  `}}t.createShaderHelper=l=>new a(l)},9192:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createGroupedConvProgramInfoLoader=void 0;const n=e(6952),a=e(1163),l=e(2075),c=e(9770),f=e(3997);t.createGroupedConvProgramInfoLoader=(g,h,p)=>{const s=(r=g.length>2,u=h.cacheKey,{name:"GroupedConv",inputTypes:r?[a.GpuDataType.default,a.GpuDataType.default,a.GpuDataType.default]:[a.GpuDataType.default,a.GpuDataType.default],cacheHint:u});var r,u;return Object.assign(Object.assign({},s),{get:()=>((d,m,b,y)=>{const w=d.length>2,x=w?"value += b[output_channel];":"",_=d[0].dims,v=d[1].dims,E=v[0]/b.group,I="f32",{activationFunction:S,applyActivation:T}=(0,f.getActicationSnippet)(b),A=[`@group(0) @binding(0) var<storage, read> x : array<${I}>;`,`@group(0) @binding(1) var<storage, read> w : array<${I}>;`];w&&A.push(`@group(0) @binding(2) var<storage, read> b : array<${I}>;`);const O=b.format==="NHWC",$=(0,c.calculateOutputShape)(_,v,b.dilations,b.pads,b.strides,O),D=n.ShapeUtil.size($),M=(0,l.createIndicesHelper)("output",$),F=(0,l.createIndicesHelper)("x",_),C=(0,l.createIndicesHelper)("w",v);return Object.assign(Object.assign({},m),{outputs:[{dims:y?y($):$,dataType:d[0].dataType,gpuDataType:a.GpuDataType.default}],getShaderSource:R=>`
  const strides: vec2<u32> = vec2(${b.strides[0]}u, ${b.strides[1]}u);
  const pads: vec2<u32> = vec2(${b.pads[0]}u, ${b.pads[1]}u);

  ${A.join(`
`)}
  @group(0) @binding(${A.length}) var<storage, read_write> output : array<${I}>;

  ${S}
  ${M.o2iImpl}
  ${F.i2oImpl}
  ${C.i2oImpl}

  ${R.mainStart()}
    ${R.guardAgainstOutOfBoundsWorkgroupSizes(D)}

    ${M.indicesVariableDeclaration("outputIndices")}
    ${M.o2iCall("global_idx","outputIndices")}
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${O?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${O?1:2}], outputIndices[${O?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${E}u;

    var value: ${I} = ${I}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${v[1]}u; wInChannel++) {
      let input_channel = group_id * ${v[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${v[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${b.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${_[O?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${v[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${b.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${_[O?2:3]}u) {
            continue;
          }

          ${F.indicesVariableDeclaration("xIndices",O?["batch","xHeight","xWidth","input_channel"]:["batch","input_channel","xHeight","xWidth"])}
          let xVal = x[${F.i2oExpression("xIndices")}];
          ${C.indicesVariableDeclaration("wIndices",["output_channel","wInChannel","wHeight","wWidth"])}
          let wVal = w[${C.i2oExpression("wIndices")}];
          value += xVal*wVal;
        }
      }
    }
    ${x}
    ${T}
    output[global_idx] = value;
  }`,dispatchGroup:()=>({x:Math.ceil(D/64)})})})(g,s,h,p)})}},9770:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.conv=t.parseConvAttributes=t.calculateOutputShape=void 0;const n=e(6952),a=e(387),l=e(9192),c=e(3822),f=e(3997),g=e(2625);t.calculateOutputShape=(s,r,u,d,m,b)=>{const y=s[0],w=s.slice(b?1:2,b?3:4),x=w.length,_=r[0],v=r.slice(2).map((I,S)=>I+(I-1)*(u[S]-1)),E=w.map((I,S)=>I+d[S]+d[S+x]).map((I,S)=>Math.floor((I-v[S]+m[S])/m[S]));return E.splice(0,0,y),E.splice(b?3:1,0,_),E};const h=(0,a.createAttributeWithCacheKey)({perm:[2,3,1,0]}),p=(s,r)=>{const u=s.kernelShape.slice();for(let b=2;b<r[1].dims.length;++b)u[b-2]===0&&(u[b-2]=r[1].dims[b]);const d=s.pads.slice();n.PoolConvUtil.adjustPadsBasedOnAutoPad(r[0].dims,s.strides,s.dilations,u,d,s.format==="NHWC",s.autoPad);const m=Object.assign({},s);return Object.assign(m,{kernelShape:u,pads:d,cacheKey:s.cacheKey}),m};t.parseConvAttributes=s=>{const r=(0,f.parseInternalActivationAttributes)(s),u=s.format,d=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][s.auto_pad],m=s.dilations,b=s.group,y=s.kernel_shape,w=s.pads,x=s.strides,_=s.w_is_const();return(0,a.createAttributeWithCacheKey)(Object.assign({autoPad:d,format:u,dilations:m,group:b,kernelShape:y,pads:w,strides:x,wIsConst:_},r))},t.conv=(s,r)=>{((u,d)=>{if(!u||u.length!==2&&u.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(u[0].dims.length!==4&&u[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(u[0].dims.length!==u[1].dims.length)throw new Error("filter does not have same dimension as input");if(u[0].dims[d.format==="NHWC"?u[0].dims.length-1:1]!==u[1].dims[1]*d.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(u.length===3&&(u[2].dims.length!==1||u[1].dims[0]!==u[2].dims[0]))throw new Error("invalid bias");const m=u[0].dims.length-2;if(d.dilations.length!==m)throw new Error(`dilations should be ${m}D`);if(d.strides.length!==m)throw new Error(`strides should be ${m}D`);if(d.pads.length!==2*m)throw new Error(`pads should be ${2*m}D`);if(d.kernelShape.length!==0&&d.kernelShape.length!==u[1].dims.length-2)throw new Error("invalid kernel shape");if(u[0].dataType!==1||u[1].dataType!==1)throw new Error("Conv input(X,W) should be float tensor");if(u.length===3&&u[2].dataType!==1)throw new Error("Conv input(bias) should be float tensor")})(s.inputs,r),s.inputs[0].dims.length===3?((u,d)=>{const m=d.format==="NHWC",b=[u.inputs[0].reshape(m?[u.inputs[0].dims[0],1,u.inputs[0].dims[1],u.inputs[0].dims[2]]:[u.inputs[0].dims[0],u.inputs[0].dims[1],1,u.inputs[0].dims[2]]),u.inputs[1].reshape([u.inputs[1].dims[0],u.inputs[1].dims[1],1,u.inputs[1].dims[2]])];u.inputs.length===3&&b.push(u.inputs[2]);const y=[0,d.pads[0],0,d.pads[1]],w=[1].concat(d.strides),x=[1].concat(d.dilations),_=[1].concat(d.kernelShape),v=p(Object.assign(Object.assign({},d),{pads:y,strides:w,dilations:x,kernelShape:_}),b);u.compute((0,l.createGroupedConvProgramInfoLoader)(b,v,E=>m?[E[0],E[2],E[3]]:[]))})(s,r):((u,d,m)=>{var b;const y=p(m,d),w=d.length===3,x=m.format==="NHWC",_=d[0].dims[x?1:2],v=d[0].dims[x?2:3],E=d[0].dims[x?3:1],I=d[1].dims[2],S=d[1].dims[3],T=(0,t.calculateOutputShape)(d[0].dims,d[1].dims,m.dilations,y.pads,m.strides,x),A=T[x?1:2],O=T[x?2:3],$=T[x?3:1];if(x&&I===_&&S===v&&m.autoPad==="VALID"||I===1&&S===1&&m.dilations[0]===1&&m.dilations[1]===1&&m.strides[0]===1&&m.strides[1]===1&&(m.autoPad==="SAME_UPPER"||m.autoPad==="SAME_LOWER"||m.autoPad==="VALID")||!x||m.group!==1)return void u.compute((0,l.createGroupedConvProgramInfoLoader)(d,y));const D=x?A*O:$,M=x?$:A*O,F=I*S*E,C=(b=u.customData.wT)!==null&&b!==void 0?b:u.compute(Object.assign(Object.assign({},g.transposeProgramMetadata),{cacheHint:h.cacheKey,get:()=>(0,g.createTransposeProgramInfo)(d[1],h.perm)}),{inputs:[1],outputs:[m.wIsConst?-2:-1]})[0];m.wIsConst&&!u.customData.wT&&(u.customData.wT=C);const R=[d[0],C];w&&(x||d[2].dims.length!==1?R.push(d[2]):R.push(d[2].reshape([d[2].dims[0],1,1]))),u.compute((0,c.createConv2DMatMulProgramInfoLoader)(R,y,T,D,M,F,w,!0),{inputs:R})})(s,s.inputs,r)}},3822:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createConv2DMatMulProgramInfoLoader=void 0;const n=e(1163),a=e(9456);t.createConv2DMatMulProgramInfoLoader=(l,c,f,g,h,p,s,r)=>{const u=((d,m)=>({name:"Conv2DMatMul",inputTypes:d?[n.GpuDataType.default,n.GpuDataType.default,n.GpuDataType.default]:[n.GpuDataType.default,n.GpuDataType.default],cacheHint:m}))(s,c.cacheKey);return Object.assign(Object.assign({},u),{get:()=>(0,a.createConv2DMatMulProgramInfo)(l,u,c,f,g,h,p,s,r)})}},3997:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseInternalActivationAttributes=t.getActicationSnippet=void 0;const n=e(6952);t.getActicationSnippet=a=>{switch(a.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${a.clipMin});const clip_max_=f32(${a.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},t.parseInternalActivationAttributes=a=>{const l=(a==null?void 0:a.activation)||"";if(l==="Clip"){const[c,f]=(a==null?void 0:a.activation_params)||[n.MIN_CLIP,n.MAX_CLIP];return{activation:l,clipMax:f,clipMin:c,activationCacheKey:`${l}:${c},${f}`}}return{activation:l,activationCacheKey:l}}},4271:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseGemmAttributes=t.gemm=void 0;const n=e(6952),a=e(387),l=e(1163);t.gemm=(c,f)=>{(g=>{if(!g)throw new Error("Input is missing");if(g.length<2||g.length>3)throw new Error("Invaid input number.");if(g.length===3&&g[2].dims.length>2)throw new Error("Invalid input shape of C");if(g[0].dataType!==1||g[1].dataType!==1||g.length===3&&g[2].dataType!==1)throw new Error("Invalid input type.");if(g[0].dataType!==g[1].dataType||g.length===3&&g[0].dataType!==g[2].dataType)throw new Error("Input types are mismatched")})(c.inputs),c.compute(((g,h)=>{const p={name:"Gemm",inputTypes:g.length===3?[l.GpuDataType.default,l.GpuDataType.default,l.GpuDataType.default]:[l.GpuDataType.default,l.GpuDataType.default],cacheHint:h.cacheKey};return Object.assign(Object.assign({},p),{get:()=>((s,r,u)=>{const d=r[0].dims.slice(),m=r[1].dims.slice(),[b,y,w]=n.GemmUtil.getShapeOfGemmResult(d,u.transA,m,u.transB,r.length===3?r[2].dims:void 0),x=[b,y];if(!x)throw new Error("Can't use gemm on the given tensors");const _=n.ShapeUtil.size(x);let v="";u.transA&&u.transB?v="value += a[k * M + m] * b[n * K + k];":u.transA&&!u.transB?v="value += a[k * M + m] * b[k * N + n];":!u.transA&&u.transB?v="value += a[m * K + k] * b[n * K + k];":u.transA||u.transB||(v="value += a[m * K + k] * b[k * N + n];");const E="f32",I=u.alpha===1?"":"value *= alpha;",S=r.length===3?`value += beta * c[${((A,O,$)=>{if($.length===0)return"0u";const D=$.length===1&&A!==1||$.length===2&&$[0]!==A,M=$[$.length-1]!==O;let F="0u";return D||(F+=`+ m * ${$[$.length-1]}u`),M||(F+="+n"),F})(b,y,r[2].dims)}];`:"",T=[`@group(0) @binding(0) var<storage, read> a : array<${E}>;`,`@group(0) @binding(1) var<storage, read> b : array<${E}>;`];return r.length===3&&T.push(`@group(0) @binding(2) var<storage, read> c : array<${E}>;`),Object.assign(Object.assign({},s),{outputs:[{dims:x,dataType:r[0].dataType,gpuDataType:l.GpuDataType.default}],getShaderSource:A=>`
  const M: u32 = ${b}u;
  const N: u32 = ${y}u;
  const K: u32 = ${w}u;
  const alpha = ${E}(${u.alpha});
  const beta = ${E}(${u.beta});

  ${T.join(`
`)}
  @group(0) @binding(${r.length}) var<storage, read_write> output : array<${E}>;

  ${A.mainStart()}
    ${A.guardAgainstOutOfBoundsWorkgroupSizes(_)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${E}(0);
    for (var k: u32 = 0u; k<${w}u; k++) {
      ${v}
    }

    ${I}
    ${S}
    output[global_id.x] = value;

  }`,dispatchGroup:()=>({x:Math.ceil(_/64)})})})(p,g,h)})})(c.inputs,f))},t.parseGemmAttributes=c=>(0,a.createAttributeWithCacheKey)(c)},1522:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.matMul=t.createMatmulProgramInfoLoader=void 0;const n=e(6952),a=e(1163),l=e(3997);t.createMatmulProgramInfoLoader=(c,f)=>{const g=(h=c.length>2,p=f.activationCacheKey,{name:"MatMul",inputTypes:h?[a.GpuDataType.default,a.GpuDataType.default,a.GpuDataType.default]:[a.GpuDataType.default,a.GpuDataType.default],cacheHint:p});var h,p;return Object.assign(Object.assign({},g),{get:()=>((s,r,u)=>{const d=r[0].dims,m=r[1].dims,b=n.BroadcastUtil.calcShape(d,m,!0);if(!b)throw new Error("Can't use matmul on the given tensors");const y=n.ShapeUtil.size(b),w="f32",{activationFunction:x,applyActivation:_}=(0,l.getActicationSnippet)(u),v=b[b.length-2],E=d[d.length-1],I=b[b.length-1];return Object.assign(Object.assign({},s),{outputs:[{dims:b,dataType:r[0].dataType,gpuDataType:a.GpuDataType.default}],getShaderSource:S=>`
  const M: u32 = ${v}u;
  const N: u32 = ${I}u;
  const K: u32 = ${E}u;

  @group(0) @binding(0) var<storage, read> a : array<${w}>;
  @group(0) @binding(1) var<storage, read> b : array<${w}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${w}>;

  ${x}

  ${S.mainStart()}
    ${S.guardAgainstOutOfBoundsWorkgroupSizes(y)}

    let stack = global_idx / (M * N);
    let mn = global_idx % (M * N);
    let n = global_idx % N;
    let m = mn / N;

    let offsetA = stack * (M * K);
    let offsetB = stack * (K * N);

    var value = ${w}(0);
    for (var k: u32 = 0u; k<${E}u; k++) {
      value += a[offsetA + m * K + k] * b[offsetB + k * N + n];
    }
    ${_}
    output[global_idx] = value;
  }`,dispatchGroup:()=>({x:Math.ceil(y/64)})})})(g,c,f)})},t.matMul=c=>{(f=>{if(!f||f.length!==2)throw new Error("MatMul requires 2 inputs.");if(f[0].dims[f[0].dims.length-1]!==f[1].dims[f[1].dims.length-2])throw new Error("shared dimension does not match.");if(f[0].dataType!==1||f[1].dataType!==1)throw new Error("inputs should be float type")})(c.inputs),c.compute((0,t.createMatmulProgramInfoLoader)(c.inputs,{activation:"",activationCacheKey:""}))}},5262:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.globalMaxPool=t.parseGlobalMaxPoolAttributes=t.parseMaxPoolAttributes=t.maxPool=t.globalAveragePool=t.parseGlobalAveragePoolAttributes=t.averagePool=t.parseAveragePoolAttributes=void 0;const n=e(6952),a=e(387),l=e(1163),c=e(2075),f=d=>{if(!d||d.length!==1)throw new Error("Pool ops requires 1 input.");if(d[0].dims.length!==4)throw new Error("Pool ops supports 2-D inputs only for now.");if(d[0].dataType!==1)throw new Error("Invalid input type.")},g=(d,m,b)=>{const y=m.format==="NHWC",w=y?[d[0].dims[0],d[0].dims[3],d[0].dims[1],d[0].dims[2]]:d[0].dims.slice(),x=Object.hasOwnProperty.call(m,"dilations"),_=m.kernelShape.slice(),v=m.strides.slice(),E=x?m.dilations.slice():[],I=m.pads.slice();n.PoolConvUtil.adjustPoolAttributes(b,w,_,v,E,I);const S=n.PoolConvUtil.computePoolOutputShape(b,w,v,E,_,I,m.autoPad),T=Object.assign({},m);return x?Object.assign(T,{kernelShape:_,strides:v,pads:I,dilations:E,cacheKey:m.cacheKey}):Object.assign(T,{kernelShape:_,strides:v,pads:I,cacheKey:m.cacheKey}),[T,y?[S[0],S[2],S[3],S[1]]:S]},h=(d,m,b,y,w,x,_,v)=>{const E=y.format==="NHWC",I=m.length,S=n.ShapeUtil.size(b),T=(0,c.createIndicesHelper)("output",b),A=(0,c.createIndicesHelper)("x",m);if(y.kernelShape.length<=2){const O=y.kernelShape[y.kernelShape.length-1],$=y.strides[y.strides.length-1],D=y.pads[y.pads.length/2-1],M=I-(E?2:1);let F="",C="",R="";if(F=D+y.pads[y.pads.length-1]!==0?`
              for (var i: u32 = 0u; i < ${O}u; i++) {
                xIndices[${M}] = indices[${M}] * ${$} - ${D} + i;
                if (xIndices[${M}] < 0 || xIndices[${M}] >= ${m[M]}) {
                  pad++;
                  continue;
                }
                let x_val = x[${A.i2oExpression("xIndices")}];
                ${w}
              }`:`
              for (var i: u32 = 0u; i < ${O}u; i++) {
                xIndices[${M}] = indices[${M}] * ${$} - ${D} + i;
                let x_val = x[${A.i2oExpression("xIndices")}];
                ${w}
              }`,y.kernelShape.length===2){const j=y.kernelShape[y.kernelShape.length-2],G=y.strides[y.strides.length-2],W=y.pads[y.pads.length/2-2],Z=y.pads[y.pads.length-2],at=I-(E?3:2),J=m[at];C=W+Z!==0?`
                for (var j: u32 = 0u; j < ${j}u; j++) {
                  xIndices[${at}] = indices[${at}] * ${G} - ${W} + j;
                  if (xIndices[${at}] < 0 || xIndices[${at}] >= ${J}) {
                    pad+= ${O};
                    continue;
                  }
              `:`
                for (var j: u32 = 0u; j < ${j}u; j++) {
                  xIndices[${at}] = indices[${at}] * ${G} - ${W} + j;
                `,R=`
              }
            `}return`
            @group(0) @binding(0) var<storage, read> x : array<${_}>;
            @group(0) @binding(1) var<storage, read_write> output : array<${_}>;

            ${T.o2iImpl}
            ${A.i2oImpl}

            ${d.mainStart()}
              ${d.guardAgainstOutOfBoundsWorkgroupSizes(S)}

              ${T.indicesVariableDeclaration("indices")}
              ${T.o2iCall("global_idx","indices")}
              ${T.indicesVariableDeclaration("xIndices")}
              ${T.o2iCall("global_idx","xIndices")}

              var value: ${_} = ${_}(${v});
              var pad = 0;
              ${C}
              ${F}
              ${R}
              ${x}

              output[global_idx] = value;
            }`}{if(E)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");const O=n.ShapeUtil.size(y.kernelShape),$=n.ShapeUtil.computeStrides(y.kernelShape),D=$.length,M=y.pads.length;let F="";return F=y.pads.reduce((C,R)=>C+R)?`
                if (xIndices[j] >= inputDims[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${A.i2oExpression("xIndices")}];
                ${w}
              }`:`
              }
              let x_val = x[${A.i2oExpression("xIndices")}];
              ${w}
            `,`
            @group(0) @binding(0) var<storage, read> x : array<${_}>;
            @group(0) @binding(1) var<storage, read_write> output : array<${_}>;

            ${T.o2iImpl}
            ${A.i2oImpl}

            const pads = array<u32, ${M}>(${y.pads.map(C=>`${C}u`).join(",")});
            const inputDims = array<u32, ${I}>(${m.map(C=>`${C}u`).join(",")});
            const kernelStrides = array<u32, ${D}>(${$.map(C=>`${C}u`).join(",")});
            const strides = array<u32, ${D}>(${y.strides.map(C=>`${C}u`).join(",")});

            ${d.mainStart()}
              ${d.guardAgainstOutOfBoundsWorkgroupSizes(S)}

              ${T.indicesVariableDeclaration("indices")}
              ${T.o2iCall("global_idx","indices")}
              ${T.indicesVariableDeclaration("xIndices")}
              ${T.o2iCall("global_idx","xIndices")}

              var offsets: array<u32, ${D}>;

              var value = ${_}(${v});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < ${O}u; i++) {
                var offset = i;
                for (var j = 0u; j < ${D-1}u; j++) {
                  offsets[j] = offset / kernelStrides[j];
                  offset -= offsets[j] * kernelStrides[j];
                }
                offsets[${D-1}] = offset;

                isPad = false;
                for (var j = ${I-D}u; j < ${I}u; j++) {
                  xIndices[j] = indices[j] * strides[j - ${I-D}u]
                    + offsets[j - ${I-D}u] - pads[j - 2u];
                  ${F}
              }
              ${x}

              output[global_idx] = value;
            }`}},p=d=>({format:d.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][d.auto_pad],ceilMode:d.ceil_mode,kernelShape:d.kernel_shape,strides:d.strides,pads:d.pads}),s=(d,m,b,y)=>{const[w,x]=g(d,y,b),_=n.ShapeUtil.size(w.kernelShape),v="f32";let E="";return w.countIncludePad?E+=`value /= ${v}(${_});`:E+=`value /= ${v}(${_} - pad);`,Object.assign(Object.assign({},m),{outputs:[{dims:x,dataType:d[0].dataType,gpuDataType:l.GpuDataType.default}],getShaderSource:I=>h(I,d[0].dims,x,w,"value += x_val;",E,v,"0.0"),dispatchGroup:()=>({x:Math.ceil(n.ShapeUtil.size(x)/64)})})};t.parseAveragePoolAttributes=d=>{const m=d.count_include_pad!==0,b=p(d);if(b.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,a.createAttributeWithCacheKey)(Object.assign({countIncludePad:m},b))},t.averagePool=(d,m)=>{f(d.inputs);const b={name:"AveragePool",inputTypes:[l.GpuDataType.default],cacheHint:m.cacheKey};d.compute(Object.assign(Object.assign({},b),{get:()=>s(d.inputs,b,!1,m)}))};const r={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""};t.parseGlobalAveragePoolAttributes=d=>{const m=d.format;return Object.assign(Object.assign({format:m},r),{cacheKey:m})},t.globalAveragePool=(d,m)=>{f(d.inputs);const b={name:"GlobalAveragePool",inputTypes:[l.GpuDataType.default],cacheHint:m.cacheKey};d.compute(Object.assign(Object.assign({},b),{get:()=>s(d.inputs,b,!0,m)}))};const u=(d,m,b,y)=>{const[w,x]=g(d,y,b);return Object.assign(Object.assign({},m),{outputs:[{dims:x,dataType:d[0].dataType,gpuDataType:l.GpuDataType.default}],getShaderSource:_=>h(_,d[0].dims,x,w,`
      value = max(x_val, value);
    `,"","f32","-1e5"),dispatchGroup:()=>({x:Math.ceil(n.ShapeUtil.size(x)/64)})})};t.maxPool=(d,m)=>{f(d.inputs);const b={name:"MaxPool",inputTypes:[l.GpuDataType.default],cacheHint:m.cacheKey};d.compute(Object.assign(Object.assign({},b),{get:()=>u(d.inputs,b,!1,m)}))},t.parseMaxPoolAttributes=d=>{const m=d.storage_order,b=d.dilations,y=p(d);if(m!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(y.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,a.createAttributeWithCacheKey)(Object.assign({storageOrder:m,dilations:b},y))},t.parseGlobalMaxPoolAttributes=d=>{const m=d.format;return Object.assign(Object.assign({format:m},r),{cacheKey:m})},t.globalMaxPool=(d,m)=>{f(d.inputs);const b={name:"GlobalMaxPool",inputTypes:[l.GpuDataType.default],cacheHint:m.cacheKey};d.compute(Object.assign(Object.assign({},b),{get:()=>u(d.inputs,b,!0,m)}))}},2625:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseTransposeAttributes=t.transpose=t.createTransposeProgramInfo=t.transposeProgramMetadata=void 0;const n=e(6952),a=e(387),l=e(1163),c=e(2075);t.transposeProgramMetadata={name:"Transpose",inputTypes:[l.GpuDataType.default]};const f=(g,h)=>h&&h.length!==g.length?[...g.keys()].reverse():h;t.createTransposeProgramInfo=(g,h)=>{const p=g.dims,s=f(p,h),r=((y,w)=>n.ShapeUtil.sortBasedOnPerm(y,f(y,w)))(p,s),u=p.length,d=n.ShapeUtil.size(r),m=(0,c.createIndicesHelper)("output",r),b=(0,c.createIndicesHelper)("a",p);return Object.assign(Object.assign({},t.transposeProgramMetadata),{outputs:[{dims:r,dataType:g.dataType,gpuDataType:l.GpuDataType.default}],getShaderSource:y=>`
  @group(0) @binding(0) var<storage, read> a : array<f32>;
  @group(0) @binding(1) var<storage, read_write> output : array<f32>;

  ${((w,x)=>{const _=[];_.push(`fn perm(a: ptr<function, array<u32, ${x}>>, i: ptr<function, array<u32, ${x}>>) {`);for(let v=0;v<x;++v)_.push(`	(*a)[${w[v]}]=(*i)[${v}];`);return _.push("	}"),_.join(`
`)})(s,u)}
  ${m.o2iImpl}
  ${b.i2oImpl}

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes(d)}

    ${m.indicesVariableDeclaration("indices")}
    ${m.o2iCall("global_idx","indices")}
    ${b.indicesVariableDeclaration("aIndices")}
    perm(&aIndices, &indices);

    output[global_idx] = a[${b.i2oExpression("aIndices")}];
  }`,dispatchGroup:()=>({x:Math.ceil(d/64)})})},t.transpose=(g,h)=>{(p=>{if(!p||p.length!==1)throw new Error("Transpose requires 1 input.");if(p[0].dataType!==1)throw new Error("input should be float tensor")})(g.inputs),g.compute(Object.assign(Object.assign({},t.transposeProgramMetadata),{cacheHint:h.cacheKey,get:()=>(0,t.createTransposeProgramInfo)(g.inputs[0],h.perm)}))},t.parseTransposeAttributes=g=>(0,a.createAttributeWithCacheKey)({perm:g.perm})},9302:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.thresholdedRelu=t.tanh=t.tan=t.sqrt=t.sinh=t.sin=t.sigmoid=t.relu=t.reciprocal=t.neg=t.leakyRelu=t.floor=t.exp=t.erf=t.elu=t.parseAlphaAttributes=t.cosh=t.cos=t.ceil=t.clip=t.clipV10=t.atanh=t.atan=t.asinh=t.asin=t.acosh=t.acos=t.abs=void 0;const n=e(6952),a=e(387),l=e(1163),c=(f,g,h,p,s)=>{const r={name:g,inputTypes:[l.GpuDataType.default],cacheHint:s};return Object.assign(Object.assign({},r),{get:()=>((u,d,m,b)=>Object.assign(Object.assign({},u),{getShaderSource:y=>((w,x,_,v)=>{const E=Math.ceil(x/4);let I="";return I=typeof _=="string"?`${_}(a)`:_("a"),`
  @group(0) @binding(0) var<storage, read> inputData : array<vec4<f32>>;
  @group(0) @binding(1) var<storage, read_write> outputData : array<vec4<f32>>;

  ${v??""}

  ${w.mainStart()}
    ${w.guardAgainstOutOfBoundsWorkgroupSizes(E)}

    let a = inputData[global_idx];
    outputData[global_idx] = ${I};
  }`})(y,n.ShapeUtil.size(d.dims),m,b),outputs:[{dims:d.dims,dataType:d.dataType,gpuDataType:l.GpuDataType.default}],dispatchGroup:y=>({x:Math.ceil(n.ShapeUtil.size(y[0].dims)/64/4)})}))(r,f,h,p)})};t.abs=f=>{f.compute(c(f.inputs[0],"Abs","abs"))},t.acos=f=>{f.compute(c(f.inputs[0],"Acos","acos"))},t.acosh=f=>{f.compute(c(f.inputs[0],"Acosh","acosh"))},t.asin=f=>{f.compute(c(f.inputs[0],"Asin","asin"))},t.asinh=f=>{f.compute(c(f.inputs[0],"Asinh","asinh"))},t.atan=f=>{f.compute(c(f.inputs[0],"Atan","atan"))},t.atanh=f=>{f.compute(c(f.inputs[0],"Atanh","atanh"))},t.clipV10=(f,g)=>{f.compute(c(f.inputs[0],"Clip",h=>`clamp(${h}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<f32> = vec4(f32(${g.min}));
    const clip_max_: vec4<f32> = vec4(f32(${g.max}));
`,g.cacheKey),{inputs:[0]})},t.clip=f=>{const g=(h=>{const p=h.length>=2?h[1].getFloat32Array()[0]:n.MIN_CLIP,s=h.length>=3?h[2].getFloat32Array()[0]:n.MAX_CLIP;return(0,a.createAttributeWithCacheKey)({min:p,max:s})})(f.inputs);(0,t.clipV10)(f,g)},t.ceil=f=>{f.compute(c(f.inputs[0],"Ceil","ceil"))},t.cos=f=>{f.compute(c(f.inputs[0],"Cos","cos"))},t.cosh=f=>{f.compute(c(f.inputs[0],"Cosh","cosh"))},t.parseAlphaAttributes=f=>(0,a.createAttributeWithCacheKey)(f),t.elu=(f,g)=>{f.compute(c(f.inputs[0],"Elu",h=>`elu_vf32(${h})`,`
  const elu_alpha_: f32 = f32(${g.alpha});

  fn elu_f32(a: f32) -> f32 {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,g.cacheKey))},t.erf=f=>{f.compute(c(f.inputs[0],"Erf",g=>`erf_vf32(${g})`,`
  const r0: f32 = 0.3275911;
  const r1: f32 = 0.254829592;
  const r2: f32 = -0.284496736;
  const r3: f32 = 1.421413741;
  const r4: f32 = -1.453152027;
  const r5: f32 = 1.061405429;

  fn erf_vf32(v: vec4<f32>) -> vec4<f32> {
    let absv = abs(v);
    let x = 1.0 / (1.0 + r0 * absv);
    return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
  }`))},t.exp=f=>{f.compute(c(f.inputs[0],"Exp","exp"))},t.floor=f=>{f.compute(c(f.inputs[0],"Floor","floor"))},t.leakyRelu=(f,g)=>{f.compute(c(f.inputs[0],"LeakyRelu",h=>`select(leaky_relu_alpha_ * ${h}, ${h}, ${h} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${g.alpha});`,g.cacheKey))},t.neg=f=>{f.compute(c(f.inputs[0],"Neg",g=>`-${g}`))},t.reciprocal=f=>{f.compute(c(f.inputs[0],"Reciprocal",g=>`1.0/${g}`))},t.relu=f=>{f.compute(c(f.inputs[0],"Relu",g=>`select(vec4<f32>(0.0), ${g}, ${g} > vec4<f32>(0.0))`))},t.sigmoid=f=>{f.compute(c(f.inputs[0],"Sigmoid",g=>`(1.0 / (1.0 + exp(-${g})))`))},t.sin=f=>{f.compute(c(f.inputs[0],"Sin","sin"))},t.sinh=f=>{f.compute(c(f.inputs[0],"Sinh","sinh"))},t.sqrt=f=>{f.compute(c(f.inputs[0],"Sqrt","sqrt"))},t.tan=f=>{f.compute(c(f.inputs[0],"Tan","tan"))},t.tanh=f=>{f.compute(c(f.inputs[0],"Tanh","tanh"))},t.thresholdedRelu=(f,g)=>(f.compute(c(f.inputs[0],"ThresholdedRelu",h=>`select(vec4<f32>(0.0), ${h}, ${h} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${g.alpha});`,g.cacheKey)),0)},8305:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ProgramManager=void 0;const n=e(4955),a=e(2075);t.ProgramManager=class{constructor(l){this.backend=l,this.repo=new Map,this.attributesBound=!1}getArtifact(l){return this.repo.get(l)}setArtifact(l,c){this.repo.set(l,c)}run(l,c,f,g){const h=this.backend.device,p=this.backend.getComputePassEncoder();this.backend.profilingEnabled&&p.writeTimestamp(this.backend.profilingQuerySet,0),p.setPipeline(l.computePipeline);const s=[];for(const u of c)s.push({binding:s.length,resource:{buffer:u.buffer}});for(const u of f)s.push({binding:s.length,resource:{buffer:u.buffer}});const r=h.createBindGroup({layout:l.computePipeline.getBindGroupLayout(0),entries:s});if(p.setBindGroup(0,r),p.dispatchWorkgroups(...g),this.backend.pendingDispatchNumber++,this.backend.profilingEnabled){p.writeTimestamp(this.backend.profilingQuerySet,1);const u=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),d=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,u.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(u.buffer,0,d.buffer,0,16),this.backend.flush();const m=this.backend.currentKernelId,b=this.backend.kernels.get(m)[0];d.buffer.mapAsync(GPUMapMode.READ).then(()=>{const y=new BigUint64Array(d.buffer.getMappedRange()),w=y[0],x=y[1];d.buffer.unmap(),this.backend.profilingTimeBase===void 0&&(this.backend.profilingTimeBase=w);const _=Number(w-this.backend.profilingTimeBase),v=Number(x-this.backend.profilingTimeBase);if(!Number.isSafeInteger(_)||!Number.isSafeInteger(v))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(u.id),this.backend.gpuDataManager.release(d.id),console.log(`[profiling] kernel "${m}|${b}" execution time: ${v-_} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(l,c){const f=this.backend.device,g=l.getShaderSource((0,a.createShaderHelper)(c)),h=f.createShaderModule({code:g});return(0,n.LOG_DEBUG)("verbose",()=>`[WebGPU] shader code: ${g}`),{programInfo:l,computePipeline:f.createComputePipeline({compute:{module:h,entryPoint:"main"},layout:"auto"})}}normalizeDispatchGroupSize(l){const c=typeof l=="number"?l:l.x,f=typeof l=="number"?1:l.y||1,g=typeof l=="number"?1:l.z||1,h=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(c<=h&&f<=h&&g<=h)return[c,f,g];const p=c*f*g;let s=Math.ceil(Math.sqrt(p));if(s>h){if(s=Math.ceil(Math.cbrt(p)),s>h)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[s,s,s]}return[s,s,1]}}},1163:(o,t)=>{var e;Object.defineProperty(t,"__esModule",{value:!0}),t.GpuDataType=void 0,(e=t.GpuDataType||(t.GpuDataType={}))[e.default=0]="default",e[e.upload=1]="upload",e[e.profile=2]="profile"},3899:(o,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.iterateExtraOptions=void 0,t.iterateExtraOptions=(e,n,a,l)=>{if(typeof e=="object"&&e!==null){if(a.has(e))throw new Error("Circular reference in options");a.add(e)}Object.entries(e).forEach(([c,f])=>{const g=n?n+c:c;if(typeof f=="object")(0,t.iterateExtraOptions)(f,g+".",a,l);else if(typeof f=="string"||typeof f=="number")l(g,f.toString());else{if(typeof f!="boolean")throw new Error("Can't handle extra config type: "+typeof f);l(g,f?"1":"0")}})}},9544:function(o,t,e){var n,a=this&&this.__createBinding||(Object.create?function(O,$,D,M){M===void 0&&(M=D);var F=Object.getOwnPropertyDescriptor($,D);F&&!("get"in F?!$.__esModule:F.writable||F.configurable)||(F={enumerable:!0,get:function(){return $[D]}}),Object.defineProperty(O,M,F)}:function(O,$,D,M){M===void 0&&(M=D),O[M]=$[D]}),l=this&&this.__setModuleDefault||(Object.create?function(O,$){Object.defineProperty(O,"default",{enumerable:!0,value:$})}:function(O,$){O.default=$}),c=this&&this.__importStar||function(O){if(O&&O.__esModule)return O;var $={};if(O!=null)for(var D in O)D!=="default"&&Object.prototype.hasOwnProperty.call(O,D)&&a($,O,D);return l($,O),$};Object.defineProperty(t,"__esModule",{value:!0}),t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=t.initWasm=void 0;const f=e(8453),g=e(7675),h=c(e(1259)),p=e(263),s=()=>!!f.env.wasm.proxy&&typeof document<"u";let r,u,d,m=!1,b=!1,y=!1;const w=[],x=[],_=[],v=[],E=[],I=[],S=()=>{if(m||!b||y||!r)throw new Error("worker not ready")},T=O=>{switch(O.data.type){case"init-wasm":m=!1,O.data.err?(y=!0,u[1](O.data.err)):(b=!0,u[0]());break;case"init-ort":O.data.err?d[1](O.data.err):d[0]();break;case"create_allocate":O.data.err?w.shift()[1](O.data.err):w.shift()[0](O.data.out);break;case"create_finalize":O.data.err?x.shift()[1](O.data.err):x.shift()[0](O.data.out);break;case"create":O.data.err?_.shift()[1](O.data.err):_.shift()[0](O.data.out);break;case"release":O.data.err?v.shift()[1](O.data.err):v.shift()[0]();break;case"run":O.data.err?E.shift()[1](O.data.err):E.shift()[0](O.data.out);break;case"end-profiling":O.data.err?I.shift()[1](O.data.err):I.shift()[0]()}},A=typeof document<"u"?(n=document==null?void 0:document.currentScript)===null||n===void 0?void 0:n.src:void 0;t.initWasm=async()=>{if(s()){if(b)return;if(m)throw new Error("multiple calls to 'initWasm()' detected.");if(y)throw new Error("previous call to 'initWasm()' failed.");return m=!0,f.env.wasm.wasmPaths===void 0&&A&&A.indexOf("blob:")!==0&&(f.env.wasm.wasmPaths=A.substr(0,+A.lastIndexOf("/")+1)),new Promise((O,$)=>{r==null||r.terminate(),r=e(8050).Z(),r.onmessage=T,u=[O,$];const D={type:"init-wasm",in:f.env.wasm};r.postMessage(D)})}return(0,p.initializeWebAssembly)(f.env.wasm)},t.initOrt=async(O,$)=>{if(s())return S(),new Promise((D,M)=>{d=[D,M];const F={type:"init-ort",in:{numThreads:O,loggingLevel:$}};r.postMessage(F)});h.initOrt(O,$),await(0,g.init)((0,p.getInstance)())},t.createSessionAllocate=async O=>s()?(S(),new Promise(($,D)=>{w.push([$,D]);const M={type:"create_allocate",in:{model:O}};r.postMessage(M,[O.buffer])})):h.createSessionAllocate(O),t.createSessionFinalize=async(O,$)=>s()?(S(),new Promise((D,M)=>{x.push([D,M]);const F={type:"create_finalize",in:{modeldata:O,options:$}};r.postMessage(F)})):h.createSessionFinalize(O,$),t.createSession=async(O,$)=>s()?(S(),new Promise((D,M)=>{_.push([D,M]);const F={type:"create",in:{model:O,options:$}};r.postMessage(F,[O.buffer])})):h.createSession(O,$),t.releaseSession=async O=>{if(s())return S(),new Promise(($,D)=>{v.push([$,D]);const M={type:"release",in:O};r.postMessage(M)});h.releaseSession(O)},t.run=async(O,$,D,M,F)=>s()?(S(),new Promise((C,R)=>{E.push([C,R]);const j={type:"run",in:{sessionId:O,inputIndices:$,inputs:D,outputIndices:M,options:F}};r.postMessage(j,h.extractTransferableBuffers(D))})):h.run(O,$,D,M,F),t.endProfiling=async O=>{if(s())return S(),new Promise(($,D)=>{I.push([$,D]);const M={type:"end-profiling",in:O};r.postMessage(M)});h.endProfiling(O)}},7918:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const n=e(3899),a=e(9444),l=e(263);t.setRunOptions=c=>{const f=(0,l.getInstance)();let g=0;const h=[],p=c||{};try{if((c==null?void 0:c.logSeverityLevel)===void 0)p.logSeverityLevel=2;else if(typeof c.logSeverityLevel!="number"||!Number.isInteger(c.logSeverityLevel)||c.logSeverityLevel<0||c.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${c.logSeverityLevel}`);if((c==null?void 0:c.logVerbosityLevel)===void 0)p.logVerbosityLevel=0;else if(typeof c.logVerbosityLevel!="number"||!Number.isInteger(c.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${c.logVerbosityLevel}`);(c==null?void 0:c.terminate)===void 0&&(p.terminate=!1);let s=0;if((c==null?void 0:c.tag)!==void 0&&(s=(0,a.allocWasmString)(c.tag,h)),g=f._OrtCreateRunOptions(p.logSeverityLevel,p.logVerbosityLevel,!!p.terminate,s),g===0)throw new Error("Can't create run options");return(c==null?void 0:c.extra)!==void 0&&(0,n.iterateExtraOptions)(c.extra,"",new WeakSet,(r,u)=>{const d=(0,a.allocWasmString)(r,h),m=(0,a.allocWasmString)(u,h);if(f._OrtAddRunConfigEntry(g,d,m)!==0)throw new Error(`Can't set a run config entry: ${r} - ${u}`)}),[g,h]}catch(s){throw g!==0&&f._OrtReleaseRunOptions(g),h.forEach(f._free),s}}},6640:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.OnnxruntimeWebAssemblySessionHandler=void 0;const n=e(2806),a=e(8453),l=e(2850),c=e(9544),f=e(7917);let g;t.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(h){const p=await fetch(h),s=await p.arrayBuffer();return(0,c.createSessionAllocate)(new Uint8Array(s))}async loadModel(h,p){if(g||(await(0,c.initOrt)(a.env.wasm.numThreads,(0,f.logLevelStringToEnum)(a.env.logLevel)),g=!0),typeof h=="string")if(typeof fetch>"u"){const s=await(0,l.promisify)(n.readFile)(h);[this.sessionId,this.inputNames,this.outputNames]=await(0,c.createSession)(s,p)}else{const s=await this.createSessionAllocate(h);[this.sessionId,this.inputNames,this.outputNames]=await(0,c.createSessionFinalize)(s,p)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,c.createSession)(h,p)}async dispose(){return(0,c.releaseSession)(this.sessionId)}async run(h,p,s){const r=[],u=[];Object.entries(h).forEach(y=>{const w=y[0],x=y[1],_=this.inputNames.indexOf(w);if(_===-1)throw new Error(`invalid input '${w}'`);r.push(x),u.push(_)});const d=[];Object.entries(p).forEach(y=>{const w=y[0],x=this.outputNames.indexOf(w);if(x===-1)throw new Error(`invalid output '${w}'`);d.push(x)});const m=await(0,c.run)(this.sessionId,u,r.map(y=>[y.type,y.dims,y.data]),d,s),b={};for(let y=0;y<m.length;y++)b[this.outputNames[d[y]]]=new a.Tensor(m[y][0],m[y][2],m[y][1]);return b}startProfiling(){}endProfiling(){(0,c.endProfiling)(this.sessionId)}}},7622:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const n=e(3899),a=e(9444),l=e(263);t.setSessionOptions=c=>{var f,g,h,p;const s=(0,l.getInstance)();let r=0;const u=[],d=c||{};(m=>{m.extra||(m.extra={}),m.extra.session||(m.extra.session={});const b=m.extra.session;b.use_ort_model_bytes_directly||(b.use_ort_model_bytes_directly="1"),m.executionProviders&&m.executionProviders.some(y=>(typeof y=="string"?y:y.name)==="webgpu")&&(m.enableMemPattern=!1)})(d);try{const m=(v=>{switch(v){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${v}`)}})((f=d.graphOptimizationLevel)!==null&&f!==void 0?f:"all"),b=(v=>{switch(v){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${v}`)}})((g=d.executionMode)!==null&&g!==void 0?g:"sequential"),y=typeof d.logId=="string"?(0,a.allocWasmString)(d.logId,u):0,w=(h=d.logSeverityLevel)!==null&&h!==void 0?h:2;if(!Number.isInteger(w)||w<0||w>4)throw new Error(`log serverity level is not valid: ${w}`);const x=(p=d.logVerbosityLevel)!==null&&p!==void 0?p:0;if(!Number.isInteger(x)||x<0||x>4)throw new Error(`log verbosity level is not valid: ${x}`);const _=typeof d.optimizedModelFilePath=="string"?(0,a.allocWasmString)(d.optimizedModelFilePath,u):0;if(r=s._OrtCreateSessionOptions(m,!!d.enableCpuMemArena,!!d.enableMemPattern,b,!!d.enableProfiling,0,y,w,x,_),r===0)throw new Error("Can't create session options");return d.executionProviders&&((v,E,I)=>{for(const S of E){let T=typeof S=="string"?S:S.name;switch(T){case"xnnpack":T="XNNPACK";break;case"webgpu":T="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${T}`)}const A=(0,a.allocWasmString)(T,I);if((0,l.getInstance)()._OrtAppendExecutionProvider(v,A)!==0)throw new Error(`Can't append execution provider: ${T}`)}})(r,d.executionProviders,u),d.extra!==void 0&&(0,n.iterateExtraOptions)(d.extra,"",new WeakSet,(v,E)=>{const I=(0,a.allocWasmString)(v,u),S=(0,a.allocWasmString)(E,u);if(s._OrtAddSessionConfigEntry(r,I,S)!==0)throw new Error(`Can't set a session config entry: ${v} - ${E}`)}),[r,u]}catch(m){throw r!==0&&s._OrtReleaseSessionOptions(r),u.forEach(s._free),m}}},9444:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.allocWasmString=void 0;const n=e(263);t.allocWasmString=(a,l)=>{const c=(0,n.getInstance)(),f=c.lengthBytesUTF8(a)+1,g=c._malloc(f);return c.stringToUTF8(a,g,f),l.push(g),g}},7917:(o,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},1259:(o,t,e)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=void 0;const n=e(7918),a=e(7622),l=e(9444),c=e(7917),f=e(263);t.initOrt=(h,p)=>{const s=(0,f.getInstance)()._OrtInit(h,p);if(s!==0)throw new Error(`Can't initialize onnxruntime. error code = ${s}`)};const g=new Map;t.createSessionAllocate=h=>{const p=(0,f.getInstance)(),s=p._malloc(h.byteLength);return p.HEAPU8.set(h,s),[s,h.byteLength]},t.createSessionFinalize=(h,p)=>{const s=(0,f.getInstance)();let r=0,u=0,d=[];try{if([u,d]=(0,a.setSessionOptions)(p),r=s._OrtCreateSession(h[0],h[1],u),r===0)throw new Error("Can't create a session")}finally{s._free(h[0]),u!==0&&s._OrtReleaseSessionOptions(u),d.forEach(s._free)}const m=s._OrtGetInputCount(r),b=s._OrtGetOutputCount(r),y=[],w=[],x=[],_=[];for(let v=0;v<m;v++){const E=s._OrtGetInputName(r,v);if(E===0)throw new Error("Can't get an input name");w.push(E),y.push(s.UTF8ToString(E))}for(let v=0;v<b;v++){const E=s._OrtGetOutputName(r,v);if(E===0)throw new Error("Can't get an output name");_.push(E),x.push(s.UTF8ToString(E))}return g.set(r,[r,w,_]),[r,y,x]},t.createSession=(h,p)=>{const s=(0,t.createSessionAllocate)(h);return(0,t.createSessionFinalize)(s,p)},t.releaseSession=h=>{const p=(0,f.getInstance)(),s=g.get(h);if(!s)throw new Error("invalid session id");const r=s[0],u=s[1],d=s[2];u.forEach(p._OrtFree),d.forEach(p._OrtFree),p._OrtReleaseSession(r),g.delete(h)},t.run=async(h,p,s,r,u)=>{const d=(0,f.getInstance)(),m=g.get(h);if(!m)throw new Error("invalid session id");const b=m[0],y=m[1],w=m[2],x=p.length,_=r.length;let v=0,E=[];const I=[],S=[];try{[v,E]=(0,n.setRunOptions)(u);for(let M=0;M<x;M++){const F=s[M][0],C=s[M][1],R=s[M][2];let j,G;if(Array.isArray(R)){G=4*R.length,j=d._malloc(G),S.push(j);let at=j/4;for(let J=0;J<R.length;J++){if(typeof R[J]!="string")throw new TypeError(`tensor data at index ${J} is not a string`);d.HEAPU32[at++]=(0,l.allocWasmString)(R[J],S)}}else G=R.byteLength,j=d._malloc(G),S.push(j),d.HEAPU8.set(new Uint8Array(R.buffer,R.byteOffset,G),j);const W=d.stackSave(),Z=d.stackAlloc(4*C.length);try{let at=Z/4;C.forEach(Y=>d.HEAP32[at++]=Y);const J=d._OrtCreateTensor((0,c.tensorDataTypeStringToEnum)(F),j,G,Z,C.length);if(J===0)throw new Error("Can't create a tensor");I.push(J)}finally{d.stackRestore(W)}}const T=d.stackSave(),A=d.stackAlloc(4*x),O=d.stackAlloc(4*x),$=d.stackAlloc(4*_),D=d.stackAlloc(4*_);try{let M=A/4,F=O/4,C=$/4,R=D/4;for(let Z=0;Z<x;Z++)d.HEAPU32[M++]=I[Z],d.HEAPU32[F++]=y[p[Z]];for(let Z=0;Z<_;Z++)d.HEAPU32[C++]=0,d.HEAPU32[R++]=w[r[Z]];let j=d._OrtRun(b,O,A,x,D,_,$,v);const G=d.jsepRunPromise;G&&G.then!==void 0&&(j=await G);const W=[];if(j===0)for(let Z=0;Z<_;Z++){const at=d.HEAPU32[$/4+Z],J=d.stackSave(),Y=d.stackAlloc(16);let K,it=0;try{if(j=d._OrtGetTensorData(at,Y,Y+4,Y+8,Y+12),j!==0)throw new Error(`Can't access output tensor data. error code = ${j}`);let rt=Y/4;const yt=d.HEAPU32[rt++];it=d.HEAPU32[rt++];const ut=d.HEAPU32[rt++],St=d.HEAPU32[rt++],gt=[];for(let pt=0;pt<St;pt++)gt.push(d.HEAPU32[ut/4+pt]);d._OrtFree(ut);const Ot=gt.length===0?1:gt.reduce((pt,ct)=>pt*ct);if(K=(0,c.tensorDataTypeEnumToString)(yt),K==="string"){const pt=[];let ct=it/4;for(let ot=0;ot<Ot;ot++){const Mt=d.HEAPU32[ct++],It=ot===Ot-1?void 0:d.HEAPU32[ct]-Mt;pt.push(d.UTF8ToString(Mt,It))}W.push([K,gt,pt])}else{const pt=new((0,c.tensorTypeToTypedArrayConstructor)(K))(Ot);new Uint8Array(pt.buffer,pt.byteOffset,pt.byteLength).set(d.HEAPU8.subarray(it,it+pt.byteLength)),W.push([K,gt,pt])}}finally{d.stackRestore(J),K==="string"&&it&&d._free(it),d._OrtReleaseTensor(at)}}if(j===0)return W;throw new Error(`failed to call OrtRun(). error code = ${j}.`)}finally{d.stackRestore(T)}}finally{I.forEach(d._OrtReleaseTensor),S.forEach(d._free),d._OrtReleaseRunOptions(v),E.forEach(d._free)}},t.endProfiling=h=>{const p=(0,f.getInstance)(),s=g.get(h);if(!s)throw new Error("invalid session id");const r=s[0],u=p._OrtEndProfiling(r);if(u===0)throw new Error("Can't get an profile file name");p._OrtFree(u)},t.extractTransferableBuffers=h=>{const p=[];for(const s of h){const r=s[2];!Array.isArray(r)&&r.buffer&&p.push(r.buffer)}return p}},263:function(o,t,e){var n=this&&this.__createBinding||(Object.create?function(u,d,m,b){b===void 0&&(b=m);var y=Object.getOwnPropertyDescriptor(d,m);y&&!("get"in y?!d.__esModule:y.writable||y.configurable)||(y={enumerable:!0,get:function(){return d[m]}}),Object.defineProperty(u,b,y)}:function(u,d,m,b){b===void 0&&(b=m),u[b]=d[m]}),a=this&&this.__setModuleDefault||(Object.create?function(u,d){Object.defineProperty(u,"default",{enumerable:!0,value:d})}:function(u,d){u.default=d}),l=this&&this.__importStar||function(u){if(u&&u.__esModule)return u;var d={};if(u!=null)for(var m in u)m!=="default"&&Object.prototype.hasOwnProperty.call(u,m)&&n(d,u,m);return a(d,u),d};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const c=l(e(6449)),f=e(932),g=e(3474);let h,p=!1,s=!1,r=!1;t.initializeWebAssembly=async u=>{if(p)return Promise.resolve();if(s)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(r)throw new Error("previous call to 'initializeWebAssembly()' failed.");s=!0;const d=u.initTimeout,m=u.numThreads,b=u.simd,y=m>1&&(()=>{try{return typeof SharedArrayBuffer<"u"&&(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}})(),w=b&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}})(),x=u.wasmPaths,_=typeof x=="string"?x:void 0,v=((T,A)=>A?T?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":T?"ort-wasm-simd.wasm":"ort-wasm.wasm")(w,y),E=typeof x=="object"?x[v]:void 0;let I=!1;const S=[];if(d>0&&S.push(new Promise(T=>{setTimeout(()=>{I=!0,T()},d)})),S.push(new Promise((T,A)=>{const O=y?g:f,$={locateFile:(D,M)=>y&&D.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([e(4154)],{type:"text/javascript"})):D.endsWith(".wasm")?E||(_??M)+v:M+D};if(y)if(typeof Blob>"u")$.mainScriptUrlOrBlob=c.join("/","ort-wasm-threaded.js");else{const D=`var ortWasmThreaded=(function(){var _scriptDir;return ${O.toString()}})();`;$.mainScriptUrlOrBlob=new Blob([D],{type:"text/javascript"})}O($).then(D=>{s=!1,p=!0,h=D,T()},D=>{s=!1,r=!0,A(D)})})),await Promise.race(S),I)throw new Error(`WebAssembly backend initializing failed due to timeout: ${d}ms`)},t.getInstance=()=>{if(p&&h)return h;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var u;!p||s||r||(s=!0,(u=h.PThread)===null||u===void 0||u.terminateAllThreads(),h=void 0,s=!1,p=!1,r=!0)}},8050:(o,t,e)=>{e.d(t,{Z:()=>l});var n=e(6614),a=e.n(n);function l(){return a()('/*!\n* ONNX Runtime Web v1.15.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var e={899:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.iterateExtraOptions=void 0,t.iterateExtraOptions=(e,n,r,a)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach((([e,o])=>{const i=n?n+e:e;if("object"==typeof o)(0,t.iterateExtraOptions)(o,i+".",r,a);else if("string"==typeof o||"number"==typeof o)a(i,o.toString());else{if("boolean"!=typeof o)throw new Error("Can\'t handle extra config type: "+typeof o);a(i,o?"1":"0")}}))}},918:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const r=n(899),a=n(444),o=n(263);t.setRunOptions=e=>{const t=(0,o.getInstance)();let n=0;const i=[],s=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(s.terminate=!1);let o=0;if(void 0!==(null==e?void 0:e.tag)&&(o=(0,a.allocWasmString)(e.tag,i)),n=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,o),0===n)throw new Error("Can\'t create run options");return void 0!==(null==e?void 0:e.extra)&&(0,r.iterateExtraOptions)(e.extra,"",new WeakSet,((e,r)=>{const o=(0,a.allocWasmString)(e,i),s=(0,a.allocWasmString)(r,i);if(0!==t._OrtAddRunConfigEntry(n,o,s))throw new Error(`Can\'t set a run config entry: ${e} - ${r}`)})),[n,i]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),i.forEach(t._free),e}}},622:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const r=n(899),a=n(444),o=n(263);t.setSessionOptions=e=>{var t,n,i,s;const u=(0,o.getInstance)();let c=0;const l=[],f=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(f);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=f.graphOptimizationLevel)&&void 0!==t?t:"all"),p=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(n=f.executionMode)&&void 0!==n?n:"sequential"),d="string"==typeof f.logId?(0,a.allocWasmString)(f.logId,l):0,m=null!==(i=f.logSeverityLevel)&&void 0!==i?i:2;if(!Number.isInteger(m)||m<0||m>4)throw new Error(`log serverity level is not valid: ${m}`);const g=null!==(s=f.logVerbosityLevel)&&void 0!==s?s:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const h="string"==typeof f.optimizedModelFilePath?(0,a.allocWasmString)(f.optimizedModelFilePath,l):0;if(c=u._OrtCreateSessionOptions(e,!!f.enableCpuMemArena,!!f.enableMemPattern,p,!!f.enableProfiling,0,d,m,g,h),0===c)throw new Error("Can\'t create session options");return f.executionProviders&&((e,t,n)=>{for(const r of t){let t="string"==typeof r?r:r.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${t}`)}const i=(0,a.allocWasmString)(t,n);if(0!==(0,o.getInstance)()._OrtAppendExecutionProvider(e,i))throw new Error(`Can\'t append execution provider: ${t}`)}})(c,f.executionProviders,l),void 0!==f.extra&&(0,r.iterateExtraOptions)(f.extra,"",new WeakSet,((e,t)=>{const n=(0,a.allocWasmString)(e,l),r=(0,a.allocWasmString)(t,l);if(0!==u._OrtAddSessionConfigEntry(c,n,r))throw new Error(`Can\'t set a session config entry: ${e} - ${t}`)})),[c,l]}catch(e){throw 0!==c&&u._OrtReleaseSessionOptions(c),l.forEach(u._free),e}}},444:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allocWasmString=void 0;const r=n(263);t.allocWasmString=(e,t)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(e)+1,o=n._malloc(a);return n.stringToUTF8(e,o,a),t.push(o),o}},917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},259:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=void 0;const r=n(918),a=n(622),o=n(444),i=n(917),s=n(263);t.initOrt=(e,t)=>{const n=(0,s.getInstance)()._OrtInit(e,t);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;t.createSessionAllocate=e=>{const t=(0,s.getInstance)(),n=t._malloc(e.byteLength);return t.HEAPU8.set(e,n),[n,e.byteLength]},t.createSessionFinalize=(e,t)=>{const n=(0,s.getInstance)();let r=0,o=0,i=[];try{if([o,i]=(0,a.setSessionOptions)(t),r=n._OrtCreateSession(e[0],e[1],o),0===r)throw new Error("Can\'t create a session")}finally{n._free(e[0]),0!==o&&n._OrtReleaseSessionOptions(o),i.forEach(n._free)}const c=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],d=[],m=[];for(let e=0;e<c;e++){const t=n._OrtGetInputName(r,e);if(0===t)throw new Error("Can\'t get an input name");p.push(t),f.push(n.UTF8ToString(t))}for(let e=0;e<l;e++){const t=n._OrtGetOutputName(r,e);if(0===t)throw new Error("Can\'t get an output name");m.push(t),d.push(n.UTF8ToString(t))}return u.set(r,[r,p,m]),[r,f,d]},t.createSession=(e,n)=>{const r=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(r,n)},t.releaseSession=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],o=n[2];a.forEach(t._OrtFree),o.forEach(t._OrtFree),t._OrtReleaseSession(r),u.delete(e)},t.run=async(e,t,n,a,c)=>{const l=(0,s.getInstance)(),f=u.get(e);if(!f)throw new Error("invalid session id");const p=f[0],d=f[1],m=f[2],g=t.length,h=a.length;let y=0,v=[];const b=[],w=[];try{[y,v]=(0,r.setRunOptions)(c);for(let e=0;e<g;e++){const t=n[e][0],r=n[e][1],a=n[e][2];let s,u;if(Array.isArray(a)){u=4*a.length,s=l._malloc(u),w.push(s);let e=s/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);l.HEAPU32[e++]=(0,o.allocWasmString)(a[t],w)}}else u=a.byteLength,s=l._malloc(u),w.push(s),l.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),s);const c=l.stackSave(),f=l.stackAlloc(4*r.length);try{let e=f/4;r.forEach((t=>l.HEAP32[e++]=t));const n=l._OrtCreateTensor((0,i.tensorDataTypeStringToEnum)(t),s,u,f,r.length);if(0===n)throw new Error("Can\'t create a tensor");b.push(n)}finally{l.stackRestore(c)}}const e=l.stackSave(),s=l.stackAlloc(4*g),u=l.stackAlloc(4*g),f=l.stackAlloc(4*h),_=l.stackAlloc(4*h);try{let e=s/4,n=u/4,r=f/4,o=_/4;for(let r=0;r<g;r++)l.HEAPU32[e++]=b[r],l.HEAPU32[n++]=d[t[r]];for(let e=0;e<h;e++)l.HEAPU32[r++]=0,l.HEAPU32[o++]=m[a[e]];let c=l._OrtRun(p,u,s,g,_,h,f,y);const v=l.jsepRunPromise;v&&void 0!==v.then&&(c=await v);const w=[];if(0===c)for(let e=0;e<h;e++){const t=l.HEAPU32[f/4+e],n=l.stackSave(),r=l.stackAlloc(16);let a,o=0;try{if(c=l._OrtGetTensorData(t,r,r+4,r+8,r+12),0!==c)throw new Error(`Can\'t access output tensor data. error code = ${c}`);let e=r/4;const n=l.HEAPU32[e++];o=l.HEAPU32[e++];const s=l.HEAPU32[e++],u=l.HEAPU32[e++],f=[];for(let e=0;e<u;e++)f.push(l.HEAPU32[s/4+e]);l._OrtFree(s);const p=0===f.length?1:f.reduce(((e,t)=>e*t));if(a=(0,i.tensorDataTypeEnumToString)(n),"string"===a){const e=[];let t=o/4;for(let n=0;n<p;n++){const r=l.HEAPU32[t++],a=n===p-1?void 0:l.HEAPU32[t]-r;e.push(l.UTF8ToString(r,a))}w.push([a,f,e])}else{const e=new((0,i.tensorTypeToTypedArrayConstructor)(a))(p);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(l.HEAPU8.subarray(o,o+e.byteLength)),w.push([a,f,e])}}finally{l.stackRestore(n),"string"===a&&o&&l._free(o),l._OrtReleaseTensor(t)}}if(0===c)return w;throw new Error(`failed to call OrtRun(). error code = ${c}.`)}finally{l.stackRestore(e)}}finally{b.forEach(l._OrtReleaseTensor),w.forEach(l._free),l._OrtReleaseRunOptions(y),v.forEach(l._free)}},t.endProfiling=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=t._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const n of e){const e=n[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(t,n);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,a)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const i=o(n(449)),s=n(932),u=n(474);let c,l=!1,f=!1,p=!1;t.initializeWebAssembly=async e=>{if(l)return Promise.resolve();if(f)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(p)throw new Error("previous call to \'initializeWebAssembly()\' failed.");f=!0;const t=e.initTimeout,r=e.numThreads,a=e.simd,o=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),d=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),m=e.wasmPaths,g="string"==typeof m?m:void 0,h=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(d,o),y="object"==typeof m?m[h]:void 0;let v=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{v=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{const r=o?u:s,a={locateFile:(e,t)=>o&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):e.endsWith(".wasm")?y||(null!=g?g:t)+h:t+e};if(o)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=i.join("/","ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}r(a).then((t=>{f=!1,l=!0,c=t,e()}),(e=>{f=!1,p=!0,t(e)}))}))),await Promise.race(b),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(l&&c)return c;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!l||f||p||(f=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,f=!1,l=!1,p=!0)}},474:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){function t(){return P.buffer!=D&&G(P.buffer),F}function r(){return P.buffer!=D&&G(P.buffer),U}function a(){return P.buffer!=D&&G(P.buffer),I}function o(){return P.buffer!=D&&G(P.buffer),W}function i(){return P.buffer!=D&&G(P.buffer),j}var s,u,c;e=e||{},s||(s=void 0!==e?e:{}),s.ready=new Promise((function(e,t){u=e,c=t}));var l,f,p,d,m,g,h=Object.assign({},s),y="./this.program",v=(e,t)=>{throw t},b="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=s.ENVIRONMENT_IS_PTHREAD||!1,S="";function T(e){return s.locateFile?s.locateFile(e,S):S+e}if(_){let t;S=w?n(908).dirname(S)+"/":"//",g=()=>{m||(d=n(384),m=n(908))},l=function(e,t){return g(),e=m.normalize(e),d.readFileSync(e,t?void 0:"utf8")},p=e=>((e=l(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,n)=>{g(),e=m.normalize(e),d.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(y=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof ie))throw e})),process.on("unhandledRejection",(function(e){throw e})),v=(e,t)=>{if(C)throw process.exitCode=e,t;t instanceof ie||x("exiting due to exception: "+t),process.exit(e)},s.inspect=function(){return"[Emscripten Module object]"};try{t=n(925)}catch(e){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),e}n.g.Worker=t.Worker}else(b||w)&&(w?S=self.location.href:"undefined"!=typeof document&&document.currentScript&&(S=document.currentScript.src),_scriptDir&&(S=_scriptDir),S=0!==S.indexOf("blob:")?S.substr(0,S.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},w&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var A=console.log.bind(console),E=console.warn.bind(console);_&&(g(),A=e=>d.writeSync(1,e+"\\n"),E=e=>d.writeSync(2,e+"\\n"));var M,R=s.print||A,x=s.printErr||E;Object.assign(s,h),h=null,s.thisProgram&&(y=s.thisProgram),s.quit&&(v=s.quit),s.wasmBinary&&(M=s.wasmBinary);var C=s.noExitRuntime||!0;"object"!=typeof WebAssembly&&ne("no native wasm support detected");var P,k,D,F,U,I,W,j,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function Y(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&L)return L.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function z(e,t){return(e>>>=0)?Y(r(),e,t):""}function B(e,t,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-a}function N(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function G(e){D=e,s.HEAP8=F=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=I=new Int32Array(e),s.HEAPU8=U=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=W=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=j=new Float64Array(e)}O&&(D=s.buffer);var q=s.INITIAL_MEMORY||16777216;if(O)P=s.wasmMemory,D=s.buffer;else if(s.wasmMemory)P=s.wasmMemory;else if(!((P=new WebAssembly.Memory({initial:q/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");P&&(D=P.buffer),q=D.byteLength,G(D);var $,V=[],J=[],Q=[];function X(){var e=s.preRun.shift();V.unshift(e)}var K,Z=0,ee=null,te=null;function ne(e){throw O?postMessage({cmd:"onAbort",arg:e}):s.onAbort&&s.onAbort(e),x(e="Aborted("+e+")"),H=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),c(e),e}function re(){return K.startsWith("data:application/octet-stream;base64,")}function ae(){var e=K;try{if(e==K&&M)return new Uint8Array(M);if(p)return p(e);throw"both async and sync fetching of the wasm failed"}catch(e){ne(e)}}K="ort-wasm-threaded.wasm",re()||(K=T(K));var oe={};function ie(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function se(e){(e=fe.La[e])||ne(),fe.Xa(e)}function ue(e){var t=fe.lb();if(!t)return 6;fe.Ra.push(t),fe.La[e.Ka]=t,t.Ka=e.Ka;var n={cmd:"run",start_routine:e.pb,arg:e.ib,pthread_ptr:e.Ka};return t.Qa=()=>{n.time=performance.now(),t.postMessage(n,e.vb)},t.loaded&&(t.Qa(),delete t.Qa),0}function ce(e){if(O)return He(1,1,e);C||(fe.qb(),s.onExit&&s.onExit(e),H=!0),v(e,new ie(e))}function le(e,t){if(!t&&O)throw de(e),"unwind";ce(e)}var fe={Oa:[],Ra:[],$a:[],La:{},Ua:function(){O&&fe.mb()},xb:function(){},mb:function(){fe.receiveObjectTransfer=fe.ob,fe.threadInitTLS=fe.Za,fe.setExitStatus=fe.Ya,C=!1},Ya:function(){},qb:function(){for(var e of Object.values(fe.La))fe.Xa(e);for(e of fe.Oa)e.terminate();fe.Oa=[]},Xa:function(e){var t=e.Ka;delete fe.La[t],fe.Oa.push(e),fe.Ra.splice(fe.Ra.indexOf(e),1),e.Ka=0,ct(t)},ob:function(){},Za:function(){fe.$a.forEach((e=>e()))},nb:function(e,t){e.onmessage=n=>{var r=(n=n.data).cmd;if(e.Ka&&(fe.kb=e.Ka),n.targetThread&&n.targetThread!=rt()){var a=fe.La[n.yb];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?De(n.queue):"spawnThread"===r?ue(n):"cleanupThread"===r?se(n.thread):"killThread"===r?(n=n.thread,r=fe.La[n],delete fe.La[n],r.terminate(),ct(n),fe.Ra.splice(fe.Ra.indexOf(r),1),r.Ka=0):"cancelThread"===r?fe.La[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t&&t(e),e.Qa&&(e.Qa(),delete e.Qa)):"print"===r?R("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?e.postMessage(n):"onAbort"===r?s.onAbort&&s.onAbort(n.arg):r&&x("worker sent an unknown command "+r);fe.kb=void 0},e.onerror=e=>{throw x("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},_&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){}))),e.postMessage({cmd:"load",urlOrBlob:s.mainScriptUrlOrBlob||_scriptDir,wasmMemory:P,wasmModule:k})},hb:function(){var e=T("ort-wasm-threaded.worker.js");fe.Oa.push(new Worker(e))},lb:function(){return 0==fe.Oa.length&&(fe.hb(),fe.nb(fe.Oa[0])),fe.Oa.pop()}};function pe(e){for(;0<e.length;)e.shift()(s)}function de(e){if(O)return He(2,0,e);try{le(e)}catch(e){e instanceof ie||"unwind"==e||v(1,e)}}s.PThread=fe,s.establishStackSpace=function(){var e=rt(),t=a()[e+44>>2>>>0];e=a()[e+48>>2>>>0],ft(t,t-e),dt(t)};var me,ge,he=[];function ye(e){this.Pa=e-24,this.gb=function(e){o()[this.Pa+4>>2>>>0]=e},this.cb=function(e){o()[this.Pa+8>>2>>>0]=e},this.eb=function(){a()[this.Pa>>2>>>0]=0},this.bb=function(){t()[this.Pa+12>>0>>>0]=0},this.fb=function(){t()[this.Pa+13>>0>>>0]=0},this.Ua=function(e,t){this.ab(),this.gb(e),this.cb(t),this.eb(),this.bb(),this.fb()},this.ab=function(){o()[this.Pa+16>>2>>>0]=0}}function ve(e,t,n,r){return O?He(3,1,e,t,n,r):be(e,t,n,r)}function be(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?ve(e,t,n,r):(e={pb:n,Ka:e,ib:r,vb:a},O?(e.wb="spawnThread",postMessage(e,a),0):ue(e))}function we(e,t,n){return O?He(4,1,e,t,n):0}function _e(e,t){if(O)return He(5,1,e,t)}function Oe(e,t){if(O)return He(6,1,e,t)}function Se(e,t,n){if(O)return He(7,1,e,t,n)}function Te(e,t,n){return O?He(8,1,e,t,n):0}function Ae(e,t){if(O)return He(9,1,e,t)}function Ee(e,t,n){if(O)return He(10,1,e,t,n)}function Me(e,t,n,r){if(O)return He(11,1,e,t,n,r)}function Re(e,t,n,r){if(O)return He(12,1,e,t,n,r)}function xe(e,t,n,r){if(O)return He(13,1,e,t,n,r)}function Ce(e){if(O)return He(14,1,e)}function Pe(e,t){if(O)return He(15,1,e,t)}function ke(e,t,n){if(O)return He(16,1,e,t,n)}function De(e){Atomics.store(a(),e>>2,1),rt()&&ut(e),Atomics.compareExchange(a(),e>>2,1,0)}function Fe(e){return o()[e>>>2]+4294967296*a()[e+4>>>2]}function Ue(e,t,n,r,a,o){return O?He(17,1,e,t,n,r,a,o):-52}function Ie(e,t,n,r,a,o){if(O)return He(18,1,e,t,n,r,a,o)}function We(e){var n=N(e)+1,r=at(n);return r&&B(e,t(),r,n),r}function je(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}if(O)return He(19,1,e,t,n);var i=(new Date).getFullYear(),s=new Date(i,0,1),u=new Date(i,6,1);i=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(i,c);a()[e>>2>>>0]=60*l,a()[t>>2>>>0]=Number(i!=c),e=r(s),t=r(u),e=We(e),t=We(t),c<i?(o()[n>>2>>>0]=e,o()[n+4>>2>>>0]=t):(o()[n>>2>>>0]=t,o()[n+4>>2>>>0]=e)}function He(e,t){var n=arguments.length-2,r=arguments;return function(e){var t=pt();return e=e(),dt(t),e}((()=>{for(var a=mt(8*n),o=a>>3,s=0;s<n;s++){var u=r[2+s];i()[o+s>>>0]=u}return st(e,n,a,t)}))}s.invokeEntryPoint=function(e,t){var n=he[e];n||(e>=he.length&&(he.length=e+1),he[e]=n=$.get(e)),e=n(t),C?fe.Ya(e):lt(e)},s.executeNotifiedProxyingQueue=De,ge=_?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:O?()=>performance.now()-s.__performance_now_clock_drift:()=>performance.now();var Le,Ye=[],ze={};function Be(){if(!Le){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:y||"./this.program"};for(e in ze)void 0===ze[e]?delete t[e]:t[e]=ze[e];var n=[];for(e in t)n.push(e+"="+t[e]);Le=n}return Le}function Ne(e,n){if(O)return He(20,1,e,n);var r=0;return Be().forEach((function(a,i){var s=n+r;for(i=o()[e+4*i>>2>>>0]=s,s=0;s<a.length;++s)t()[i++>>0>>>0]=a.charCodeAt(s);t()[i>>0>>>0]=0,r+=a.length+1})),0}function Ge(e,t){if(O)return He(21,1,e,t);var n=Be();o()[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),o()[t>>2>>>0]=r,0}function qe(e){return O?He(22,1,e):52}function $e(e,t,n,r){return O?He(23,1,e,t,n,r):52}function Ve(e,t,n,r,a){return O?He(24,1,e,t,n,r,a):70}var Je=[null,[],[]];function Qe(e,t,n,a){if(O)return He(25,1,e,t,n,a);for(var i=0,s=0;s<n;s++){var u=o()[t>>2>>>0],c=o()[t+4>>2>>>0];t+=8;for(var l=0;l<c;l++){var f=r()[u+l>>>0],p=Je[e];0===f||10===f?((1===e?R:x)(Y(p,0)),p.length=0):p.push(f)}i+=c}return o()[a>>2>>>0]=i,0}function Xe(e){return 0==e%4&&(0!=e%100||0==e%400)}var Ke=[31,29,31,30,31,30,31,31,30,31,30,31],Ze=[31,28,31,30,31,30,31,31,30,31,30,31];function et(e,n,r,o){function i(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function s(e,t){return i(e,t,"0")}function u(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function c(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function l(e){var t=e.Ma;for(e=new Date(new Date(e.Na+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(Xe(e.getFullYear())?Ke:Ze)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=c(new Date(e.getFullYear(),0,4)),n=c(n),0>=u(t,e)?0>=u(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var f=a()[o+40>>2>>>0];for(var p in o={tb:a()[o>>2>>>0],sb:a()[o+4>>2>>>0],Sa:a()[o+8>>2>>>0],Va:a()[o+12>>2>>>0],Ta:a()[o+16>>2>>>0],Na:a()[o+20>>2>>>0],Ja:a()[o+24>>2>>>0],Ma:a()[o+28>>2>>>0],zb:a()[o+32>>2>>>0],rb:a()[o+36>>2>>>0],ub:f?z(f):""},r=z(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),m="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(e){return d[e.Ja].substring(0,3)},"%A":function(e){return d[e.Ja]},"%b":function(e){return m[e.Ta].substring(0,3)},"%B":function(e){return m[e.Ta]},"%C":function(e){return s((e.Na+1900)/100|0,2)},"%d":function(e){return s(e.Va,2)},"%e":function(e){return i(e.Va,2," ")},"%g":function(e){return l(e).toString().substring(2)},"%G":function(e){return l(e)},"%H":function(e){return s(e.Sa,2)},"%I":function(e){return 0==(e=e.Sa)?e=12:12<e&&(e-=12),s(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.Ta-1;t+=(Xe(e.Na+1900)?Ke:Ze)[n++]);return s(e.Va+t,3)},"%m":function(e){return s(e.Ta+1,2)},"%M":function(e){return s(e.sb,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.Sa&&12>e.Sa?"AM":"PM"},"%S":function(e){return s(e.tb,2)},"%t":function(){return"\\t"},"%u":function(e){return e.Ja||7},"%U":function(e){return s(Math.floor((e.Ma+7-e.Ja)/7),2)},"%V":function(e){var t=Math.floor((e.Ma+7-(e.Ja+6)%7)/7);if(2>=(e.Ja+371-e.Ma-2)%7&&t++,t)53==t&&(4==(n=(e.Ja+371-e.Ma)%7)||3==n&&Xe(e.Na)||(t=1));else{t=52;var n=(e.Ja+7-e.Ma-1)%7;(4==n||5==n&&Xe(e.Na%400-1))&&t++}return s(t,2)},"%w":function(e){return e.Ja},"%W":function(e){return s(Math.floor((e.Ma+7-(e.Ja+6)%7)/7),2)},"%y":function(e){return(e.Na+1900).toString().substring(2)},"%Y":function(e){return e.Na+1900},"%z":function(e){var t=0<=(e=e.rb);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.ub},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](o)));return p=function(e){var t=Array(N(e)+1);return B(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(e,n){t().set(e,n>>>0)}(p,e),p.length-1)}fe.Ua();var tt=[null,ce,de,ve,we,_e,Oe,Se,Te,Ae,Ee,Me,Re,xe,Ce,Pe,ke,Ue,Ie,je,Ne,Ge,qe,$e,Ve,Qe],nt={b:function(e){return at(e+24)+24},c:function(e,t,n){throw new ye(e).Ua(t,n),e},L:function(e){ot(e,!w,1,!b),fe.Za()},l:function(e){O?postMessage({cmd:"cleanupThread",thread:e}):se(e)},D:be,i:we,R:_e,z:Oe,B:Se,T:Te,P:Ae,I:Ee,O:Me,p:Re,A:xe,x:Ce,Q:Pe,y:ke,r:function(){},j:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},s:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},q:function(){return Date.now()},E:function(){return 2097152},V:function(){return!0},F:function(e,t,n,r){if(e==t)setTimeout((()=>De(r)));else if(O)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{if(!(e=fe.La[e]))return;e.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},K:function(){return-1},W:function(e,t){e=new Date(1e3*Fe(e)),a()[t>>2>>>0]=e.getUTCSeconds(),a()[t+4>>2>>>0]=e.getUTCMinutes(),a()[t+8>>2>>>0]=e.getUTCHours(),a()[t+12>>2>>>0]=e.getUTCDate(),a()[t+16>>2>>>0]=e.getUTCMonth(),a()[t+20>>2>>>0]=e.getUTCFullYear()-1900,a()[t+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[t+28>>2>>>0]=e},X:function(e,t){e=new Date(1e3*Fe(e)),a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),a()[t+20>>2>>>0]=e.getFullYear()-1900,a()[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1),r=(e.getTime()-n.getTime())/864e5|0;a()[t+28>>2>>>0]=r,a()[t+36>>2>>>0]=-60*e.getTimezoneOffset(),r=new Date(e.getFullYear(),6,1).getTimezoneOffset(),e=0|(r!=(n=n.getTimezoneOffset())&&e.getTimezoneOffset()==Math.min(n,r)),a()[t+32>>2>>>0]=e},Y:function(e){var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),n=a()[e+32>>2>>>0],r=t.getTimezoneOffset(),o=new Date(t.getFullYear(),0,1),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),s=o.getTimezoneOffset(),u=Math.min(s,i);return 0>n?a()[e+32>>2>>>0]=Number(i!=s&&u==r):0<n!=(u==r)&&(i=Math.max(s,i),t.setTime(t.getTime()+6e4*((0<n?u:i)-r))),a()[e+24>>2>>>0]=t.getDay(),n=(t.getTime()-o.getTime())/864e5|0,a()[e+28>>2>>>0]=n,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},G:Ue,H:Ie,Z:function e(t,n,r){e.jb||(e.jb=!0,je(t,n,r))},d:function(){ne("")},m:function(){if(!_&&!w){var e="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";me||(me={}),me[e]||(me[e]=1,_&&(e="warning: "+e),x(e))}},w:function(){return 4294901760},f:ge,S:function(e,t,n){r().copyWithin(e>>>0,t>>>0,t+n>>>0)},g:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},J:function(e,t,n){Ye.length=t,n>>=3;for(var r=0;r<t;r++)Ye[r]=i()[n+r>>>0];return(0>e?oe[-e-1]:tt[e]).apply(null,Ye)},v:function(e){var t=r().length;if((e>>>=0)<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var a=t*(1+.2/n);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a),o=o.min.call(o,4294901760,a+(65536-a%65536)%65536);e:{try{P.grow(o-D.byteLength+65535>>>16),G(P.buffer);var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},U:function(){throw"unwind"},M:Ne,N:Ge,k:le,h:qe,o:$e,t:Ve,n:Qe,u:function e(r,a){e.Wa||(e.Wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(_)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>ne("randomDevice")}());for(var o=0;o<a;o++)t()[r+o>>0>>>0]=e.Wa();return 0},a:P||s.wasmMemory,C:et,e:function(e,t,n,r){return et(e,t,n,r)}};!function(){function e(e,t){s.asm=e.exports,fe.$a.push(s.asm.wa),$=s.asm.za,J.unshift(s.asm._),k=t,O||(Z--,s.monitorRunDependencies&&s.monitorRunDependencies(Z),0==Z&&(null!==ee&&(clearInterval(ee),ee=null),te&&(e=te,te=null,e())))}function t(t){e(t.instance,t.module)}function n(e){return function(){if(!M&&(b||w)){if("function"==typeof fetch&&!K.startsWith("file://"))return fetch(K,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+K+"\'";return e.arrayBuffer()})).catch((function(){return ae()}));if(f)return new Promise((function(e,t){f(K,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return ae()}))}().then((function(e){return WebAssembly.instantiate(e,r)})).then((function(e){return e})).then(e,(function(e){x("failed to asynchronously prepare wasm: "+e),ne(e)}))}var r={a:nt};if(O||(Z++,s.monitorRunDependencies&&s.monitorRunDependencies(Z)),s.instantiateWasm)try{return s.instantiateWasm(r,e)}catch(e){return x("Module.instantiateWasm callback failed with error: "+e),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||re()||K.startsWith("file://")||_||"function"!=typeof fetch?n(t):fetch(K,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,r).then(t,(function(e){return x("wasm streaming compile failed: "+e),x("falling back to ArrayBuffer instantiation"),n(t)}))}))).catch(c)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm._).apply(null,arguments)},s._OrtInit=function(){return(s._OrtInit=s.asm.$).apply(null,arguments)},s._OrtCreateSessionOptions=function(){return(s._OrtCreateSessionOptions=s.asm.aa).apply(null,arguments)},s._OrtAppendExecutionProvider=function(){return(s._OrtAppendExecutionProvider=s.asm.ba).apply(null,arguments)},s._OrtAddSessionConfigEntry=function(){return(s._OrtAddSessionConfigEntry=s.asm.ca).apply(null,arguments)},s._OrtReleaseSessionOptions=function(){return(s._OrtReleaseSessionOptions=s.asm.da).apply(null,arguments)},s._OrtCreateSession=function(){return(s._OrtCreateSession=s.asm.ea).apply(null,arguments)},s._OrtReleaseSession=function(){return(s._OrtReleaseSession=s.asm.fa).apply(null,arguments)},s._OrtGetInputCount=function(){return(s._OrtGetInputCount=s.asm.ga).apply(null,arguments)},s._OrtGetOutputCount=function(){return(s._OrtGetOutputCount=s.asm.ha).apply(null,arguments)},s._OrtGetInputName=function(){return(s._OrtGetInputName=s.asm.ia).apply(null,arguments)},s._OrtGetOutputName=function(){return(s._OrtGetOutputName=s.asm.ja).apply(null,arguments)},s._OrtFree=function(){return(s._OrtFree=s.asm.ka).apply(null,arguments)},s._OrtCreateTensor=function(){return(s._OrtCreateTensor=s.asm.la).apply(null,arguments)},s._OrtGetTensorData=function(){return(s._OrtGetTensorData=s.asm.ma).apply(null,arguments)},s._OrtReleaseTensor=function(){return(s._OrtReleaseTensor=s.asm.na).apply(null,arguments)},s._OrtCreateRunOptions=function(){return(s._OrtCreateRunOptions=s.asm.oa).apply(null,arguments)},s._OrtAddRunConfigEntry=function(){return(s._OrtAddRunConfigEntry=s.asm.pa).apply(null,arguments)},s._OrtReleaseRunOptions=function(){return(s._OrtReleaseRunOptions=s.asm.qa).apply(null,arguments)},s._OrtRun=function(){return(s._OrtRun=s.asm.ra).apply(null,arguments)},s._OrtEndProfiling=function(){return(s._OrtEndProfiling=s.asm.sa).apply(null,arguments)};var rt=s._pthread_self=function(){return(rt=s._pthread_self=s.asm.ta).apply(null,arguments)},at=s._malloc=function(){return(at=s._malloc=s.asm.ua).apply(null,arguments)};s._free=function(){return(s._free=s.asm.va).apply(null,arguments)},s.__emscripten_tls_init=function(){return(s.__emscripten_tls_init=s.asm.wa).apply(null,arguments)};var ot=s.__emscripten_thread_init=function(){return(ot=s.__emscripten_thread_init=s.asm.xa).apply(null,arguments)};s.__emscripten_thread_crashed=function(){return(s.__emscripten_thread_crashed=s.asm.ya).apply(null,arguments)};var it,st=s._emscripten_run_in_main_runtime_thread_js=function(){return(st=s._emscripten_run_in_main_runtime_thread_js=s.asm.Aa).apply(null,arguments)},ut=s.__emscripten_proxy_execute_task_queue=function(){return(ut=s.__emscripten_proxy_execute_task_queue=s.asm.Ba).apply(null,arguments)},ct=s.__emscripten_thread_free_data=function(){return(ct=s.__emscripten_thread_free_data=s.asm.Ca).apply(null,arguments)},lt=s.__emscripten_thread_exit=function(){return(lt=s.__emscripten_thread_exit=s.asm.Da).apply(null,arguments)},ft=s._emscripten_stack_set_limits=function(){return(ft=s._emscripten_stack_set_limits=s.asm.Ea).apply(null,arguments)},pt=s.stackSave=function(){return(pt=s.stackSave=s.asm.Fa).apply(null,arguments)},dt=s.stackRestore=function(){return(dt=s.stackRestore=s.asm.Ga).apply(null,arguments)},mt=s.stackAlloc=function(){return(mt=s.stackAlloc=s.asm.Ha).apply(null,arguments)};function gt(){function e(){if(!it&&(it=!0,s.calledRun=!0,!H)&&(O||pe(J),u(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),!O)){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;){var e=s.postRun.shift();Q.unshift(e)}pe(Q)}}if(!(0<Z))if(O)u(s),O||pe(J),postMessage({cmd:"loaded"});else{if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)X();pe(V),0<Z||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),e()}),1)):e())}}if(s.___cxa_is_pointer_type=function(){return(s.___cxa_is_pointer_type=s.asm.Ia).apply(null,arguments)},s.UTF8ToString=z,s.stringToUTF8=function(e,t,n){return B(e,r(),t,n)},s.lengthBytesUTF8=N,s.keepRuntimeAlive=function(){return C},s.wasmMemory=P,s.stackSave=pt,s.stackRestore=dt,s.stackAlloc=mt,s.ExitStatus=ie,s.PThread=fe,te=function e(){it||gt(),it||(te=e)},s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return gt(),e.ready});e.exports=r},932:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){var t,r,a;e=e||{},t||(t=void 0!==e?e:{}),t.ready=new Promise((function(e,t){r=e,a=t}));var o,i,s,u,c,l,f=Object.assign({},t),p="./this.program",d=(e,t)=>{throw t},m="object"==typeof window,g="function"==typeof importScripts,h="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,y="";h?(y=g?n(908).dirname(y)+"/":"//",l=()=>{c||(u=n(384),c=n(908))},o=function(e,t){return l(),e=c.normalize(e),u.readFileSync(e,t?void 0:"utf8")},s=e=>((e=o(e,!0)).buffer||(e=new Uint8Array(e)),e),i=(e,t,n)=>{l(),e=c.normalize(e),u.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof $))throw e})),process.on("unhandledRejection",(function(e){throw e})),d=(e,t)=>{if(_)throw process.exitCode=e,t;t instanceof $||w("exiting due to exception: "+t),process.exit(e)},t.inspect=function(){return"[Emscripten Module object]"}):(m||g)&&(g?y=self.location.href:"undefined"!=typeof document&&document.currentScript&&(y=document.currentScript.src),_scriptDir&&(y=_scriptDir),y=0!==y.indexOf("blob:")?y.substr(0,y.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},g&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),i=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var v,b=t.print||console.log.bind(console),w=t.printErr||console.warn.bind(console);Object.assign(t,f),f=null,t.thisProgram&&(p=t.thisProgram),t.quit&&(d=t.quit),t.wasmBinary&&(v=t.wasmBinary);var _=t.noExitRuntime||!0;"object"!=typeof WebAssembly&&B("no native wasm support detected");var O,S,T,A,E,M,R=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function C(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&x)return x.decode(e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function P(e,t){return(e>>>=0)?C(A,e,t):""}function k(e,t,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-a}function D(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function F(){var e=O.buffer;S=e,t.HEAP8=T=new Int8Array(e),t.HEAP16=new Int16Array(e),t.HEAP32=E=new Int32Array(e),t.HEAPU8=A=new Uint8Array(e),t.HEAPU16=new Uint16Array(e),t.HEAPU32=M=new Uint32Array(e),t.HEAPF32=new Float32Array(e),t.HEAPF64=new Float64Array(e)}var U=[],I=[],W=[];function j(){var e=t.preRun.shift();U.unshift(e)}var H,L=0,Y=null,z=null;function B(e){throw t.onAbort&&t.onAbort(e),w(e="Aborted("+e+")"),R=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),a(e),e}function N(){return H.startsWith("data:application/octet-stream;base64,")}if(H="ort-wasm.wasm",!N()){var G=H;H=t.locateFile?t.locateFile(G,y):y+G}function q(){var e=H;try{if(e==H&&v)return new Uint8Array(v);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}catch(e){B(e)}}function $(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function V(e){for(;0<e.length;)e.shift()(t)}function J(e){this.sa=e-24,this.Ia=function(e){M[this.sa+4>>2>>>0]=e},this.Ba=function(e){M[this.sa+8>>2>>>0]=e},this.Ga=function(){E[this.sa>>2>>>0]=0},this.Aa=function(){T[this.sa+12>>0>>>0]=0},this.Ha=function(){T[this.sa+13>>0>>>0]=0},this.ya=function(e,t){this.za(),this.Ia(e),this.Ba(t),this.Ga(),this.Aa(),this.Ha()},this.za=function(){M[this.sa+16>>2>>>0]=0}}function Q(e){var t=D(e)+1,n=ie(t);return n&&k(e,T,n,t),n}var X={};function K(){if(!Z){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(e in X)void 0===X[e]?delete t[e]:t[e]=X[e];var n=[];for(e in t)n.push(e+"="+t[e]);Z=n}return Z}var Z,ee=[null,[],[]];function te(e){return 0==e%4&&(0!=e%100||0==e%400)}var ne=[31,29,31,30,31,30,31,31,30,31,30,31],re=[31,28,31,30,31,30,31,31,30,31,30,31];function ae(e,t,n,r){function a(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function o(e,t){return a(e,t,"0")}function i(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.qa;for(e=new Date(new Date(e.ra+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(te(e.getFullYear())?ne:re)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),n=s(n),0>=i(t,e)?0>=i(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var c=E[r+40>>2>>>0];for(var l in r={Ea:E[r>>2>>>0],Da:E[r+4>>2>>>0],ta:E[r+8>>2>>>0],va:E[r+12>>2>>>0],ua:E[r+16>>2>>>0],ra:E[r+20>>2>>>0],la:E[r+24>>2>>>0],qa:E[r+28>>2>>>0],Ja:E[r+32>>2>>>0],Ca:E[r+36>>2>>>0],Fa:c?P(c):""},n=P(n),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),c[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in c={"%a":function(e){return f[e.la].substring(0,3)},"%A":function(e){return f[e.la]},"%b":function(e){return p[e.ua].substring(0,3)},"%B":function(e){return p[e.ua]},"%C":function(e){return o((e.ra+1900)/100|0,2)},"%d":function(e){return o(e.va,2)},"%e":function(e){return a(e.va,2," ")},"%g":function(e){return u(e).toString().substring(2)},"%G":function(e){return u(e)},"%H":function(e){return o(e.ta,2)},"%I":function(e){return 0==(e=e.ta)?e=12:12<e&&(e-=12),o(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.ua-1;t+=(te(e.ra+1900)?ne:re)[n++]);return o(e.va+t,3)},"%m":function(e){return o(e.ua+1,2)},"%M":function(e){return o(e.Da,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.ta&&12>e.ta?"AM":"PM"},"%S":function(e){return o(e.Ea,2)},"%t":function(){return"\\t"},"%u":function(e){return e.la||7},"%U":function(e){return o(Math.floor((e.qa+7-e.la)/7),2)},"%V":function(e){var t=Math.floor((e.qa+7-(e.la+6)%7)/7);if(2>=(e.la+371-e.qa-2)%7&&t++,t)53==t&&(4==(n=(e.la+371-e.qa)%7)||3==n&&te(e.ra)||(t=1));else{t=52;var n=(e.la+7-e.qa-1)%7;(4==n||5==n&&te(e.ra%400-1))&&t++}return o(t,2)},"%w":function(e){return e.la},"%W":function(e){return o(Math.floor((e.qa+7-(e.la+6)%7)/7),2)},"%y":function(e){return(e.ra+1900).toString().substring(2)},"%Y":function(e){return e.ra+1900},"%z":function(e){var t=0<=(e=e.Ca);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.Fa},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),c)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),c[l](r)));return l=function(e){var t=Array(D(e)+1);return k(e,t,0,t.length),t}(n=n.replace(/\\0\\0/g,"%")),l.length>t?0:(T.set(l,e>>>0),l.length-1)}var oe={a:function(e){return ie(e+24)+24},b:function(e,t,n){throw new J(e).ya(t,n),e},g:function(){return 0},I:function(){},w:function(){},y:function(){},K:function(){return 0},G:function(){},C:function(){},F:function(){},k:function(){},x:function(){},u:function(){},H:function(){},v:function(){},n:function(){},p:function(){B("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},o:function(){B("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},l:function(){return Date.now()},L:function(){return!0},M:function(e,t){e=new Date(1e3*(M[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getUTCSeconds(),E[t+4>>2>>>0]=e.getUTCMinutes(),E[t+8>>2>>>0]=e.getUTCHours(),E[t+12>>2>>>0]=e.getUTCDate(),E[t+16>>2>>>0]=e.getUTCMonth(),E[t+20>>2>>>0]=e.getUTCFullYear()-1900,E[t+24>>2>>>0]=e.getUTCDay(),E[t+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},N:function(e,t){e=new Date(1e3*(M[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),E[t+20>>2>>>0]=e.getFullYear()-1900,E[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1);E[t+28>>2>>>0]=(e.getTime()-n.getTime())/864e5|0,E[t+36>>2>>>0]=-60*e.getTimezoneOffset();var r=new Date(e.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[t+32>>2>>>0]=0|(r!=n&&e.getTimezoneOffset()==Math.min(n,r))},O:function(e){var t=new Date(E[e+20>>2>>>0]+1900,E[e+16>>2>>>0],E[e+12>>2>>>0],E[e+8>>2>>>0],E[e+4>>2>>>0],E[e>>2>>>0],0),n=E[e+32>>2>>>0],r=t.getTimezoneOffset(),a=new Date(t.getFullYear(),0,1),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=a.getTimezoneOffset(),s=Math.min(i,o);return 0>n?E[e+32>>2>>>0]=Number(o!=i&&s==r):0<n!=(s==r)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<n?s:o)-r))),E[e+24>>2>>>0]=t.getDay(),E[e+28>>2>>>0]=(t.getTime()-a.getTime())/864e5|0,E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},z:function(){return-52},B:function(){},m:function e(t,n,r){e.xa||(e.xa=!0,function(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();E[e>>2>>>0]=60*Math.max(a,s),E[t>>2>>>0]=Number(a!=s),e=r(o),t=r(i),e=Q(e),t=Q(t),s<a?(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t):(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e)}(t,n,r))},d:function(){B("")},t:function(){return 4294901760},h:h?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.now(),J:function(e,t,n){A.copyWithin(e>>>0,t>>>0,t+n>>>0)},f:function(e){var t=A.length;if(4294901760<(e>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var a=Math;r=Math.max(e,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);e:{try{O.grow(a-S.byteLength+65535>>>16),F();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},D:function(e,t){var n=0;return K().forEach((function(r,a){var o=t+n;for(a=M[e+4*a>>2>>>0]=o,o=0;o<r.length;++o)T[a++>>0>>>0]=r.charCodeAt(o);T[a>>0>>>0]=0,n+=r.length+1})),0},E:function(e,t){var n=K();M[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),M[t>>2>>>0]=r,0},r:function(e){_||(t.onExit&&t.onExit(e),R=!0),d(e,new $(e))},e:function(){return 52},j:function(){return 52},q:function(){return 70},i:function(e,t,n,r){for(var a=0,o=0;o<n;o++){var i=M[t>>2>>>0],s=M[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var c=A[i+u>>>0],l=ee[e];0===c||10===c?((1===e?b:w)(C(l,0)),l.length=0):l.push(c)}a+=s}return M[r>>2>>>0]=a,0},s:function e(t,r){e.wa||(e.wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(h)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>B("randomDevice")}());for(var a=0;a<r;a++)T[t+a>>0>>>0]=e.wa();return 0},A:ae,c:function(e,t,n,r){return ae(e,t,n,r)}};!function(){function e(e){t.asm=e.exports,O=t.asm.P,F(),I.unshift(t.asm.Q),L--,t.monitorRunDependencies&&t.monitorRunDependencies(L),0==L&&(null!==Y&&(clearInterval(Y),Y=null),z&&(e=z,z=null,e()))}function n(t){e(t.instance)}function r(e){return function(){if(!v&&(m||g)){if("function"==typeof fetch&&!H.startsWith("file://"))return fetch(H,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+H+"\'";return e.arrayBuffer()})).catch((function(){return q()}));if(i)return new Promise((function(e,t){i(H,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return q()}))}().then((function(e){return WebAssembly.instantiate(e,o)})).then((function(e){return e})).then(e,(function(e){w("failed to asynchronously prepare wasm: "+e),B(e)}))}var o={a:oe};if(L++,t.monitorRunDependencies&&t.monitorRunDependencies(L),t.instantiateWasm)try{return t.instantiateWasm(o,e)}catch(e){return w("Module.instantiateWasm callback failed with error: "+e),!1}(v||"function"!=typeof WebAssembly.instantiateStreaming||N()||H.startsWith("file://")||h||"function"!=typeof fetch?r(n):fetch(H,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,o).then(n,(function(e){return w("wasm streaming compile failed: "+e),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),t.___wasm_call_ctors=function(){return(t.___wasm_call_ctors=t.asm.Q).apply(null,arguments)},t._OrtInit=function(){return(t._OrtInit=t.asm.R).apply(null,arguments)},t._OrtCreateSessionOptions=function(){return(t._OrtCreateSessionOptions=t.asm.S).apply(null,arguments)},t._OrtAppendExecutionProvider=function(){return(t._OrtAppendExecutionProvider=t.asm.T).apply(null,arguments)},t._OrtAddSessionConfigEntry=function(){return(t._OrtAddSessionConfigEntry=t.asm.U).apply(null,arguments)},t._OrtReleaseSessionOptions=function(){return(t._OrtReleaseSessionOptions=t.asm.V).apply(null,arguments)},t._OrtCreateSession=function(){return(t._OrtCreateSession=t.asm.W).apply(null,arguments)},t._OrtReleaseSession=function(){return(t._OrtReleaseSession=t.asm.X).apply(null,arguments)},t._OrtGetInputCount=function(){return(t._OrtGetInputCount=t.asm.Y).apply(null,arguments)},t._OrtGetOutputCount=function(){return(t._OrtGetOutputCount=t.asm.Z).apply(null,arguments)},t._OrtGetInputName=function(){return(t._OrtGetInputName=t.asm._).apply(null,arguments)},t._OrtGetOutputName=function(){return(t._OrtGetOutputName=t.asm.$).apply(null,arguments)},t._OrtFree=function(){return(t._OrtFree=t.asm.aa).apply(null,arguments)},t._OrtCreateTensor=function(){return(t._OrtCreateTensor=t.asm.ba).apply(null,arguments)},t._OrtGetTensorData=function(){return(t._OrtGetTensorData=t.asm.ca).apply(null,arguments)},t._OrtReleaseTensor=function(){return(t._OrtReleaseTensor=t.asm.da).apply(null,arguments)},t._OrtCreateRunOptions=function(){return(t._OrtCreateRunOptions=t.asm.ea).apply(null,arguments)},t._OrtAddRunConfigEntry=function(){return(t._OrtAddRunConfigEntry=t.asm.fa).apply(null,arguments)},t._OrtReleaseRunOptions=function(){return(t._OrtReleaseRunOptions=t.asm.ga).apply(null,arguments)},t._OrtRun=function(){return(t._OrtRun=t.asm.ha).apply(null,arguments)},t._OrtEndProfiling=function(){return(t._OrtEndProfiling=t.asm.ia).apply(null,arguments)};var ie=t._malloc=function(){return(ie=t._malloc=t.asm.ja).apply(null,arguments)};t._free=function(){return(t._free=t.asm.ka).apply(null,arguments)};var se,ue=t.stackSave=function(){return(ue=t.stackSave=t.asm.ma).apply(null,arguments)},ce=t.stackRestore=function(){return(ce=t.stackRestore=t.asm.na).apply(null,arguments)},le=t.stackAlloc=function(){return(le=t.stackAlloc=t.asm.oa).apply(null,arguments)};function fe(){function e(){if(!se&&(se=!0,t.calledRun=!0,!R)){if(V(I),r(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),t.postRun)for("function"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;){var e=t.postRun.shift();W.unshift(e)}V(W)}}if(!(0<L)){if(t.preRun)for("function"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)j();V(U),0<L||(t.setStatus?(t.setStatus("Running..."),setTimeout((function(){setTimeout((function(){t.setStatus("")}),1),e()}),1)):e())}}if(t.___cxa_is_pointer_type=function(){return(t.___cxa_is_pointer_type=t.asm.pa).apply(null,arguments)},t.UTF8ToString=P,t.stringToUTF8=function(e,t,n){return k(e,A,t,n)},t.lengthBytesUTF8=D,t.stackSave=ue,t.stackRestore=ce,t.stackAlloc=le,z=function e(){se||fe(),se||(z=e)},t.preInit)for("function"==typeof t.preInit&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return fe(),e.ready});e.exports=r},154:e=>{"use strict";e.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},760:()=>{},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var o=t[r]={exports:{}};return e[r].call(o.exports,o,o.exports,n),o.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),(()=>{"use strict";const e=n(259),t=n(263);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,t.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(e=>postMessage({type:"init-wasm",err:e})));break;case"init-ort":try{const{numThreads:t,loggingLevel:r}=n.data.in;(0,e.initOrt)(t,r),postMessage({type:"init-ort"})}catch(e){postMessage({type:"init-ort",err:e})}break;case"create_allocate":try{const{model:t}=n.data.in,r=(0,e.createSessionAllocate)(t);postMessage({type:"create_allocate",out:r})}catch(e){postMessage({type:"create_allocate",err:e})}break;case"create_finalize":try{const{modeldata:t,options:r}=n.data.in,a=(0,e.createSessionFinalize)(t,r);postMessage({type:"create_finalize",out:a})}catch(e){postMessage({type:"create_finalize",err:e})}break;case"create":try{const{model:t,options:r}=n.data.in,a=(0,e.createSession)(t,r);postMessage({type:"create",out:a})}catch(e){postMessage({type:"create",err:e})}break;case"release":try{const t=n.data.in;(0,e.releaseSession)(t),postMessage({type:"release"})}catch(e){postMessage({type:"release",err:e})}break;case"run":try{const{sessionId:t,inputIndices:r,inputs:a,outputIndices:o,options:i}=n.data.in;(0,e.run)(t,r,a,o,i).then((t=>{postMessage({type:"run",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:"run",err:e})}))}catch(e){postMessage({type:"run",err:e})}break;case"end-profiling":try{const t=n.data.in;(0,e.endProfiling)(t),postMessage({type:"end-profiling"})}catch(e){postMessage({type:"end-profiling",err:e})}}}})()})();\n',"Worker",void 0,void 0)}},6614:o=>{o.exports=function(t,e,n,a){var l=self||window;try{try{var c;try{c=new l.Blob([t])}catch{(c=new(l.BlobBuilder||l.WebKitBlobBuilder||l.MozBlobBuilder||l.MSBlobBuilder)).append(t),c=c.getBlob()}var f=l.URL||l.webkitURL,g=f.createObjectURL(c),h=new l[e](g,n);return f.revokeObjectURL(g),h}catch{return new l[e]("data:application/javascript,".concat(encodeURIComponent(t)),n)}}catch{if(!a)throw Error("Inline worker is not supported");return new l[e](a,n)}}},3474:(o,t,e)=>{var n,a=(n=(n=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(l){function c(){return G.buffer!=Z&&pt(G.buffer),at}function f(){return G.buffer!=Z&&pt(G.buffer),J}function g(){return G.buffer!=Z&&pt(G.buffer),Y}function h(){return G.buffer!=Z&&pt(G.buffer),K}function p(){return G.buffer!=Z&&pt(G.buffer),it}var s,r,u;l=l||{},s||(s=l!==void 0?l:{}),s.ready=new Promise(function(P,N){r=P,u=N});var d,m,b,y,w,x,_=Object.assign({},s),v="./this.program",E=(P,N)=>{throw N},I=typeof window=="object",S=typeof importScripts=="function",T=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",A=s.ENVIRONMENT_IS_PTHREAD||!1,O="";function $(P){return s.locateFile?s.locateFile(P,O):O+P}if(T){let P;O=S?e(908).dirname(O)+"/":"//",x=()=>{w||(y=e(1384),w=e(908))},d=function(N,U){return x(),N=w.normalize(N),y.readFileSync(N,U?void 0:"utf8")},b=N=>((N=d(N,!0)).buffer||(N=new Uint8Array(N)),N),m=(N,U,X)=>{x(),N=w.normalize(N),y.readFile(N,function(dt,At){dt?X(dt):U(At.buffer)})},1<process.argv.length&&(v=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(N){if(!(N instanceof vt))throw N}),process.on("unhandledRejection",function(N){throw N}),E=(N,U)=>{if(j)throw process.exitCode=N,U;U instanceof vt||R("exiting due to exception: "+U),process.exit(N)},s.inspect=function(){return"[Emscripten Module object]"};try{P=e(9925)}catch(N){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),N}e.g.Worker=P.Worker}else(I||S)&&(S?O=self.location.href:typeof document<"u"&&document.currentScript&&(O=document.currentScript.src),n&&(O=n),O=O.indexOf("blob:")!==0?O.substr(0,O.replace(/[?#].*/,"").lastIndexOf("/")+1):"",T||(d=P=>{var N=new XMLHttpRequest;return N.open("GET",P,!1),N.send(null),N.responseText},S&&(b=P=>{var N=new XMLHttpRequest;return N.open("GET",P,!1),N.responseType="arraybuffer",N.send(null),new Uint8Array(N.response)}),m=(P,N,U)=>{var X=new XMLHttpRequest;X.open("GET",P,!0),X.responseType="arraybuffer",X.onload=()=>{X.status==200||X.status==0&&X.response?N(X.response):U()},X.onerror=U,X.send(null)}));T&&typeof performance>"u"&&(e.g.performance=e(6953).performance);var D=console.log.bind(console),M=console.warn.bind(console);T&&(x(),D=P=>y.writeSync(1,P+`
`),M=P=>y.writeSync(2,P+`
`));var F,C=s.print||D,R=s.printErr||M;Object.assign(s,_),_=null,s.thisProgram&&(v=s.thisProgram),s.quit&&(E=s.quit),s.wasmBinary&&(F=s.wasmBinary);var j=s.noExitRuntime||!0;typeof WebAssembly!="object"&&et("no native wasm support detected");var G,W,Z,at,J,Y,K,it,rt=!1,yt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function ut(P,N,U){var X=(N>>>=0)+U;for(U=N;P[U]&&!(U>=X);)++U;if(16<U-N&&P.buffer&&yt)return yt.decode(P.buffer instanceof SharedArrayBuffer?P.slice(N,U):P.subarray(N,U));for(X="";N<U;){var dt=P[N++];if(128&dt){var At=63&P[N++];if((224&dt)==192)X+=String.fromCharCode((31&dt)<<6|At);else{var Nt=63&P[N++];65536>(dt=(240&dt)==224?(15&dt)<<12|At<<6|Nt:(7&dt)<<18|At<<12|Nt<<6|63&P[N++])?X+=String.fromCharCode(dt):(dt-=65536,X+=String.fromCharCode(55296|dt>>10,56320|1023&dt))}}else X+=String.fromCharCode(dt)}return X}function St(P,N){return(P>>>=0)?ut(f(),P,N):""}function gt(P,N,U,X){if(!(0<X))return 0;var dt=U>>>=0;X=U+X-1;for(var At=0;At<P.length;++At){var Nt=P.charCodeAt(At);if(55296<=Nt&&57343>=Nt&&(Nt=65536+((1023&Nt)<<10)|1023&P.charCodeAt(++At)),127>=Nt){if(U>=X)break;N[U++>>>0]=Nt}else{if(2047>=Nt){if(U+1>=X)break;N[U++>>>0]=192|Nt>>6}else{if(65535>=Nt){if(U+2>=X)break;N[U++>>>0]=224|Nt>>12}else{if(U+3>=X)break;N[U++>>>0]=240|Nt>>18,N[U++>>>0]=128|Nt>>12&63}N[U++>>>0]=128|Nt>>6&63}N[U++>>>0]=128|63&Nt}}return N[U>>>0]=0,U-dt}function Ot(P){for(var N=0,U=0;U<P.length;++U){var X=P.charCodeAt(U);127>=X?N++:2047>=X?N+=2:55296<=X&&57343>=X?(N+=4,++U):N+=3}return N}function pt(P){Z=P,s.HEAP8=at=new Int8Array(P),s.HEAP16=new Int16Array(P),s.HEAP32=Y=new Int32Array(P),s.HEAPU8=J=new Uint8Array(P),s.HEAPU16=new Uint16Array(P),s.HEAPU32=K=new Uint32Array(P),s.HEAPF32=new Float32Array(P),s.HEAPF64=it=new Float64Array(P)}A&&(Z=s.buffer);var ct=s.INITIAL_MEMORY||16777216;if(A)G=s.wasmMemory,Z=s.buffer;else if(s.wasmMemory)G=s.wasmMemory;else if(!((G=new WebAssembly.Memory({initial:ct/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw R("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),T&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");G&&(Z=G.buffer),ct=Z.byteLength,pt(Z);var ot,Mt=[],It=[],Dt=[];function H(){var P=s.preRun.shift();Mt.unshift(P)}var ft,xt=0,_t=null;function et(P){throw A?postMessage({cmd:"onAbort",arg:P}):s.onAbort&&s.onAbort(P),R(P="Aborted("+P+")"),rt=!0,P=new WebAssembly.RuntimeError(P+". Build with -sASSERTIONS for more info."),u(P),P}function Ct(){return ft.startsWith("data:application/octet-stream;base64,")}function Pt(){var P=ft;try{if(P==ft&&F)return new Uint8Array(F);if(b)return b(P);throw"both async and sync fetching of the wasm failed"}catch(N){et(N)}}ft="ort-wasm-threaded.wasm",Ct()||(ft=$(ft));var mt={};function vt(P){this.name="ExitStatus",this.message="Program terminated with exit("+P+")",this.status=P}function $t(P){(P=lt.La[P])||et(),lt.Xa(P)}function Tt(P){var N=lt.lb();if(!N)return 6;lt.Ra.push(N),lt.La[P.Ka]=N,N.Ka=P.Ka;var U={cmd:"run",start_routine:P.pb,arg:P.ib,pthread_ptr:P.Ka};return N.Qa=()=>{U.time=performance.now(),N.postMessage(U,P.vb)},N.loaded&&(N.Qa(),delete N.Qa),0}function kt(P){if(A)return Bt(1,1,P);j||(lt.qb(),s.onExit&&s.onExit(P),rt=!0),E(P,new vt(P))}function Rt(P,N){if(!N&&A)throw z(P),"unwind";kt(P)}var lt={Oa:[],Ra:[],$a:[],La:{},Ua:function(){A&&lt.mb()},xb:function(){},mb:function(){lt.receiveObjectTransfer=lt.ob,lt.threadInitTLS=lt.Za,lt.setExitStatus=lt.Ya,j=!1},Ya:function(){},qb:function(){for(var P of Object.values(lt.La))lt.Xa(P);for(P of lt.Oa)P.terminate();lt.Oa=[]},Xa:function(P){var N=P.Ka;delete lt.La[N],lt.Oa.push(P),lt.Ra.splice(lt.Ra.indexOf(P),1),P.Ka=0,ve(N)},ob:function(){},Za:function(){lt.$a.forEach(P=>P())},nb:function(P,N){P.onmessage=U=>{var X=(U=U.data).cmd;if(P.Ka&&(lt.kb=P.Ka),U.targetThread&&U.targetThread!=be()){var dt=lt.La[U.yb];dt?dt.postMessage(U,U.transferList):R('Internal error! Worker sent a message "'+X+'" to target pthread '+U.targetThread+", but that thread no longer exists!")}else X==="processProxyingQueue"?Ut(U.queue):X==="spawnThread"?Tt(U):X==="cleanupThread"?$t(U.thread):X==="killThread"?(U=U.thread,X=lt.La[U],delete lt.La[U],X.terminate(),ve(U),lt.Ra.splice(lt.Ra.indexOf(X),1),X.Ka=0):X==="cancelThread"?lt.La[U.thread].postMessage({cmd:"cancel"}):X==="loaded"?(P.loaded=!0,N&&N(P),P.Qa&&(P.Qa(),delete P.Qa)):X==="print"?C("Thread "+U.threadId+": "+U.text):X==="printErr"?R("Thread "+U.threadId+": "+U.text):X==="alert"?alert("Thread "+U.threadId+": "+U.text):U.target==="setimmediate"?P.postMessage(U):X==="onAbort"?s.onAbort&&s.onAbort(U.arg):X&&R("worker sent an unknown command "+X);lt.kb=void 0},P.onerror=U=>{throw R("worker sent an error! "+U.filename+":"+U.lineno+": "+U.message),U},T&&(P.on("message",function(U){P.onmessage({data:U})}),P.on("error",function(U){P.onerror(U)}),P.on("detachedExit",function(){})),P.postMessage({cmd:"load",urlOrBlob:s.mainScriptUrlOrBlob||n,wasmMemory:G,wasmModule:W})},hb:function(){var P=$("ort-wasm-threaded.worker.js");lt.Oa.push(new Worker(P))},lb:function(){return lt.Oa.length==0&&(lt.hb(),lt.nb(lt.Oa[0])),lt.Oa.pop()}};function B(P){for(;0<P.length;)P.shift()(s)}function z(P){if(A)return Bt(2,0,P);try{Rt(P)}catch(N){N instanceof vt||N=="unwind"||E(1,N)}}s.PThread=lt,s.establishStackSpace=function(){var P=be(),N=g()[P+44>>2>>>0];P=g()[P+48>>2>>>0],ke(N,N-P),we(N)};var Q,st,ht=[];function bt(P){this.Pa=P-24,this.gb=function(N){h()[this.Pa+4>>2>>>0]=N},this.cb=function(N){h()[this.Pa+8>>2>>>0]=N},this.eb=function(){g()[this.Pa>>2>>>0]=0},this.bb=function(){c()[this.Pa+12>>0>>>0]=0},this.fb=function(){c()[this.Pa+13>>0>>>0]=0},this.Ua=function(N,U){this.ab(),this.gb(N),this.cb(U),this.eb(),this.bb(),this.fb()},this.ab=function(){h()[this.Pa+16>>2>>>0]=0}}function Ft(P,N,U,X){return A?Bt(3,1,P,N,U,X):Ht(P,N,U,X)}function Ht(P,N,U,X){if(typeof SharedArrayBuffer>"u")return R("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var dt=[];return A&&dt.length===0?Ft(P,N,U,X):(P={pb:U,Ka:P,ib:X,vb:dt},A?(P.wb="spawnThread",postMessage(P,dt),0):Tt(P))}function zt(P,N,U){return A?Bt(4,1,P,N,U):0}function Vt(P,N){if(A)return Bt(5,1,P,N)}function jt(P,N){if(A)return Bt(6,1,P,N)}function Xt(P,N,U){if(A)return Bt(7,1,P,N,U)}function Jt(P,N,U){return A?Bt(8,1,P,N,U):0}function q(P,N){if(A)return Bt(9,1,P,N)}function k(P,N,U){if(A)return Bt(10,1,P,N,U)}function L(P,N,U,X){if(A)return Bt(11,1,P,N,U,X)}function V(P,N,U,X){if(A)return Bt(12,1,P,N,U,X)}function nt(P,N,U,X){if(A)return Bt(13,1,P,N,U,X)}function wt(P){if(A)return Bt(14,1,P)}function Et(P,N){if(A)return Bt(15,1,P,N)}function Gt(P,N,U){if(A)return Bt(16,1,P,N,U)}function Ut(P){Atomics.store(g(),P>>2,1),be()&&De(P),Atomics.compareExchange(g(),P>>2,1,0)}function Yt(P){return h()[P>>>2]+4294967296*g()[P+4>>>2]}function Zt(P,N,U,X,dt,At){return A?Bt(17,1,P,N,U,X,dt,At):-52}function se(P,N,U,X,dt,At){if(A)return Bt(18,1,P,N,U,X,dt,At)}function qt(P){var N=Ot(P)+1,U=_e(N);return U&&gt(P,c(),U,N),U}function oe(P,N,U){function X(ee){return(ee=ee.toTimeString().match(/\(([A-Za-z ]+)\)$/))?ee[1]:"GMT"}if(A)return Bt(19,1,P,N,U);var dt=new Date().getFullYear(),At=new Date(dt,0,1),Nt=new Date(dt,6,1);dt=At.getTimezoneOffset();var Qt=Nt.getTimezoneOffset(),le=Math.max(dt,Qt);g()[P>>2>>>0]=60*le,g()[N>>2>>>0]=+(dt!=Qt),P=X(At),N=X(Nt),P=qt(P),N=qt(N),Qt<dt?(h()[U>>2>>>0]=P,h()[U+4>>2>>>0]=N):(h()[U>>2>>>0]=N,h()[U+4>>2>>>0]=P)}function Bt(P,N){var U=arguments.length-2,X=arguments;return function(dt){var At=Te();return dt=dt(),we(At),dt}(()=>{for(var dt=Se(8*U),At=dt>>3,Nt=0;Nt<U;Nt++){var Qt=X[2+Nt];p()[At+Nt>>>0]=Qt}return $e(P,U,dt,N)})}s.invokeEntryPoint=function(P,N){var U=ht[P];U||(P>=ht.length&&(ht.length=P+1),ht[P]=U=ot.get(P)),P=U(N),j?lt.Ya(P):Me(P)},s.executeNotifiedProxyingQueue=Ut,st=T?()=>{var P=process.hrtime();return 1e3*P[0]+P[1]/1e6}:A?()=>performance.now()-s.__performance_now_clock_drift:()=>performance.now();var te,Kt=[],re={};function ae(){if(!te){var P,N={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:v||"./this.program"};for(P in re)re[P]===void 0?delete N[P]:N[P]=re[P];var U=[];for(P in N)U.push(P+"="+N[P]);te=U}return te}function ie(P,N){if(A)return Bt(20,1,P,N);var U=0;return ae().forEach(function(X,dt){var At=N+U;for(dt=h()[P+4*dt>>2>>>0]=At,At=0;At<X.length;++At)c()[dt++>>0>>>0]=X.charCodeAt(At);c()[dt>>0>>>0]=0,U+=X.length+1}),0}function ue(P,N){if(A)return Bt(21,1,P,N);var U=ae();h()[P>>2>>>0]=U.length;var X=0;return U.forEach(function(dt){X+=dt.length+1}),h()[N>>2>>>0]=X,0}function fe(P){return A?Bt(22,1,P):52}function de(P,N,U,X){return A?Bt(23,1,P,N,U,X):52}function pe(P,N,U,X,dt){return A?Bt(24,1,P,N,U,X,dt):70}var ge=[null,[],[]];function ce(P,N,U,X){if(A)return Bt(25,1,P,N,U,X);for(var dt=0,At=0;At<U;At++){var Nt=h()[N>>2>>>0],Qt=h()[N+4>>2>>>0];N+=8;for(var le=0;le<Qt;le++){var ee=f()[Nt+le>>>0],ne=ge[P];ee===0||ee===10?((P===1?C:R)(ut(ne,0)),ne.length=0):ne.push(ee)}dt+=Qt}return h()[X>>2>>>0]=dt,0}function me(P){return P%4==0&&(P%100!=0||P%400==0)}var Ee=[31,29,31,30,31,30,31,31,30,31,30,31],Ae=[31,28,31,30,31,30,31,31,30,31,30,31];function Ie(P,N,U,X){function dt(tt,Lt,Wt){for(tt=typeof tt=="number"?tt.toString():tt||"";tt.length<Lt;)tt=Wt[0]+tt;return tt}function At(tt,Lt){return dt(tt,Lt,"0")}function Nt(tt,Lt){function Wt(Fe){return 0>Fe?-1:0<Fe?1:0}var he;return(he=Wt(tt.getFullYear()-Lt.getFullYear()))===0&&(he=Wt(tt.getMonth()-Lt.getMonth()))===0&&(he=Wt(tt.getDate()-Lt.getDate())),he}function Qt(tt){switch(tt.getDay()){case 0:return new Date(tt.getFullYear()-1,11,29);case 1:return tt;case 2:return new Date(tt.getFullYear(),0,3);case 3:return new Date(tt.getFullYear(),0,2);case 4:return new Date(tt.getFullYear(),0,1);case 5:return new Date(tt.getFullYear()-1,11,31);case 6:return new Date(tt.getFullYear()-1,11,30)}}function le(tt){var Lt=tt.Ma;for(tt=new Date(new Date(tt.Na+1900,0,1).getTime());0<Lt;){var Wt=tt.getMonth(),he=(me(tt.getFullYear())?Ee:Ae)[Wt];if(!(Lt>he-tt.getDate())){tt.setDate(tt.getDate()+Lt);break}Lt-=he-tt.getDate()+1,tt.setDate(1),11>Wt?tt.setMonth(Wt+1):(tt.setMonth(0),tt.setFullYear(tt.getFullYear()+1))}return Wt=new Date(tt.getFullYear()+1,0,4),Lt=Qt(new Date(tt.getFullYear(),0,4)),Wt=Qt(Wt),0>=Nt(Lt,tt)?0>=Nt(Wt,tt)?tt.getFullYear()+1:tt.getFullYear():tt.getFullYear()-1}var ee=g()[X+40>>2>>>0];for(var ne in X={tb:g()[X>>2>>>0],sb:g()[X+4>>2>>>0],Sa:g()[X+8>>2>>>0],Va:g()[X+12>>2>>>0],Ta:g()[X+16>>2>>>0],Na:g()[X+20>>2>>>0],Ja:g()[X+24>>2>>>0],Ma:g()[X+28>>2>>>0],zb:g()[X+32>>2>>>0],rb:g()[X+36>>2>>>0],ub:ee?St(ee):""},U=St(U),ee={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})U=U.replace(new RegExp(ne,"g"),ee[ne]);var Ce="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Re="January February March April May June July August September October November December".split(" ");for(ne in ee={"%a":function(tt){return Ce[tt.Ja].substring(0,3)},"%A":function(tt){return Ce[tt.Ja]},"%b":function(tt){return Re[tt.Ta].substring(0,3)},"%B":function(tt){return Re[tt.Ta]},"%C":function(tt){return At((tt.Na+1900)/100|0,2)},"%d":function(tt){return At(tt.Va,2)},"%e":function(tt){return dt(tt.Va,2," ")},"%g":function(tt){return le(tt).toString().substring(2)},"%G":function(tt){return le(tt)},"%H":function(tt){return At(tt.Sa,2)},"%I":function(tt){return(tt=tt.Sa)==0?tt=12:12<tt&&(tt-=12),At(tt,2)},"%j":function(tt){for(var Lt=0,Wt=0;Wt<=tt.Ta-1;Lt+=(me(tt.Na+1900)?Ee:Ae)[Wt++]);return At(tt.Va+Lt,3)},"%m":function(tt){return At(tt.Ta+1,2)},"%M":function(tt){return At(tt.sb,2)},"%n":function(){return`
`},"%p":function(tt){return 0<=tt.Sa&&12>tt.Sa?"AM":"PM"},"%S":function(tt){return At(tt.tb,2)},"%t":function(){return"	"},"%u":function(tt){return tt.Ja||7},"%U":function(tt){return At(Math.floor((tt.Ma+7-tt.Ja)/7),2)},"%V":function(tt){var Lt=Math.floor((tt.Ma+7-(tt.Ja+6)%7)/7);if(2>=(tt.Ja+371-tt.Ma-2)%7&&Lt++,Lt)Lt==53&&((Wt=(tt.Ja+371-tt.Ma)%7)==4||Wt==3&&me(tt.Na)||(Lt=1));else{Lt=52;var Wt=(tt.Ja+7-tt.Ma-1)%7;(Wt==4||Wt==5&&me(tt.Na%400-1))&&Lt++}return At(Lt,2)},"%w":function(tt){return tt.Ja},"%W":function(tt){return At(Math.floor((tt.Ma+7-(tt.Ja+6)%7)/7),2)},"%y":function(tt){return(tt.Na+1900).toString().substring(2)},"%Y":function(tt){return tt.Na+1900},"%z":function(tt){var Lt=0<=(tt=tt.rb);return tt=Math.abs(tt)/60,(Lt?"+":"-")+("0000"+(tt/60*100+tt%60)).slice(-4)},"%Z":function(tt){return tt.ub},"%%":function(){return"%"}},U=U.replace(/%%/g,"\0\0"),ee)U.includes(ne)&&(U=U.replace(new RegExp(ne,"g"),ee[ne](X)));return ne=function(tt){var Lt=Array(Ot(tt)+1);return gt(tt,Lt,0,Lt.length),Lt}(U=U.replace(/\0\0/g,"%")),ne.length>N?0:(function(tt,Lt){c().set(tt,Lt>>>0)}(ne,P),ne.length-1)}lt.Ua();var Ue=[null,kt,z,Ft,zt,Vt,jt,Xt,Jt,q,k,L,V,nt,wt,Et,Gt,Zt,se,oe,ie,ue,fe,de,pe,ce],je={b:function(P){return _e(P+24)+24},c:function(P,N,U){throw new bt(P).Ua(N,U),P},L:function(P){Oe(P,!S,1,!I),lt.Za()},l:function(P){A?postMessage({cmd:"cleanupThread",thread:P}):$t(P)},D:Ht,i:zt,R:Vt,z:jt,B:Xt,T:Jt,P:q,I:k,O:L,p:V,A:nt,x:wt,Q:Et,y:Gt,r:function(){},j:function(){et("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},s:function(){et("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},q:function(){return Date.now()},E:function(){return 2097152},V:function(){return!0},F:function(P,N,U,X){if(P==N)setTimeout(()=>Ut(X));else if(A)postMessage({targetThread:P,cmd:"processProxyingQueue",queue:X});else{if(!(P=lt.La[P]))return;P.postMessage({cmd:"processProxyingQueue",queue:X})}return 1},K:function(){return-1},W:function(P,N){P=new Date(1e3*Yt(P)),g()[N>>2>>>0]=P.getUTCSeconds(),g()[N+4>>2>>>0]=P.getUTCMinutes(),g()[N+8>>2>>>0]=P.getUTCHours(),g()[N+12>>2>>>0]=P.getUTCDate(),g()[N+16>>2>>>0]=P.getUTCMonth(),g()[N+20>>2>>>0]=P.getUTCFullYear()-1900,g()[N+24>>2>>>0]=P.getUTCDay(),P=(P.getTime()-Date.UTC(P.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,g()[N+28>>2>>>0]=P},X:function(P,N){P=new Date(1e3*Yt(P)),g()[N>>2>>>0]=P.getSeconds(),g()[N+4>>2>>>0]=P.getMinutes(),g()[N+8>>2>>>0]=P.getHours(),g()[N+12>>2>>>0]=P.getDate(),g()[N+16>>2>>>0]=P.getMonth(),g()[N+20>>2>>>0]=P.getFullYear()-1900,g()[N+24>>2>>>0]=P.getDay();var U=new Date(P.getFullYear(),0,1),X=(P.getTime()-U.getTime())/864e5|0;g()[N+28>>2>>>0]=X,g()[N+36>>2>>>0]=-60*P.getTimezoneOffset(),X=new Date(P.getFullYear(),6,1).getTimezoneOffset(),P=0|(X!=(U=U.getTimezoneOffset())&&P.getTimezoneOffset()==Math.min(U,X)),g()[N+32>>2>>>0]=P},Y:function(P){var N=new Date(g()[P+20>>2>>>0]+1900,g()[P+16>>2>>>0],g()[P+12>>2>>>0],g()[P+8>>2>>>0],g()[P+4>>2>>>0],g()[P>>2>>>0],0),U=g()[P+32>>2>>>0],X=N.getTimezoneOffset(),dt=new Date(N.getFullYear(),0,1),At=new Date(N.getFullYear(),6,1).getTimezoneOffset(),Nt=dt.getTimezoneOffset(),Qt=Math.min(Nt,At);return 0>U?g()[P+32>>2>>>0]=+(At!=Nt&&Qt==X):0<U!=(Qt==X)&&(At=Math.max(Nt,At),N.setTime(N.getTime()+6e4*((0<U?Qt:At)-X))),g()[P+24>>2>>>0]=N.getDay(),U=(N.getTime()-dt.getTime())/864e5|0,g()[P+28>>2>>>0]=U,g()[P>>2>>>0]=N.getSeconds(),g()[P+4>>2>>>0]=N.getMinutes(),g()[P+8>>2>>>0]=N.getHours(),g()[P+12>>2>>>0]=N.getDate(),g()[P+16>>2>>>0]=N.getMonth(),N.getTime()/1e3|0},G:Zt,H:se,Z:function P(N,U,X){P.jb||(P.jb=!0,oe(N,U,X))},d:function(){et("")},m:function(){if(!T&&!S){var P="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";Q||(Q={}),Q[P]||(Q[P]=1,T&&(P="warning: "+P),R(P))}},w:function(){return 4294901760},f:st,S:function(P,N,U){f().copyWithin(P>>>0,N>>>0,N+U>>>0)},g:function(){return T?e(3993).cpus().length:navigator.hardwareConcurrency},J:function(P,N,U){Kt.length=N,U>>=3;for(var X=0;X<N;X++)Kt[X]=p()[U+X>>>0];return(0>P?mt[-P-1]:Ue[P]).apply(null,Kt)},v:function(P){var N=f().length;if((P>>>=0)<=N||4294901760<P)return!1;for(var U=1;4>=U;U*=2){var X=N*(1+.2/U);X=Math.min(X,P+100663296);var dt=Math;X=Math.max(P,X),dt=dt.min.call(dt,4294901760,X+(65536-X%65536)%65536);t:{try{G.grow(dt-Z.byteLength+65535>>>16),pt(G.buffer);var At=1;break t}catch{}At=void 0}if(At)return!0}return!1},U:function(){throw"unwind"},M:ie,N:ue,k:Rt,h:fe,o:de,t:pe,n:ce,u:function P(N,U){P.Wa||(P.Wa=function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var dt=new Uint8Array(1);return()=>(crypto.getRandomValues(dt),dt[0])}if(T)try{var At=e(760);return()=>At.randomBytes(1)[0]}catch{}return()=>et("randomDevice")}());for(var X=0;X<U;X++)c()[N+X>>0>>>0]=P.Wa();return 0},a:G||s.wasmMemory,C:Ie,e:function(P,N,U,X){return Ie(P,N,U,X)}};(function(){function P(dt,At){s.asm=dt.exports,lt.$a.push(s.asm.wa),ot=s.asm.za,It.unshift(s.asm._),W=At,A||(xt--,s.monitorRunDependencies&&s.monitorRunDependencies(xt),xt==0&&_t&&(dt=_t,_t=null,dt()))}function N(dt){P(dt.instance,dt.module)}function U(dt){return function(){if(!F&&(I||S)){if(typeof fetch=="function"&&!ft.startsWith("file://"))return fetch(ft,{credentials:"same-origin"}).then(function(At){if(!At.ok)throw"failed to load wasm binary file at '"+ft+"'";return At.arrayBuffer()}).catch(function(){return Pt()});if(m)return new Promise(function(At,Nt){m(ft,function(Qt){At(new Uint8Array(Qt))},Nt)})}return Promise.resolve().then(function(){return Pt()})}().then(function(At){return WebAssembly.instantiate(At,X)}).then(function(At){return At}).then(dt,function(At){R("failed to asynchronously prepare wasm: "+At),et(At)})}var X={a:je};if(A||(xt++,s.monitorRunDependencies&&s.monitorRunDependencies(xt)),s.instantiateWasm)try{return s.instantiateWasm(X,P)}catch(dt){return R("Module.instantiateWasm callback failed with error: "+dt),!1}(F||typeof WebAssembly.instantiateStreaming!="function"||Ct()||ft.startsWith("file://")||T||typeof fetch!="function"?U(N):fetch(ft,{credentials:"same-origin"}).then(function(dt){return WebAssembly.instantiateStreaming(dt,X).then(N,function(At){return R("wasm streaming compile failed: "+At),R("falling back to ArrayBuffer instantiation"),U(N)})})).catch(u)})(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm._).apply(null,arguments)},s._OrtInit=function(){return(s._OrtInit=s.asm.$).apply(null,arguments)},s._OrtCreateSessionOptions=function(){return(s._OrtCreateSessionOptions=s.asm.aa).apply(null,arguments)},s._OrtAppendExecutionProvider=function(){return(s._OrtAppendExecutionProvider=s.asm.ba).apply(null,arguments)},s._OrtAddSessionConfigEntry=function(){return(s._OrtAddSessionConfigEntry=s.asm.ca).apply(null,arguments)},s._OrtReleaseSessionOptions=function(){return(s._OrtReleaseSessionOptions=s.asm.da).apply(null,arguments)},s._OrtCreateSession=function(){return(s._OrtCreateSession=s.asm.ea).apply(null,arguments)},s._OrtReleaseSession=function(){return(s._OrtReleaseSession=s.asm.fa).apply(null,arguments)},s._OrtGetInputCount=function(){return(s._OrtGetInputCount=s.asm.ga).apply(null,arguments)},s._OrtGetOutputCount=function(){return(s._OrtGetOutputCount=s.asm.ha).apply(null,arguments)},s._OrtGetInputName=function(){return(s._OrtGetInputName=s.asm.ia).apply(null,arguments)},s._OrtGetOutputName=function(){return(s._OrtGetOutputName=s.asm.ja).apply(null,arguments)},s._OrtFree=function(){return(s._OrtFree=s.asm.ka).apply(null,arguments)},s._OrtCreateTensor=function(){return(s._OrtCreateTensor=s.asm.la).apply(null,arguments)},s._OrtGetTensorData=function(){return(s._OrtGetTensorData=s.asm.ma).apply(null,arguments)},s._OrtReleaseTensor=function(){return(s._OrtReleaseTensor=s.asm.na).apply(null,arguments)},s._OrtCreateRunOptions=function(){return(s._OrtCreateRunOptions=s.asm.oa).apply(null,arguments)},s._OrtAddRunConfigEntry=function(){return(s._OrtAddRunConfigEntry=s.asm.pa).apply(null,arguments)},s._OrtReleaseRunOptions=function(){return(s._OrtReleaseRunOptions=s.asm.qa).apply(null,arguments)},s._OrtRun=function(){return(s._OrtRun=s.asm.ra).apply(null,arguments)},s._OrtEndProfiling=function(){return(s._OrtEndProfiling=s.asm.sa).apply(null,arguments)};var be=s._pthread_self=function(){return(be=s._pthread_self=s.asm.ta).apply(null,arguments)},_e=s._malloc=function(){return(_e=s._malloc=s.asm.ua).apply(null,arguments)};s._free=function(){return(s._free=s.asm.va).apply(null,arguments)},s.__emscripten_tls_init=function(){return(s.__emscripten_tls_init=s.asm.wa).apply(null,arguments)};var Oe=s.__emscripten_thread_init=function(){return(Oe=s.__emscripten_thread_init=s.asm.xa).apply(null,arguments)};s.__emscripten_thread_crashed=function(){return(s.__emscripten_thread_crashed=s.asm.ya).apply(null,arguments)};var ye,$e=s._emscripten_run_in_main_runtime_thread_js=function(){return($e=s._emscripten_run_in_main_runtime_thread_js=s.asm.Aa).apply(null,arguments)},De=s.__emscripten_proxy_execute_task_queue=function(){return(De=s.__emscripten_proxy_execute_task_queue=s.asm.Ba).apply(null,arguments)},ve=s.__emscripten_thread_free_data=function(){return(ve=s.__emscripten_thread_free_data=s.asm.Ca).apply(null,arguments)},Me=s.__emscripten_thread_exit=function(){return(Me=s.__emscripten_thread_exit=s.asm.Da).apply(null,arguments)},ke=s._emscripten_stack_set_limits=function(){return(ke=s._emscripten_stack_set_limits=s.asm.Ea).apply(null,arguments)},Te=s.stackSave=function(){return(Te=s.stackSave=s.asm.Fa).apply(null,arguments)},we=s.stackRestore=function(){return(we=s.stackRestore=s.asm.Ga).apply(null,arguments)},Se=s.stackAlloc=function(){return(Se=s.stackAlloc=s.asm.Ha).apply(null,arguments)};function Pe(){function P(){if(!ye&&(ye=!0,s.calledRun=!0,!rt)&&(A||B(It),r(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),!A)){if(s.postRun)for(typeof s.postRun=="function"&&(s.postRun=[s.postRun]);s.postRun.length;){var N=s.postRun.shift();Dt.unshift(N)}B(Dt)}}if(!(0<xt))if(A)r(s),A||B(It),postMessage({cmd:"loaded"});else{if(s.preRun)for(typeof s.preRun=="function"&&(s.preRun=[s.preRun]);s.preRun.length;)H();B(Mt),0<xt||(s.setStatus?(s.setStatus("Running..."),setTimeout(function(){setTimeout(function(){s.setStatus("")},1),P()},1)):P())}}if(s.___cxa_is_pointer_type=function(){return(s.___cxa_is_pointer_type=s.asm.Ia).apply(null,arguments)},s.UTF8ToString=St,s.stringToUTF8=function(P,N,U){return gt(P,f(),N,U)},s.lengthBytesUTF8=Ot,s.keepRuntimeAlive=function(){return j},s.wasmMemory=G,s.stackSave=Te,s.stackRestore=we,s.stackAlloc=Se,s.ExitStatus=vt,s.PThread=lt,_t=function P(){ye||Pe(),ye||(_t=P)},s.preInit)for(typeof s.preInit=="function"&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return Pe(),l.ready});o.exports=a},932:(o,t,e)=>{var n,a=(n=(n=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(l){var c,f,g;l=l||{},c||(c=l!==void 0?l:{}),c.ready=new Promise(function(B,z){f=B,g=z});var h,p,s,r,u,d,m=Object.assign({},c),b="./this.program",y=(B,z)=>{throw z},w=typeof window=="object",x=typeof importScripts=="function",_=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",v="";_?(v=x?e(908).dirname(v)+"/":"//",d=()=>{u||(r=e(1384),u=e(908))},h=function(B,z){return d(),B=u.normalize(B),r.readFileSync(B,z?void 0:"utf8")},s=B=>((B=h(B,!0)).buffer||(B=new Uint8Array(B)),B),p=(B,z,Q)=>{d(),B=u.normalize(B),r.readFile(B,function(st,ht){st?Q(st):z(ht.buffer)})},1<process.argv.length&&(b=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(B){if(!(B instanceof ct))throw B}),process.on("unhandledRejection",function(B){throw B}),y=(B,z)=>{if(T)throw process.exitCode=B,z;z instanceof ct||S("exiting due to exception: "+z),process.exit(B)},c.inspect=function(){return"[Emscripten Module object]"}):(w||x)&&(x?v=self.location.href:typeof document<"u"&&document.currentScript&&(v=document.currentScript.src),n&&(v=n),v=v.indexOf("blob:")!==0?v.substr(0,v.replace(/[?#].*/,"").lastIndexOf("/")+1):"",h=B=>{var z=new XMLHttpRequest;return z.open("GET",B,!1),z.send(null),z.responseText},x&&(s=B=>{var z=new XMLHttpRequest;return z.open("GET",B,!1),z.responseType="arraybuffer",z.send(null),new Uint8Array(z.response)}),p=(B,z,Q)=>{var st=new XMLHttpRequest;st.open("GET",B,!0),st.responseType="arraybuffer",st.onload=()=>{st.status==200||st.status==0&&st.response?z(st.response):Q()},st.onerror=Q,st.send(null)});var E,I=c.print||console.log.bind(console),S=c.printErr||console.warn.bind(console);Object.assign(c,m),m=null,c.thisProgram&&(b=c.thisProgram),c.quit&&(y=c.quit),c.wasmBinary&&(E=c.wasmBinary);var T=c.noExitRuntime||!0;typeof WebAssembly!="object"&&St("no native wasm support detected");var A,O,$,D,M,F,C=!1,R=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function j(B,z,Q){var st=(z>>>=0)+Q;for(Q=z;B[Q]&&!(Q>=st);)++Q;if(16<Q-z&&B.buffer&&R)return R.decode(B.subarray(z,Q));for(st="";z<Q;){var ht=B[z++];if(128&ht){var bt=63&B[z++];if((224&ht)==192)st+=String.fromCharCode((31&ht)<<6|bt);else{var Ft=63&B[z++];65536>(ht=(240&ht)==224?(15&ht)<<12|bt<<6|Ft:(7&ht)<<18|bt<<12|Ft<<6|63&B[z++])?st+=String.fromCharCode(ht):(ht-=65536,st+=String.fromCharCode(55296|ht>>10,56320|1023&ht))}}else st+=String.fromCharCode(ht)}return st}function G(B,z){return(B>>>=0)?j(D,B,z):""}function W(B,z,Q,st){if(!(0<st))return 0;var ht=Q>>>=0;st=Q+st-1;for(var bt=0;bt<B.length;++bt){var Ft=B.charCodeAt(bt);if(55296<=Ft&&57343>=Ft&&(Ft=65536+((1023&Ft)<<10)|1023&B.charCodeAt(++bt)),127>=Ft){if(Q>=st)break;z[Q++>>>0]=Ft}else{if(2047>=Ft){if(Q+1>=st)break;z[Q++>>>0]=192|Ft>>6}else{if(65535>=Ft){if(Q+2>=st)break;z[Q++>>>0]=224|Ft>>12}else{if(Q+3>=st)break;z[Q++>>>0]=240|Ft>>18,z[Q++>>>0]=128|Ft>>12&63}z[Q++>>>0]=128|Ft>>6&63}z[Q++>>>0]=128|63&Ft}}return z[Q>>>0]=0,Q-ht}function Z(B){for(var z=0,Q=0;Q<B.length;++Q){var st=B.charCodeAt(Q);127>=st?z++:2047>=st?z+=2:55296<=st&&57343>=st?(z+=4,++Q):z+=3}return z}function at(){var B=A.buffer;O=B,c.HEAP8=$=new Int8Array(B),c.HEAP16=new Int16Array(B),c.HEAP32=M=new Int32Array(B),c.HEAPU8=D=new Uint8Array(B),c.HEAPU16=new Uint16Array(B),c.HEAPU32=F=new Uint32Array(B),c.HEAPF32=new Float32Array(B),c.HEAPF64=new Float64Array(B)}var J=[],Y=[],K=[];function it(){var B=c.preRun.shift();J.unshift(B)}var rt,yt=0,ut=null;function St(B){throw c.onAbort&&c.onAbort(B),S(B="Aborted("+B+")"),C=!0,B=new WebAssembly.RuntimeError(B+". Build with -sASSERTIONS for more info."),g(B),B}function gt(){return rt.startsWith("data:application/octet-stream;base64,")}if(rt="ort-wasm.wasm",!gt()){var Ot=rt;rt=c.locateFile?c.locateFile(Ot,v):v+Ot}function pt(){var B=rt;try{if(B==rt&&E)return new Uint8Array(E);if(s)return s(B);throw"both async and sync fetching of the wasm failed"}catch(z){St(z)}}function ct(B){this.name="ExitStatus",this.message="Program terminated with exit("+B+")",this.status=B}function ot(B){for(;0<B.length;)B.shift()(c)}function Mt(B){this.sa=B-24,this.Ia=function(z){F[this.sa+4>>2>>>0]=z},this.Ba=function(z){F[this.sa+8>>2>>>0]=z},this.Ga=function(){M[this.sa>>2>>>0]=0},this.Aa=function(){$[this.sa+12>>0>>>0]=0},this.Ha=function(){$[this.sa+13>>0>>>0]=0},this.ya=function(z,Q){this.za(),this.Ia(z),this.Ba(Q),this.Ga(),this.Aa(),this.Ha()},this.za=function(){F[this.sa+16>>2>>>0]=0}}function It(B){var z=Z(B)+1,Q=vt(z);return Q&&W(B,$,Q,z),Q}var Dt={};function H(){if(!ft){var B,z={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:b||"./this.program"};for(B in Dt)Dt[B]===void 0?delete z[B]:z[B]=Dt[B];var Q=[];for(B in z)Q.push(B+"="+z[B]);ft=Q}return ft}var ft,xt=[null,[],[]];function _t(B){return B%4==0&&(B%100!=0||B%400==0)}var et=[31,29,31,30,31,30,31,31,30,31,30,31],Ct=[31,28,31,30,31,30,31,31,30,31,30,31];function Pt(B,z,Q,st){function ht(q,k,L){for(q=typeof q=="number"?q.toString():q||"";q.length<k;)q=L[0]+q;return q}function bt(q,k){return ht(q,k,"0")}function Ft(q,k){function L(nt){return 0>nt?-1:0<nt?1:0}var V;return(V=L(q.getFullYear()-k.getFullYear()))===0&&(V=L(q.getMonth()-k.getMonth()))===0&&(V=L(q.getDate()-k.getDate())),V}function Ht(q){switch(q.getDay()){case 0:return new Date(q.getFullYear()-1,11,29);case 1:return q;case 2:return new Date(q.getFullYear(),0,3);case 3:return new Date(q.getFullYear(),0,2);case 4:return new Date(q.getFullYear(),0,1);case 5:return new Date(q.getFullYear()-1,11,31);case 6:return new Date(q.getFullYear()-1,11,30)}}function zt(q){var k=q.qa;for(q=new Date(new Date(q.ra+1900,0,1).getTime());0<k;){var L=q.getMonth(),V=(_t(q.getFullYear())?et:Ct)[L];if(!(k>V-q.getDate())){q.setDate(q.getDate()+k);break}k-=V-q.getDate()+1,q.setDate(1),11>L?q.setMonth(L+1):(q.setMonth(0),q.setFullYear(q.getFullYear()+1))}return L=new Date(q.getFullYear()+1,0,4),k=Ht(new Date(q.getFullYear(),0,4)),L=Ht(L),0>=Ft(k,q)?0>=Ft(L,q)?q.getFullYear()+1:q.getFullYear():q.getFullYear()-1}var Vt=M[st+40>>2>>>0];for(var jt in st={Ea:M[st>>2>>>0],Da:M[st+4>>2>>>0],ta:M[st+8>>2>>>0],va:M[st+12>>2>>>0],ua:M[st+16>>2>>>0],ra:M[st+20>>2>>>0],la:M[st+24>>2>>>0],qa:M[st+28>>2>>>0],Ja:M[st+32>>2>>>0],Ca:M[st+36>>2>>>0],Fa:Vt?G(Vt):""},Q=G(Q),Vt={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})Q=Q.replace(new RegExp(jt,"g"),Vt[jt]);var Xt="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Jt="January February March April May June July August September October November December".split(" ");for(jt in Vt={"%a":function(q){return Xt[q.la].substring(0,3)},"%A":function(q){return Xt[q.la]},"%b":function(q){return Jt[q.ua].substring(0,3)},"%B":function(q){return Jt[q.ua]},"%C":function(q){return bt((q.ra+1900)/100|0,2)},"%d":function(q){return bt(q.va,2)},"%e":function(q){return ht(q.va,2," ")},"%g":function(q){return zt(q).toString().substring(2)},"%G":function(q){return zt(q)},"%H":function(q){return bt(q.ta,2)},"%I":function(q){return(q=q.ta)==0?q=12:12<q&&(q-=12),bt(q,2)},"%j":function(q){for(var k=0,L=0;L<=q.ua-1;k+=(_t(q.ra+1900)?et:Ct)[L++]);return bt(q.va+k,3)},"%m":function(q){return bt(q.ua+1,2)},"%M":function(q){return bt(q.Da,2)},"%n":function(){return`
`},"%p":function(q){return 0<=q.ta&&12>q.ta?"AM":"PM"},"%S":function(q){return bt(q.Ea,2)},"%t":function(){return"	"},"%u":function(q){return q.la||7},"%U":function(q){return bt(Math.floor((q.qa+7-q.la)/7),2)},"%V":function(q){var k=Math.floor((q.qa+7-(q.la+6)%7)/7);if(2>=(q.la+371-q.qa-2)%7&&k++,k)k==53&&((L=(q.la+371-q.qa)%7)==4||L==3&&_t(q.ra)||(k=1));else{k=52;var L=(q.la+7-q.qa-1)%7;(L==4||L==5&&_t(q.ra%400-1))&&k++}return bt(k,2)},"%w":function(q){return q.la},"%W":function(q){return bt(Math.floor((q.qa+7-(q.la+6)%7)/7),2)},"%y":function(q){return(q.ra+1900).toString().substring(2)},"%Y":function(q){return q.ra+1900},"%z":function(q){var k=0<=(q=q.Ca);return q=Math.abs(q)/60,(k?"+":"-")+("0000"+(q/60*100+q%60)).slice(-4)},"%Z":function(q){return q.Fa},"%%":function(){return"%"}},Q=Q.replace(/%%/g,"\0\0"),Vt)Q.includes(jt)&&(Q=Q.replace(new RegExp(jt,"g"),Vt[jt](st)));return jt=function(q){var k=Array(Z(q)+1);return W(q,k,0,k.length),k}(Q=Q.replace(/\0\0/g,"%")),jt.length>z?0:($.set(jt,B>>>0),jt.length-1)}var mt={a:function(B){return vt(B+24)+24},b:function(B,z,Q){throw new Mt(B).ya(z,Q),B},g:function(){return 0},I:function(){},w:function(){},y:function(){},K:function(){return 0},G:function(){},C:function(){},F:function(){},k:function(){},x:function(){},u:function(){},H:function(){},v:function(){},n:function(){},p:function(){St("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},o:function(){St("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},l:function(){return Date.now()},L:function(){return!0},M:function(B,z){B=new Date(1e3*(F[B>>>2]+4294967296*M[B+4>>>2])),M[z>>2>>>0]=B.getUTCSeconds(),M[z+4>>2>>>0]=B.getUTCMinutes(),M[z+8>>2>>>0]=B.getUTCHours(),M[z+12>>2>>>0]=B.getUTCDate(),M[z+16>>2>>>0]=B.getUTCMonth(),M[z+20>>2>>>0]=B.getUTCFullYear()-1900,M[z+24>>2>>>0]=B.getUTCDay(),M[z+28>>2>>>0]=(B.getTime()-Date.UTC(B.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},N:function(B,z){B=new Date(1e3*(F[B>>>2]+4294967296*M[B+4>>>2])),M[z>>2>>>0]=B.getSeconds(),M[z+4>>2>>>0]=B.getMinutes(),M[z+8>>2>>>0]=B.getHours(),M[z+12>>2>>>0]=B.getDate(),M[z+16>>2>>>0]=B.getMonth(),M[z+20>>2>>>0]=B.getFullYear()-1900,M[z+24>>2>>>0]=B.getDay();var Q=new Date(B.getFullYear(),0,1);M[z+28>>2>>>0]=(B.getTime()-Q.getTime())/864e5|0,M[z+36>>2>>>0]=-60*B.getTimezoneOffset();var st=new Date(B.getFullYear(),6,1).getTimezoneOffset();Q=Q.getTimezoneOffset(),M[z+32>>2>>>0]=0|(st!=Q&&B.getTimezoneOffset()==Math.min(Q,st))},O:function(B){var z=new Date(M[B+20>>2>>>0]+1900,M[B+16>>2>>>0],M[B+12>>2>>>0],M[B+8>>2>>>0],M[B+4>>2>>>0],M[B>>2>>>0],0),Q=M[B+32>>2>>>0],st=z.getTimezoneOffset(),ht=new Date(z.getFullYear(),0,1),bt=new Date(z.getFullYear(),6,1).getTimezoneOffset(),Ft=ht.getTimezoneOffset(),Ht=Math.min(Ft,bt);return 0>Q?M[B+32>>2>>>0]=+(bt!=Ft&&Ht==st):0<Q!=(Ht==st)&&(bt=Math.max(Ft,bt),z.setTime(z.getTime()+6e4*((0<Q?Ht:bt)-st))),M[B+24>>2>>>0]=z.getDay(),M[B+28>>2>>>0]=(z.getTime()-ht.getTime())/864e5|0,M[B>>2>>>0]=z.getSeconds(),M[B+4>>2>>>0]=z.getMinutes(),M[B+8>>2>>>0]=z.getHours(),M[B+12>>2>>>0]=z.getDate(),M[B+16>>2>>>0]=z.getMonth(),z.getTime()/1e3|0},z:function(){return-52},B:function(){},m:function B(z,Q,st){B.xa||(B.xa=!0,function(ht,bt,Ft){function Ht(Jt){return(Jt=Jt.toTimeString().match(/\(([A-Za-z ]+)\)$/))?Jt[1]:"GMT"}var zt=new Date().getFullYear(),Vt=new Date(zt,0,1),jt=new Date(zt,6,1);zt=Vt.getTimezoneOffset();var Xt=jt.getTimezoneOffset();M[ht>>2>>>0]=60*Math.max(zt,Xt),M[bt>>2>>>0]=+(zt!=Xt),ht=Ht(Vt),bt=Ht(jt),ht=It(ht),bt=It(bt),Xt<zt?(F[Ft>>2>>>0]=ht,F[Ft+4>>2>>>0]=bt):(F[Ft>>2>>>0]=bt,F[Ft+4>>2>>>0]=ht)}(z,Q,st))},d:function(){St("")},t:function(){return 4294901760},h:_?()=>{var B=process.hrtime();return 1e3*B[0]+B[1]/1e6}:()=>performance.now(),J:function(B,z,Q){D.copyWithin(B>>>0,z>>>0,z+Q>>>0)},f:function(B){var z=D.length;if(4294901760<(B>>>=0))return!1;for(var Q=1;4>=Q;Q*=2){var st=z*(1+.2/Q);st=Math.min(st,B+100663296);var ht=Math;st=Math.max(B,st),ht=ht.min.call(ht,4294901760,st+(65536-st%65536)%65536);t:{try{A.grow(ht-O.byteLength+65535>>>16),at();var bt=1;break t}catch{}bt=void 0}if(bt)return!0}return!1},D:function(B,z){var Q=0;return H().forEach(function(st,ht){var bt=z+Q;for(ht=F[B+4*ht>>2>>>0]=bt,bt=0;bt<st.length;++bt)$[ht++>>0>>>0]=st.charCodeAt(bt);$[ht>>0>>>0]=0,Q+=st.length+1}),0},E:function(B,z){var Q=H();F[B>>2>>>0]=Q.length;var st=0;return Q.forEach(function(ht){st+=ht.length+1}),F[z>>2>>>0]=st,0},r:function(B){T||(c.onExit&&c.onExit(B),C=!0),y(B,new ct(B))},e:function(){return 52},j:function(){return 52},q:function(){return 70},i:function(B,z,Q,st){for(var ht=0,bt=0;bt<Q;bt++){var Ft=F[z>>2>>>0],Ht=F[z+4>>2>>>0];z+=8;for(var zt=0;zt<Ht;zt++){var Vt=D[Ft+zt>>>0],jt=xt[B];Vt===0||Vt===10?((B===1?I:S)(j(jt,0)),jt.length=0):jt.push(Vt)}ht+=Ht}return F[st>>2>>>0]=ht,0},s:function B(z,Q){B.wa||(B.wa=function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var ht=new Uint8Array(1);return()=>(crypto.getRandomValues(ht),ht[0])}if(_)try{var bt=e(760);return()=>bt.randomBytes(1)[0]}catch{}return()=>St("randomDevice")}());for(var st=0;st<Q;st++)$[z+st>>0>>>0]=B.wa();return 0},A:Pt,c:function(B,z,Q,st){return Pt(B,z,Q,st)}};(function(){function B(ht){c.asm=ht.exports,A=c.asm.P,at(),Y.unshift(c.asm.Q),yt--,c.monitorRunDependencies&&c.monitorRunDependencies(yt),yt==0&&ut&&(ht=ut,ut=null,ht())}function z(ht){B(ht.instance)}function Q(ht){return function(){if(!E&&(w||x)){if(typeof fetch=="function"&&!rt.startsWith("file://"))return fetch(rt,{credentials:"same-origin"}).then(function(bt){if(!bt.ok)throw"failed to load wasm binary file at '"+rt+"'";return bt.arrayBuffer()}).catch(function(){return pt()});if(p)return new Promise(function(bt,Ft){p(rt,function(Ht){bt(new Uint8Array(Ht))},Ft)})}return Promise.resolve().then(function(){return pt()})}().then(function(bt){return WebAssembly.instantiate(bt,st)}).then(function(bt){return bt}).then(ht,function(bt){S("failed to asynchronously prepare wasm: "+bt),St(bt)})}var st={a:mt};if(yt++,c.monitorRunDependencies&&c.monitorRunDependencies(yt),c.instantiateWasm)try{return c.instantiateWasm(st,B)}catch(ht){return S("Module.instantiateWasm callback failed with error: "+ht),!1}(E||typeof WebAssembly.instantiateStreaming!="function"||gt()||rt.startsWith("file://")||_||typeof fetch!="function"?Q(z):fetch(rt,{credentials:"same-origin"}).then(function(ht){return WebAssembly.instantiateStreaming(ht,st).then(z,function(bt){return S("wasm streaming compile failed: "+bt),S("falling back to ArrayBuffer instantiation"),Q(z)})})).catch(g)})(),c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.Q).apply(null,arguments)},c._OrtInit=function(){return(c._OrtInit=c.asm.R).apply(null,arguments)},c._OrtCreateSessionOptions=function(){return(c._OrtCreateSessionOptions=c.asm.S).apply(null,arguments)},c._OrtAppendExecutionProvider=function(){return(c._OrtAppendExecutionProvider=c.asm.T).apply(null,arguments)},c._OrtAddSessionConfigEntry=function(){return(c._OrtAddSessionConfigEntry=c.asm.U).apply(null,arguments)},c._OrtReleaseSessionOptions=function(){return(c._OrtReleaseSessionOptions=c.asm.V).apply(null,arguments)},c._OrtCreateSession=function(){return(c._OrtCreateSession=c.asm.W).apply(null,arguments)},c._OrtReleaseSession=function(){return(c._OrtReleaseSession=c.asm.X).apply(null,arguments)},c._OrtGetInputCount=function(){return(c._OrtGetInputCount=c.asm.Y).apply(null,arguments)},c._OrtGetOutputCount=function(){return(c._OrtGetOutputCount=c.asm.Z).apply(null,arguments)},c._OrtGetInputName=function(){return(c._OrtGetInputName=c.asm._).apply(null,arguments)},c._OrtGetOutputName=function(){return(c._OrtGetOutputName=c.asm.$).apply(null,arguments)},c._OrtFree=function(){return(c._OrtFree=c.asm.aa).apply(null,arguments)},c._OrtCreateTensor=function(){return(c._OrtCreateTensor=c.asm.ba).apply(null,arguments)},c._OrtGetTensorData=function(){return(c._OrtGetTensorData=c.asm.ca).apply(null,arguments)},c._OrtReleaseTensor=function(){return(c._OrtReleaseTensor=c.asm.da).apply(null,arguments)},c._OrtCreateRunOptions=function(){return(c._OrtCreateRunOptions=c.asm.ea).apply(null,arguments)},c._OrtAddRunConfigEntry=function(){return(c._OrtAddRunConfigEntry=c.asm.fa).apply(null,arguments)},c._OrtReleaseRunOptions=function(){return(c._OrtReleaseRunOptions=c.asm.ga).apply(null,arguments)},c._OrtRun=function(){return(c._OrtRun=c.asm.ha).apply(null,arguments)},c._OrtEndProfiling=function(){return(c._OrtEndProfiling=c.asm.ia).apply(null,arguments)};var vt=c._malloc=function(){return(vt=c._malloc=c.asm.ja).apply(null,arguments)};c._free=function(){return(c._free=c.asm.ka).apply(null,arguments)};var $t,Tt=c.stackSave=function(){return(Tt=c.stackSave=c.asm.ma).apply(null,arguments)},kt=c.stackRestore=function(){return(kt=c.stackRestore=c.asm.na).apply(null,arguments)},Rt=c.stackAlloc=function(){return(Rt=c.stackAlloc=c.asm.oa).apply(null,arguments)};function lt(){function B(){if(!$t&&($t=!0,c.calledRun=!0,!C)){if(ot(Y),f(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),c.postRun)for(typeof c.postRun=="function"&&(c.postRun=[c.postRun]);c.postRun.length;){var z=c.postRun.shift();K.unshift(z)}ot(K)}}if(!(0<yt)){if(c.preRun)for(typeof c.preRun=="function"&&(c.preRun=[c.preRun]);c.preRun.length;)it();ot(J),0<yt||(c.setStatus?(c.setStatus("Running..."),setTimeout(function(){setTimeout(function(){c.setStatus("")},1),B()},1)):B())}}if(c.___cxa_is_pointer_type=function(){return(c.___cxa_is_pointer_type=c.asm.pa).apply(null,arguments)},c.UTF8ToString=G,c.stringToUTF8=function(B,z,Q){return W(B,D,z,Q)},c.lengthBytesUTF8=Z,c.stackSave=Tt,c.stackRestore=kt,c.stackAlloc=Rt,ut=function B(){$t||lt(),$t||(ut=B)},c.preInit)for(typeof c.preInit=="function"&&(c.preInit=[c.preInit]);0<c.preInit.length;)c.preInit.pop()();return lt(),l.ready});o.exports=a},4537:o=>{o.exports=function(t,e){for(var n=new Array(arguments.length-1),a=0,l=2,c=!0;l<arguments.length;)n[a++]=arguments[l++];return new Promise(function(f,g){n[a]=function(h){if(c)if(c=!1,h)g(h);else{for(var p=new Array(arguments.length-1),s=0;s<p.length;)p[s++]=arguments[s];f.apply(null,p)}};try{t.apply(e||null,n)}catch(h){c&&(c=!1,g(h))}})}},7419:(o,t)=>{var e=t;e.length=function(f){var g=f.length;if(!g)return 0;for(var h=0;--g%4>1&&f.charAt(g)==="=";)++h;return Math.ceil(3*f.length)/4-h};for(var n=new Array(64),a=new Array(123),l=0;l<64;)a[n[l]=l<26?l+65:l<52?l+71:l<62?l-4:l-59|43]=l++;e.encode=function(f,g,h){for(var p,s=null,r=[],u=0,d=0;g<h;){var m=f[g++];switch(d){case 0:r[u++]=n[m>>2],p=(3&m)<<4,d=1;break;case 1:r[u++]=n[p|m>>4],p=(15&m)<<2,d=2;break;case 2:r[u++]=n[p|m>>6],r[u++]=n[63&m],d=0}u>8191&&((s||(s=[])).push(String.fromCharCode.apply(String,r)),u=0)}return d&&(r[u++]=n[p],r[u++]=61,d===1&&(r[u++]=61)),s?(u&&s.push(String.fromCharCode.apply(String,r.slice(0,u))),s.join("")):String.fromCharCode.apply(String,r.slice(0,u))};var c="invalid encoding";e.decode=function(f,g,h){for(var p,s=h,r=0,u=0;u<f.length;){var d=f.charCodeAt(u++);if(d===61&&r>1)break;if((d=a[d])===void 0)throw Error(c);switch(r){case 0:p=d,r=1;break;case 1:g[h++]=p<<2|(48&d)>>4,p=d,r=2;break;case 2:g[h++]=(15&p)<<4|(60&d)>>2,p=d,r=3;break;case 3:g[h++]=(3&p)<<6|d,r=0}}if(r===1)throw Error(c);return h-s},e.test=function(f){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(f)}},9211:o=>{function t(){this._listeners={}}o.exports=t,t.prototype.on=function(e,n,a){return(this._listeners[e]||(this._listeners[e]=[])).push({fn:n,ctx:a||this}),this},t.prototype.off=function(e,n){if(e===void 0)this._listeners={};else if(n===void 0)this._listeners[e]=[];else for(var a=this._listeners[e],l=0;l<a.length;)a[l].fn===n?a.splice(l,1):++l;return this},t.prototype.emit=function(e){var n=this._listeners[e];if(n){for(var a=[],l=1;l<arguments.length;)a.push(arguments[l++]);for(l=0;l<n.length;)n[l].fn.apply(n[l++].ctx,a)}return this}},945:o=>{function t(c){return typeof Float32Array<"u"?function(){var f=new Float32Array([-0]),g=new Uint8Array(f.buffer),h=g[3]===128;function p(d,m,b){f[0]=d,m[b]=g[0],m[b+1]=g[1],m[b+2]=g[2],m[b+3]=g[3]}function s(d,m,b){f[0]=d,m[b]=g[3],m[b+1]=g[2],m[b+2]=g[1],m[b+3]=g[0]}function r(d,m){return g[0]=d[m],g[1]=d[m+1],g[2]=d[m+2],g[3]=d[m+3],f[0]}function u(d,m){return g[3]=d[m],g[2]=d[m+1],g[1]=d[m+2],g[0]=d[m+3],f[0]}c.writeFloatLE=h?p:s,c.writeFloatBE=h?s:p,c.readFloatLE=h?r:u,c.readFloatBE=h?u:r}():function(){function f(h,p,s,r){var u=p<0?1:0;if(u&&(p=-p),p===0)h(1/p>0?0:2147483648,s,r);else if(isNaN(p))h(2143289344,s,r);else if(p>34028234663852886e22)h((u<<31|2139095040)>>>0,s,r);else if(p<11754943508222875e-54)h((u<<31|Math.round(p/1401298464324817e-60))>>>0,s,r);else{var d=Math.floor(Math.log(p)/Math.LN2);h((u<<31|d+127<<23|8388607&Math.round(p*Math.pow(2,-d)*8388608))>>>0,s,r)}}function g(h,p,s){var r=h(p,s),u=2*(r>>31)+1,d=r>>>23&255,m=8388607&r;return d===255?m?NaN:u*(1/0):d===0?1401298464324817e-60*u*m:u*Math.pow(2,d-150)*(m+8388608)}c.writeFloatLE=f.bind(null,e),c.writeFloatBE=f.bind(null,n),c.readFloatLE=g.bind(null,a),c.readFloatBE=g.bind(null,l)}(),typeof Float64Array<"u"?function(){var f=new Float64Array([-0]),g=new Uint8Array(f.buffer),h=g[7]===128;function p(d,m,b){f[0]=d,m[b]=g[0],m[b+1]=g[1],m[b+2]=g[2],m[b+3]=g[3],m[b+4]=g[4],m[b+5]=g[5],m[b+6]=g[6],m[b+7]=g[7]}function s(d,m,b){f[0]=d,m[b]=g[7],m[b+1]=g[6],m[b+2]=g[5],m[b+3]=g[4],m[b+4]=g[3],m[b+5]=g[2],m[b+6]=g[1],m[b+7]=g[0]}function r(d,m){return g[0]=d[m],g[1]=d[m+1],g[2]=d[m+2],g[3]=d[m+3],g[4]=d[m+4],g[5]=d[m+5],g[6]=d[m+6],g[7]=d[m+7],f[0]}function u(d,m){return g[7]=d[m],g[6]=d[m+1],g[5]=d[m+2],g[4]=d[m+3],g[3]=d[m+4],g[2]=d[m+5],g[1]=d[m+6],g[0]=d[m+7],f[0]}c.writeDoubleLE=h?p:s,c.writeDoubleBE=h?s:p,c.readDoubleLE=h?r:u,c.readDoubleBE=h?u:r}():function(){function f(h,p,s,r,u,d){var m=r<0?1:0;if(m&&(r=-r),r===0)h(0,u,d+p),h(1/r>0?0:2147483648,u,d+s);else if(isNaN(r))h(0,u,d+p),h(2146959360,u,d+s);else if(r>17976931348623157e292)h(0,u,d+p),h((m<<31|2146435072)>>>0,u,d+s);else{var b;if(r<22250738585072014e-324)h((b=r/5e-324)>>>0,u,d+p),h((m<<31|b/4294967296)>>>0,u,d+s);else{var y=Math.floor(Math.log(r)/Math.LN2);y===1024&&(y=1023),h(4503599627370496*(b=r*Math.pow(2,-y))>>>0,u,d+p),h((m<<31|y+1023<<20|1048576*b&1048575)>>>0,u,d+s)}}}function g(h,p,s,r,u){var d=h(r,u+p),m=h(r,u+s),b=2*(m>>31)+1,y=m>>>20&2047,w=4294967296*(1048575&m)+d;return y===2047?w?NaN:b*(1/0):y===0?5e-324*b*w:b*Math.pow(2,y-1075)*(w+4503599627370496)}c.writeDoubleLE=f.bind(null,e,0,4),c.writeDoubleBE=f.bind(null,n,4,0),c.readDoubleLE=g.bind(null,a,0,4),c.readDoubleBE=g.bind(null,l,4,0)}(),c}function e(c,f,g){f[g]=255&c,f[g+1]=c>>>8&255,f[g+2]=c>>>16&255,f[g+3]=c>>>24}function n(c,f,g){f[g]=c>>>24,f[g+1]=c>>>16&255,f[g+2]=c>>>8&255,f[g+3]=255&c}function a(c,f){return(c[f]|c[f+1]<<8|c[f+2]<<16|c[f+3]<<24)>>>0}function l(c,f){return(c[f]<<24|c[f+1]<<16|c[f+2]<<8|c[f+3])>>>0}o.exports=t(t)},7199:module=>{function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(o){}return null}module.exports=inquire},6662:o=>{o.exports=function(t,e,n){var a=n||8192,l=a>>>1,c=null,f=a;return function(g){if(g<1||g>l)return t(g);f+g>a&&(c=t(a),f=0);var h=e.call(c,f,f+=g);return 7&f&&(f=1+(7|f)),h}}},4997:(o,t)=>{var e=t;e.length=function(n){for(var a=0,l=0,c=0;c<n.length;++c)(l=n.charCodeAt(c))<128?a+=1:l<2048?a+=2:(64512&l)==55296&&(64512&n.charCodeAt(c+1))==56320?(++c,a+=4):a+=3;return a},e.read=function(n,a,l){if(l-a<1)return"";for(var c,f=null,g=[],h=0;a<l;)(c=n[a++])<128?g[h++]=c:c>191&&c<224?g[h++]=(31&c)<<6|63&n[a++]:c>239&&c<365?(c=((7&c)<<18|(63&n[a++])<<12|(63&n[a++])<<6|63&n[a++])-65536,g[h++]=55296+(c>>10),g[h++]=56320+(1023&c)):g[h++]=(15&c)<<12|(63&n[a++])<<6|63&n[a++],h>8191&&((f||(f=[])).push(String.fromCharCode.apply(String,g)),h=0);return f?(h&&f.push(String.fromCharCode.apply(String,g.slice(0,h))),f.join("")):String.fromCharCode.apply(String,g.slice(0,h))},e.write=function(n,a,l){for(var c,f,g=l,h=0;h<n.length;++h)(c=n.charCodeAt(h))<128?a[l++]=c:c<2048?(a[l++]=c>>6|192,a[l++]=63&c|128):(64512&c)==55296&&(64512&(f=n.charCodeAt(h+1)))==56320?(c=65536+((1023&c)<<10)+(1023&f),++h,a[l++]=c>>18|240,a[l++]=c>>12&63|128,a[l++]=c>>6&63|128,a[l++]=63&c|128):(a[l++]=c>>12|224,a[l++]=c>>6&63|128,a[l++]=63&c|128);return l-g}},3442:(o,t)=>{t.__esModule=!0;var e=function(){function n(a){if(!a)throw new TypeError("Invalid argument; `value` has no value.");this.value=n.EMPTY,a&&n.isGuid(a)&&(this.value=a)}return n.isGuid=function(a){var l=a.toString();return a&&(a instanceof n||n.validator.test(l))},n.create=function(){return new n([n.gen(2),n.gen(1),n.gen(1),n.gen(1),n.gen(3)].join("-"))},n.createEmpty=function(){return new n("emptyguid")},n.parse=function(a){return new n(a)},n.raw=function(){return[n.gen(2),n.gen(1),n.gen(1),n.gen(1),n.gen(3)].join("-")},n.gen=function(a){for(var l="",c=0;c<a;c++)l+=(65536*(1+Math.random())|0).toString(16).substring(1);return l},n.prototype.equals=function(a){return n.isGuid(a)&&this.value===a.toString()},n.prototype.isEmpty=function(){return this.value===n.EMPTY},n.prototype.toString=function(){return this.value},n.prototype.toJSON=function(){return{value:this.value}},n.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),n.EMPTY="00000000-0000-0000-0000-000000000000",n}();t.Guid=e},3720:o=>{o.exports=e;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(T,A,O){this.low=0|T,this.high=0|A,this.unsigned=!!O}function n(T){return(T&&T.__isLong__)===!0}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0}),e.isLong=n;var a={},l={};function c(T,A){var O,$,D;return A?(D=0<=(T>>>=0)&&T<256)&&($=l[T])?$:(O=g(T,(0|T)<0?-1:0,!0),D&&(l[T]=O),O):(D=-128<=(T|=0)&&T<128)&&($=a[T])?$:(O=g(T,T<0?-1:0,!1),D&&(a[T]=O),O)}function f(T,A){if(isNaN(T))return A?y:b;if(A){if(T<0)return y;if(T>=u)return E}else{if(T<=-d)return I;if(T+1>=d)return v}return T<0?f(-T,A).neg():g(T%r|0,T/r|0,A)}function g(T,A,O){return new e(T,A,O)}e.fromInt=c,e.fromNumber=f,e.fromBits=g;var h=Math.pow;function p(T,A,O){if(T.length===0)throw Error("empty string");if(T==="NaN"||T==="Infinity"||T==="+Infinity"||T==="-Infinity")return b;if(typeof A=="number"?(O=A,A=!1):A=!!A,(O=O||10)<2||36<O)throw RangeError("radix");var $;if(($=T.indexOf("-"))>0)throw Error("interior hyphen");if($===0)return p(T.substring(1),A,O).neg();for(var D=f(h(O,8)),M=b,F=0;F<T.length;F+=8){var C=Math.min(8,T.length-F),R=parseInt(T.substring(F,F+C),O);if(C<8){var j=f(h(O,C));M=M.mul(j).add(f(R))}else M=(M=M.mul(D)).add(f(R))}return M.unsigned=A,M}function s(T,A){return typeof T=="number"?f(T,A):typeof T=="string"?p(T,A):g(T.low,T.high,typeof A=="boolean"?A:T.unsigned)}e.fromString=p,e.fromValue=s;var r=4294967296,u=r*r,d=u/2,m=c(1<<24),b=c(0);e.ZERO=b;var y=c(0,!0);e.UZERO=y;var w=c(1);e.ONE=w;var x=c(1,!0);e.UONE=x;var _=c(-1);e.NEG_ONE=_;var v=g(-1,2147483647,!1);e.MAX_VALUE=v;var E=g(-1,-1,!0);e.MAX_UNSIGNED_VALUE=E;var I=g(0,-2147483648,!1);e.MIN_VALUE=I;var S=e.prototype;S.toInt=function(){return this.unsigned?this.low>>>0:this.low},S.toNumber=function(){return this.unsigned?(this.high>>>0)*r+(this.low>>>0):this.high*r+(this.low>>>0)},S.toString=function(T){if((T=T||10)<2||36<T)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(I)){var A=f(T),O=this.div(A),$=O.mul(A).sub(this);return O.toString(T)+$.toInt().toString(T)}return"-"+this.neg().toString(T)}for(var D=f(h(T,6),this.unsigned),M=this,F="";;){var C=M.div(D),R=(M.sub(C.mul(D)).toInt()>>>0).toString(T);if((M=C).isZero())return R+F;for(;R.length<6;)R="0"+R;F=""+R+F}},S.getHighBits=function(){return this.high},S.getHighBitsUnsigned=function(){return this.high>>>0},S.getLowBits=function(){return this.low},S.getLowBitsUnsigned=function(){return this.low>>>0},S.getNumBitsAbs=function(){if(this.isNegative())return this.eq(I)?64:this.neg().getNumBitsAbs();for(var T=this.high!=0?this.high:this.low,A=31;A>0&&!(T&1<<A);A--);return this.high!=0?A+33:A+1},S.isZero=function(){return this.high===0&&this.low===0},S.eqz=S.isZero,S.isNegative=function(){return!this.unsigned&&this.high<0},S.isPositive=function(){return this.unsigned||this.high>=0},S.isOdd=function(){return(1&this.low)==1},S.isEven=function(){return(1&this.low)==0},S.equals=function(T){return n(T)||(T=s(T)),(this.unsigned===T.unsigned||this.high>>>31!=1||T.high>>>31!=1)&&this.high===T.high&&this.low===T.low},S.eq=S.equals,S.notEquals=function(T){return!this.eq(T)},S.neq=S.notEquals,S.ne=S.notEquals,S.lessThan=function(T){return this.comp(T)<0},S.lt=S.lessThan,S.lessThanOrEqual=function(T){return this.comp(T)<=0},S.lte=S.lessThanOrEqual,S.le=S.lessThanOrEqual,S.greaterThan=function(T){return this.comp(T)>0},S.gt=S.greaterThan,S.greaterThanOrEqual=function(T){return this.comp(T)>=0},S.gte=S.greaterThanOrEqual,S.ge=S.greaterThanOrEqual,S.compare=function(T){if(n(T)||(T=s(T)),this.eq(T))return 0;var A=this.isNegative(),O=T.isNegative();return A&&!O?-1:!A&&O?1:this.unsigned?T.high>>>0>this.high>>>0||T.high===this.high&&T.low>>>0>this.low>>>0?-1:1:this.sub(T).isNegative()?-1:1},S.comp=S.compare,S.negate=function(){return!this.unsigned&&this.eq(I)?I:this.not().add(w)},S.neg=S.negate,S.add=function(T){n(T)||(T=s(T));var A=this.high>>>16,O=65535&this.high,$=this.low>>>16,D=65535&this.low,M=T.high>>>16,F=65535&T.high,C=T.low>>>16,R=0,j=0,G=0,W=0;return G+=(W+=D+(65535&T.low))>>>16,j+=(G+=$+C)>>>16,R+=(j+=O+F)>>>16,R+=A+M,g((G&=65535)<<16|(W&=65535),(R&=65535)<<16|(j&=65535),this.unsigned)},S.subtract=function(T){return n(T)||(T=s(T)),this.add(T.neg())},S.sub=S.subtract,S.multiply=function(T){if(this.isZero())return b;if(n(T)||(T=s(T)),t)return g(t.mul(this.low,this.high,T.low,T.high),t.get_high(),this.unsigned);if(T.isZero())return b;if(this.eq(I))return T.isOdd()?I:b;if(T.eq(I))return this.isOdd()?I:b;if(this.isNegative())return T.isNegative()?this.neg().mul(T.neg()):this.neg().mul(T).neg();if(T.isNegative())return this.mul(T.neg()).neg();if(this.lt(m)&&T.lt(m))return f(this.toNumber()*T.toNumber(),this.unsigned);var A=this.high>>>16,O=65535&this.high,$=this.low>>>16,D=65535&this.low,M=T.high>>>16,F=65535&T.high,C=T.low>>>16,R=65535&T.low,j=0,G=0,W=0,Z=0;return W+=(Z+=D*R)>>>16,G+=(W+=$*R)>>>16,W&=65535,G+=(W+=D*C)>>>16,j+=(G+=O*R)>>>16,G&=65535,j+=(G+=$*C)>>>16,G&=65535,j+=(G+=D*F)>>>16,j+=A*R+O*C+$*F+D*M,g((W&=65535)<<16|(Z&=65535),(j&=65535)<<16|(G&=65535),this.unsigned)},S.mul=S.multiply,S.divide=function(T){if(n(T)||(T=s(T)),T.isZero())throw Error("division by zero");var A,O,$;if(t)return this.unsigned||this.high!==-2147483648||T.low!==-1||T.high!==-1?g((this.unsigned?t.div_u:t.div_s)(this.low,this.high,T.low,T.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:b;if(this.unsigned){if(T.unsigned||(T=T.toUnsigned()),T.gt(this))return y;if(T.gt(this.shru(1)))return x;$=y}else{if(this.eq(I))return T.eq(w)||T.eq(_)?I:T.eq(I)?w:(A=this.shr(1).div(T).shl(1)).eq(b)?T.isNegative()?w:_:(O=this.sub(T.mul(A)),$=A.add(O.div(T)));if(T.eq(I))return this.unsigned?y:b;if(this.isNegative())return T.isNegative()?this.neg().div(T.neg()):this.neg().div(T).neg();if(T.isNegative())return this.div(T.neg()).neg();$=b}for(O=this;O.gte(T);){A=Math.max(1,Math.floor(O.toNumber()/T.toNumber()));for(var D=Math.ceil(Math.log(A)/Math.LN2),M=D<=48?1:h(2,D-48),F=f(A),C=F.mul(T);C.isNegative()||C.gt(O);)C=(F=f(A-=M,this.unsigned)).mul(T);F.isZero()&&(F=w),$=$.add(F),O=O.sub(C)}return $},S.div=S.divide,S.modulo=function(T){return n(T)||(T=s(T)),t?g((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,T.low,T.high),t.get_high(),this.unsigned):this.sub(this.div(T).mul(T))},S.mod=S.modulo,S.rem=S.modulo,S.not=function(){return g(~this.low,~this.high,this.unsigned)},S.and=function(T){return n(T)||(T=s(T)),g(this.low&T.low,this.high&T.high,this.unsigned)},S.or=function(T){return n(T)||(T=s(T)),g(this.low|T.low,this.high|T.high,this.unsigned)},S.xor=function(T){return n(T)||(T=s(T)),g(this.low^T.low,this.high^T.high,this.unsigned)},S.shiftLeft=function(T){return n(T)&&(T=T.toInt()),(T&=63)==0?this:T<32?g(this.low<<T,this.high<<T|this.low>>>32-T,this.unsigned):g(0,this.low<<T-32,this.unsigned)},S.shl=S.shiftLeft,S.shiftRight=function(T){return n(T)&&(T=T.toInt()),(T&=63)==0?this:T<32?g(this.low>>>T|this.high<<32-T,this.high>>T,this.unsigned):g(this.high>>T-32,this.high>=0?0:-1,this.unsigned)},S.shr=S.shiftRight,S.shiftRightUnsigned=function(T){if(n(T)&&(T=T.toInt()),(T&=63)==0)return this;var A=this.high;return T<32?g(this.low>>>T|A<<32-T,A>>>T,this.unsigned):g(T===32?A:A>>>T-32,0,this.unsigned)},S.shru=S.shiftRightUnsigned,S.shr_u=S.shiftRightUnsigned,S.toSigned=function(){return this.unsigned?g(this.low,this.high,!1):this},S.toUnsigned=function(){return this.unsigned?this:g(this.low,this.high,!0)},S.toBytes=function(T){return T?this.toBytesLE():this.toBytesBE()},S.toBytesLE=function(){var T=this.high,A=this.low;return[255&A,A>>>8&255,A>>>16&255,A>>>24,255&T,T>>>8&255,T>>>16&255,T>>>24]},S.toBytesBE=function(){var T=this.high,A=this.low;return[T>>>24,T>>>16&255,T>>>8&255,255&T,A>>>24,A>>>16&255,A>>>8&255,255&A]},e.fromBytes=function(T,A,O){return O?e.fromBytesLE(T,A):e.fromBytesBE(T,A)},e.fromBytesLE=function(T,A){return new e(T[0]|T[1]<<8|T[2]<<16|T[3]<<24,T[4]|T[5]<<8|T[6]<<16|T[7]<<24,A)},e.fromBytesBE=function(T,A){return new e(T[4]<<24|T[5]<<16|T[6]<<8|T[7],T[0]<<24|T[1]<<16|T[2]<<8|T[3],A)}},1446:(o,t,e)=>{var n,a,l,c=e(2100),f=c.Reader,g=c.Writer,h=c.util,p=c.roots.default||(c.roots.default={});p.onnx=((l={}).Version=(n={},(a=Object.create(n))[n[0]="_START_VERSION"]=0,a[n[1]="IR_VERSION_2017_10_10"]=1,a[n[2]="IR_VERSION_2017_10_30"]=2,a[n[3]="IR_VERSION_2017_11_3"]=3,a[n[4]="IR_VERSION_2019_1_22"]=4,a[n[5]="IR_VERSION"]=5,a),l.AttributeProto=function(){function s(r){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],r)for(var u=Object.keys(r),d=0;d<u.length;++d)r[u[d]]!=null&&(this[u[d]]=r[u[d]])}return s.prototype.name="",s.prototype.refAttrName="",s.prototype.docString="",s.prototype.type=0,s.prototype.f=0,s.prototype.i=h.Long?h.Long.fromBits(0,0,!1):0,s.prototype.s=h.newBuffer([]),s.prototype.t=null,s.prototype.g=null,s.prototype.floats=h.emptyArray,s.prototype.ints=h.emptyArray,s.prototype.strings=h.emptyArray,s.prototype.tensors=h.emptyArray,s.prototype.graphs=h.emptyArray,s.create=function(r){return new s(r)},s.encode=function(r,u){if(u||(u=g.create()),r.name!=null&&r.hasOwnProperty("name")&&u.uint32(10).string(r.name),r.f!=null&&r.hasOwnProperty("f")&&u.uint32(21).float(r.f),r.i!=null&&r.hasOwnProperty("i")&&u.uint32(24).int64(r.i),r.s!=null&&r.hasOwnProperty("s")&&u.uint32(34).bytes(r.s),r.t!=null&&r.hasOwnProperty("t")&&p.onnx.TensorProto.encode(r.t,u.uint32(42).fork()).ldelim(),r.g!=null&&r.hasOwnProperty("g")&&p.onnx.GraphProto.encode(r.g,u.uint32(50).fork()).ldelim(),r.floats!=null&&r.floats.length){u.uint32(58).fork();for(var d=0;d<r.floats.length;++d)u.float(r.floats[d]);u.ldelim()}if(r.ints!=null&&r.ints.length){for(u.uint32(66).fork(),d=0;d<r.ints.length;++d)u.int64(r.ints[d]);u.ldelim()}if(r.strings!=null&&r.strings.length)for(d=0;d<r.strings.length;++d)u.uint32(74).bytes(r.strings[d]);if(r.tensors!=null&&r.tensors.length)for(d=0;d<r.tensors.length;++d)p.onnx.TensorProto.encode(r.tensors[d],u.uint32(82).fork()).ldelim();if(r.graphs!=null&&r.graphs.length)for(d=0;d<r.graphs.length;++d)p.onnx.GraphProto.encode(r.graphs[d],u.uint32(90).fork()).ldelim();return r.docString!=null&&r.hasOwnProperty("docString")&&u.uint32(106).string(r.docString),r.type!=null&&r.hasOwnProperty("type")&&u.uint32(160).int32(r.type),r.refAttrName!=null&&r.hasOwnProperty("refAttrName")&&u.uint32(170).string(r.refAttrName),u},s.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},s.decode=function(r,u){r instanceof f||(r=f.create(r));for(var d=u===void 0?r.len:r.pos+u,m=new p.onnx.AttributeProto;r.pos<d;){var b=r.uint32();switch(b>>>3){case 1:m.name=r.string();break;case 21:m.refAttrName=r.string();break;case 13:m.docString=r.string();break;case 20:m.type=r.int32();break;case 2:m.f=r.float();break;case 3:m.i=r.int64();break;case 4:m.s=r.bytes();break;case 5:m.t=p.onnx.TensorProto.decode(r,r.uint32());break;case 6:m.g=p.onnx.GraphProto.decode(r,r.uint32());break;case 7:if(m.floats&&m.floats.length||(m.floats=[]),(7&b)==2)for(var y=r.uint32()+r.pos;r.pos<y;)m.floats.push(r.float());else m.floats.push(r.float());break;case 8:if(m.ints&&m.ints.length||(m.ints=[]),(7&b)==2)for(y=r.uint32()+r.pos;r.pos<y;)m.ints.push(r.int64());else m.ints.push(r.int64());break;case 9:m.strings&&m.strings.length||(m.strings=[]),m.strings.push(r.bytes());break;case 10:m.tensors&&m.tensors.length||(m.tensors=[]),m.tensors.push(p.onnx.TensorProto.decode(r,r.uint32()));break;case 11:m.graphs&&m.graphs.length||(m.graphs=[]),m.graphs.push(p.onnx.GraphProto.decode(r,r.uint32()));break;default:r.skipType(7&b)}}return m},s.decodeDelimited=function(r){return r instanceof f||(r=new f(r)),this.decode(r,r.uint32())},s.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.name!=null&&r.hasOwnProperty("name")&&!h.isString(r.name))return"name: string expected";if(r.refAttrName!=null&&r.hasOwnProperty("refAttrName")&&!h.isString(r.refAttrName))return"refAttrName: string expected";if(r.docString!=null&&r.hasOwnProperty("docString")&&!h.isString(r.docString))return"docString: string expected";if(r.type!=null&&r.hasOwnProperty("type"))switch(r.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(r.f!=null&&r.hasOwnProperty("f")&&typeof r.f!="number")return"f: number expected";if(r.i!=null&&r.hasOwnProperty("i")&&!(h.isInteger(r.i)||r.i&&h.isInteger(r.i.low)&&h.isInteger(r.i.high)))return"i: integer|Long expected";if(r.s!=null&&r.hasOwnProperty("s")&&!(r.s&&typeof r.s.length=="number"||h.isString(r.s)))return"s: buffer expected";if(r.t!=null&&r.hasOwnProperty("t")&&(d=p.onnx.TensorProto.verify(r.t)))return"t."+d;if(r.g!=null&&r.hasOwnProperty("g")&&(d=p.onnx.GraphProto.verify(r.g)))return"g."+d;if(r.floats!=null&&r.hasOwnProperty("floats")){if(!Array.isArray(r.floats))return"floats: array expected";for(var u=0;u<r.floats.length;++u)if(typeof r.floats[u]!="number")return"floats: number[] expected"}if(r.ints!=null&&r.hasOwnProperty("ints")){if(!Array.isArray(r.ints))return"ints: array expected";for(u=0;u<r.ints.length;++u)if(!(h.isInteger(r.ints[u])||r.ints[u]&&h.isInteger(r.ints[u].low)&&h.isInteger(r.ints[u].high)))return"ints: integer|Long[] expected"}if(r.strings!=null&&r.hasOwnProperty("strings")){if(!Array.isArray(r.strings))return"strings: array expected";for(u=0;u<r.strings.length;++u)if(!(r.strings[u]&&typeof r.strings[u].length=="number"||h.isString(r.strings[u])))return"strings: buffer[] expected"}if(r.tensors!=null&&r.hasOwnProperty("tensors")){if(!Array.isArray(r.tensors))return"tensors: array expected";for(u=0;u<r.tensors.length;++u)if(d=p.onnx.TensorProto.verify(r.tensors[u]))return"tensors."+d}if(r.graphs!=null&&r.hasOwnProperty("graphs")){if(!Array.isArray(r.graphs))return"graphs: array expected";for(u=0;u<r.graphs.length;++u){var d;if(d=p.onnx.GraphProto.verify(r.graphs[u]))return"graphs."+d}}return null},s.fromObject=function(r){if(r instanceof p.onnx.AttributeProto)return r;var u=new p.onnx.AttributeProto;switch(r.name!=null&&(u.name=String(r.name)),r.refAttrName!=null&&(u.refAttrName=String(r.refAttrName)),r.docString!=null&&(u.docString=String(r.docString)),r.type){case"UNDEFINED":case 0:u.type=0;break;case"FLOAT":case 1:u.type=1;break;case"INT":case 2:u.type=2;break;case"STRING":case 3:u.type=3;break;case"TENSOR":case 4:u.type=4;break;case"GRAPH":case 5:u.type=5;break;case"FLOATS":case 6:u.type=6;break;case"INTS":case 7:u.type=7;break;case"STRINGS":case 8:u.type=8;break;case"TENSORS":case 9:u.type=9;break;case"GRAPHS":case 10:u.type=10}if(r.f!=null&&(u.f=Number(r.f)),r.i!=null&&(h.Long?(u.i=h.Long.fromValue(r.i)).unsigned=!1:typeof r.i=="string"?u.i=parseInt(r.i,10):typeof r.i=="number"?u.i=r.i:typeof r.i=="object"&&(u.i=new h.LongBits(r.i.low>>>0,r.i.high>>>0).toNumber())),r.s!=null&&(typeof r.s=="string"?h.base64.decode(r.s,u.s=h.newBuffer(h.base64.length(r.s)),0):r.s.length&&(u.s=r.s)),r.t!=null){if(typeof r.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");u.t=p.onnx.TensorProto.fromObject(r.t)}if(r.g!=null){if(typeof r.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");u.g=p.onnx.GraphProto.fromObject(r.g)}if(r.floats){if(!Array.isArray(r.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");u.floats=[];for(var d=0;d<r.floats.length;++d)u.floats[d]=Number(r.floats[d])}if(r.ints){if(!Array.isArray(r.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(u.ints=[],d=0;d<r.ints.length;++d)h.Long?(u.ints[d]=h.Long.fromValue(r.ints[d])).unsigned=!1:typeof r.ints[d]=="string"?u.ints[d]=parseInt(r.ints[d],10):typeof r.ints[d]=="number"?u.ints[d]=r.ints[d]:typeof r.ints[d]=="object"&&(u.ints[d]=new h.LongBits(r.ints[d].low>>>0,r.ints[d].high>>>0).toNumber())}if(r.strings){if(!Array.isArray(r.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(u.strings=[],d=0;d<r.strings.length;++d)typeof r.strings[d]=="string"?h.base64.decode(r.strings[d],u.strings[d]=h.newBuffer(h.base64.length(r.strings[d])),0):r.strings[d].length&&(u.strings[d]=r.strings[d])}if(r.tensors){if(!Array.isArray(r.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(u.tensors=[],d=0;d<r.tensors.length;++d){if(typeof r.tensors[d]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");u.tensors[d]=p.onnx.TensorProto.fromObject(r.tensors[d])}}if(r.graphs){if(!Array.isArray(r.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(u.graphs=[],d=0;d<r.graphs.length;++d){if(typeof r.graphs[d]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");u.graphs[d]=p.onnx.GraphProto.fromObject(r.graphs[d])}}return u},s.toObject=function(r,u){u||(u={});var d={};if((u.arrays||u.defaults)&&(d.floats=[],d.ints=[],d.strings=[],d.tensors=[],d.graphs=[]),u.defaults){if(d.name="",d.f=0,h.Long){var m=new h.Long(0,0,!1);d.i=u.longs===String?m.toString():u.longs===Number?m.toNumber():m}else d.i=u.longs===String?"0":0;u.bytes===String?d.s="":(d.s=[],u.bytes!==Array&&(d.s=h.newBuffer(d.s))),d.t=null,d.g=null,d.docString="",d.type=u.enums===String?"UNDEFINED":0,d.refAttrName=""}if(r.name!=null&&r.hasOwnProperty("name")&&(d.name=r.name),r.f!=null&&r.hasOwnProperty("f")&&(d.f=u.json&&!isFinite(r.f)?String(r.f):r.f),r.i!=null&&r.hasOwnProperty("i")&&(typeof r.i=="number"?d.i=u.longs===String?String(r.i):r.i:d.i=u.longs===String?h.Long.prototype.toString.call(r.i):u.longs===Number?new h.LongBits(r.i.low>>>0,r.i.high>>>0).toNumber():r.i),r.s!=null&&r.hasOwnProperty("s")&&(d.s=u.bytes===String?h.base64.encode(r.s,0,r.s.length):u.bytes===Array?Array.prototype.slice.call(r.s):r.s),r.t!=null&&r.hasOwnProperty("t")&&(d.t=p.onnx.TensorProto.toObject(r.t,u)),r.g!=null&&r.hasOwnProperty("g")&&(d.g=p.onnx.GraphProto.toObject(r.g,u)),r.floats&&r.floats.length){d.floats=[];for(var b=0;b<r.floats.length;++b)d.floats[b]=u.json&&!isFinite(r.floats[b])?String(r.floats[b]):r.floats[b]}if(r.ints&&r.ints.length)for(d.ints=[],b=0;b<r.ints.length;++b)typeof r.ints[b]=="number"?d.ints[b]=u.longs===String?String(r.ints[b]):r.ints[b]:d.ints[b]=u.longs===String?h.Long.prototype.toString.call(r.ints[b]):u.longs===Number?new h.LongBits(r.ints[b].low>>>0,r.ints[b].high>>>0).toNumber():r.ints[b];if(r.strings&&r.strings.length)for(d.strings=[],b=0;b<r.strings.length;++b)d.strings[b]=u.bytes===String?h.base64.encode(r.strings[b],0,r.strings[b].length):u.bytes===Array?Array.prototype.slice.call(r.strings[b]):r.strings[b];if(r.tensors&&r.tensors.length)for(d.tensors=[],b=0;b<r.tensors.length;++b)d.tensors[b]=p.onnx.TensorProto.toObject(r.tensors[b],u);if(r.graphs&&r.graphs.length)for(d.graphs=[],b=0;b<r.graphs.length;++b)d.graphs[b]=p.onnx.GraphProto.toObject(r.graphs[b],u);return r.docString!=null&&r.hasOwnProperty("docString")&&(d.docString=r.docString),r.type!=null&&r.hasOwnProperty("type")&&(d.type=u.enums===String?p.onnx.AttributeProto.AttributeType[r.type]:r.type),r.refAttrName!=null&&r.hasOwnProperty("refAttrName")&&(d.refAttrName=r.refAttrName),d},s.prototype.toJSON=function(){return this.constructor.toObject(this,c.util.toJSONOptions)},s.AttributeType=function(){var r={},u=Object.create(r);return u[r[0]="UNDEFINED"]=0,u[r[1]="FLOAT"]=1,u[r[2]="INT"]=2,u[r[3]="STRING"]=3,u[r[4]="TENSOR"]=4,u[r[5]="GRAPH"]=5,u[r[6]="FLOATS"]=6,u[r[7]="INTS"]=7,u[r[8]="STRINGS"]=8,u[r[9]="TENSORS"]=9,u[r[10]="GRAPHS"]=10,u}(),s}(),l.ValueInfoProto=function(){function s(r){if(r)for(var u=Object.keys(r),d=0;d<u.length;++d)r[u[d]]!=null&&(this[u[d]]=r[u[d]])}return s.prototype.name="",s.prototype.type=null,s.prototype.docString="",s.create=function(r){return new s(r)},s.encode=function(r,u){return u||(u=g.create()),r.name!=null&&r.hasOwnProperty("name")&&u.uint32(10).string(r.name),r.type!=null&&r.hasOwnProperty("type")&&p.onnx.TypeProto.encode(r.type,u.uint32(18).fork()).ldelim(),r.docString!=null&&r.hasOwnProperty("docString")&&u.uint32(26).string(r.docString),u},s.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},s.decode=function(r,u){r instanceof f||(r=f.create(r));for(var d=u===void 0?r.len:r.pos+u,m=new p.onnx.ValueInfoProto;r.pos<d;){var b=r.uint32();switch(b>>>3){case 1:m.name=r.string();break;case 2:m.type=p.onnx.TypeProto.decode(r,r.uint32());break;case 3:m.docString=r.string();break;default:r.skipType(7&b)}}return m},s.decodeDelimited=function(r){return r instanceof f||(r=new f(r)),this.decode(r,r.uint32())},s.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.name!=null&&r.hasOwnProperty("name")&&!h.isString(r.name))return"name: string expected";if(r.type!=null&&r.hasOwnProperty("type")){var u=p.onnx.TypeProto.verify(r.type);if(u)return"type."+u}return r.docString!=null&&r.hasOwnProperty("docString")&&!h.isString(r.docString)?"docString: string expected":null},s.fromObject=function(r){if(r instanceof p.onnx.ValueInfoProto)return r;var u=new p.onnx.ValueInfoProto;if(r.name!=null&&(u.name=String(r.name)),r.type!=null){if(typeof r.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");u.type=p.onnx.TypeProto.fromObject(r.type)}return r.docString!=null&&(u.docString=String(r.docString)),u},s.toObject=function(r,u){u||(u={});var d={};return u.defaults&&(d.name="",d.type=null,d.docString=""),r.name!=null&&r.hasOwnProperty("name")&&(d.name=r.name),r.type!=null&&r.hasOwnProperty("type")&&(d.type=p.onnx.TypeProto.toObject(r.type,u)),r.docString!=null&&r.hasOwnProperty("docString")&&(d.docString=r.docString),d},s.prototype.toJSON=function(){return this.constructor.toObject(this,c.util.toJSONOptions)},s}(),l.NodeProto=function(){function s(r){if(this.input=[],this.output=[],this.attribute=[],r)for(var u=Object.keys(r),d=0;d<u.length;++d)r[u[d]]!=null&&(this[u[d]]=r[u[d]])}return s.prototype.input=h.emptyArray,s.prototype.output=h.emptyArray,s.prototype.name="",s.prototype.opType="",s.prototype.domain="",s.prototype.attribute=h.emptyArray,s.prototype.docString="",s.create=function(r){return new s(r)},s.encode=function(r,u){if(u||(u=g.create()),r.input!=null&&r.input.length)for(var d=0;d<r.input.length;++d)u.uint32(10).string(r.input[d]);if(r.output!=null&&r.output.length)for(d=0;d<r.output.length;++d)u.uint32(18).string(r.output[d]);if(r.name!=null&&r.hasOwnProperty("name")&&u.uint32(26).string(r.name),r.opType!=null&&r.hasOwnProperty("opType")&&u.uint32(34).string(r.opType),r.attribute!=null&&r.attribute.length)for(d=0;d<r.attribute.length;++d)p.onnx.AttributeProto.encode(r.attribute[d],u.uint32(42).fork()).ldelim();return r.docString!=null&&r.hasOwnProperty("docString")&&u.uint32(50).string(r.docString),r.domain!=null&&r.hasOwnProperty("domain")&&u.uint32(58).string(r.domain),u},s.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},s.decode=function(r,u){r instanceof f||(r=f.create(r));for(var d=u===void 0?r.len:r.pos+u,m=new p.onnx.NodeProto;r.pos<d;){var b=r.uint32();switch(b>>>3){case 1:m.input&&m.input.length||(m.input=[]),m.input.push(r.string());break;case 2:m.output&&m.output.length||(m.output=[]),m.output.push(r.string());break;case 3:m.name=r.string();break;case 4:m.opType=r.string();break;case 7:m.domain=r.string();break;case 5:m.attribute&&m.attribute.length||(m.attribute=[]),m.attribute.push(p.onnx.AttributeProto.decode(r,r.uint32()));break;case 6:m.docString=r.string();break;default:r.skipType(7&b)}}return m},s.decodeDelimited=function(r){return r instanceof f||(r=new f(r)),this.decode(r,r.uint32())},s.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.input!=null&&r.hasOwnProperty("input")){if(!Array.isArray(r.input))return"input: array expected";for(var u=0;u<r.input.length;++u)if(!h.isString(r.input[u]))return"input: string[] expected"}if(r.output!=null&&r.hasOwnProperty("output")){if(!Array.isArray(r.output))return"output: array expected";for(u=0;u<r.output.length;++u)if(!h.isString(r.output[u]))return"output: string[] expected"}if(r.name!=null&&r.hasOwnProperty("name")&&!h.isString(r.name))return"name: string expected";if(r.opType!=null&&r.hasOwnProperty("opType")&&!h.isString(r.opType))return"opType: string expected";if(r.domain!=null&&r.hasOwnProperty("domain")&&!h.isString(r.domain))return"domain: string expected";if(r.attribute!=null&&r.hasOwnProperty("attribute")){if(!Array.isArray(r.attribute))return"attribute: array expected";for(u=0;u<r.attribute.length;++u){var d=p.onnx.AttributeProto.verify(r.attribute[u]);if(d)return"attribute."+d}}return r.docString!=null&&r.hasOwnProperty("docString")&&!h.isString(r.docString)?"docString: string expected":null},s.fromObject=function(r){if(r instanceof p.onnx.NodeProto)return r;var u=new p.onnx.NodeProto;if(r.input){if(!Array.isArray(r.input))throw TypeError(".onnx.NodeProto.input: array expected");u.input=[];for(var d=0;d<r.input.length;++d)u.input[d]=String(r.input[d])}if(r.output){if(!Array.isArray(r.output))throw TypeError(".onnx.NodeProto.output: array expected");for(u.output=[],d=0;d<r.output.length;++d)u.output[d]=String(r.output[d])}if(r.name!=null&&(u.name=String(r.name)),r.opType!=null&&(u.opType=String(r.opType)),r.domain!=null&&(u.domain=String(r.domain)),r.attribute){if(!Array.isArray(r.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(u.attribute=[],d=0;d<r.attribute.length;++d){if(typeof r.attribute[d]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");u.attribute[d]=p.onnx.AttributeProto.fromObject(r.attribute[d])}}return r.docString!=null&&(u.docString=String(r.docString)),u},s.toObject=function(r,u){u||(u={});var d={};if((u.arrays||u.defaults)&&(d.input=[],d.output=[],d.attribute=[]),u.defaults&&(d.name="",d.opType="",d.docString="",d.domain=""),r.input&&r.input.length){d.input=[];for(var m=0;m<r.input.length;++m)d.input[m]=r.input[m]}if(r.output&&r.output.length)for(d.output=[],m=0;m<r.output.length;++m)d.output[m]=r.output[m];if(r.name!=null&&r.hasOwnProperty("name")&&(d.name=r.name),r.opType!=null&&r.hasOwnProperty("opType")&&(d.opType=r.opType),r.attribute&&r.attribute.length)for(d.attribute=[],m=0;m<r.attribute.length;++m)d.attribute[m]=p.onnx.AttributeProto.toObject(r.attribute[m],u);return r.docString!=null&&r.hasOwnProperty("docString")&&(d.docString=r.docString),r.domain!=null&&r.hasOwnProperty("domain")&&(d.domain=r.domain),d},s.prototype.toJSON=function(){return this.constructor.toObject(this,c.util.toJSONOptions)},s}(),l.ModelProto=function(){function s(r){if(this.opsetImport=[],this.metadataProps=[],r)for(var u=Object.keys(r),d=0;d<u.length;++d)r[u[d]]!=null&&(this[u[d]]=r[u[d]])}return s.prototype.irVersion=h.Long?h.Long.fromBits(0,0,!1):0,s.prototype.opsetImport=h.emptyArray,s.prototype.producerName="",s.prototype.producerVersion="",s.prototype.domain="",s.prototype.modelVersion=h.Long?h.Long.fromBits(0,0,!1):0,s.prototype.docString="",s.prototype.graph=null,s.prototype.metadataProps=h.emptyArray,s.create=function(r){return new s(r)},s.encode=function(r,u){if(u||(u=g.create()),r.irVersion!=null&&r.hasOwnProperty("irVersion")&&u.uint32(8).int64(r.irVersion),r.producerName!=null&&r.hasOwnProperty("producerName")&&u.uint32(18).string(r.producerName),r.producerVersion!=null&&r.hasOwnProperty("producerVersion")&&u.uint32(26).string(r.producerVersion),r.domain!=null&&r.hasOwnProperty("domain")&&u.uint32(34).string(r.domain),r.modelVersion!=null&&r.hasOwnProperty("modelVersion")&&u.uint32(40).int64(r.modelVersion),r.docString!=null&&r.hasOwnProperty("docString")&&u.uint32(50).string(r.docString),r.graph!=null&&r.hasOwnProperty("graph")&&p.onnx.GraphProto.encode(r.graph,u.uint32(58).fork()).ldelim(),r.opsetImport!=null&&r.opsetImport.length)for(var d=0;d<r.opsetImport.length;++d)p.onnx.OperatorSetIdProto.encode(r.opsetImport[d],u.uint32(66).fork()).ldelim();if(r.metadataProps!=null&&r.metadataProps.length)for(d=0;d<r.metadataProps.length;++d)p.onnx.StringStringEntryProto.encode(r.metadataProps[d],u.uint32(114).fork()).ldelim();return u},s.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},s.decode=function(r,u){r instanceof f||(r=f.create(r));for(var d=u===void 0?r.len:r.pos+u,m=new p.onnx.ModelProto;r.pos<d;){var b=r.uint32();switch(b>>>3){case 1:m.irVersion=r.int64();break;case 8:m.opsetImport&&m.opsetImport.length||(m.opsetImport=[]),m.opsetImport.push(p.onnx.OperatorSetIdProto.decode(r,r.uint32()));break;case 2:m.producerName=r.string();break;case 3:m.producerVersion=r.string();break;case 4:m.domain=r.string();break;case 5:m.modelVersion=r.int64();break;case 6:m.docString=r.string();break;case 7:m.graph=p.onnx.GraphProto.decode(r,r.uint32());break;case 14:m.metadataProps&&m.metadataProps.length||(m.metadataProps=[]),m.metadataProps.push(p.onnx.StringStringEntryProto.decode(r,r.uint32()));break;default:r.skipType(7&b)}}return m},s.decodeDelimited=function(r){return r instanceof f||(r=new f(r)),this.decode(r,r.uint32())},s.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.irVersion!=null&&r.hasOwnProperty("irVersion")&&!(h.isInteger(r.irVersion)||r.irVersion&&h.isInteger(r.irVersion.low)&&h.isInteger(r.irVersion.high)))return"irVersion: integer|Long expected";if(r.opsetImport!=null&&r.hasOwnProperty("opsetImport")){if(!Array.isArray(r.opsetImport))return"opsetImport: array expected";for(var u=0;u<r.opsetImport.length;++u)if(d=p.onnx.OperatorSetIdProto.verify(r.opsetImport[u]))return"opsetImport."+d}if(r.producerName!=null&&r.hasOwnProperty("producerName")&&!h.isString(r.producerName))return"producerName: string expected";if(r.producerVersion!=null&&r.hasOwnProperty("producerVersion")&&!h.isString(r.producerVersion))return"producerVersion: string expected";if(r.domain!=null&&r.hasOwnProperty("domain")&&!h.isString(r.domain))return"domain: string expected";if(r.modelVersion!=null&&r.hasOwnProperty("modelVersion")&&!(h.isInteger(r.modelVersion)||r.modelVersion&&h.isInteger(r.modelVersion.low)&&h.isInteger(r.modelVersion.high)))return"modelVersion: integer|Long expected";if(r.docString!=null&&r.hasOwnProperty("docString")&&!h.isString(r.docString))return"docString: string expected";if(r.graph!=null&&r.hasOwnProperty("graph")&&(d=p.onnx.GraphProto.verify(r.graph)))return"graph."+d;if(r.metadataProps!=null&&r.hasOwnProperty("metadataProps")){if(!Array.isArray(r.metadataProps))return"metadataProps: array expected";for(u=0;u<r.metadataProps.length;++u){var d;if(d=p.onnx.StringStringEntryProto.verify(r.metadataProps[u]))return"metadataProps."+d}}return null},s.fromObject=function(r){if(r instanceof p.onnx.ModelProto)return r;var u=new p.onnx.ModelProto;if(r.irVersion!=null&&(h.Long?(u.irVersion=h.Long.fromValue(r.irVersion)).unsigned=!1:typeof r.irVersion=="string"?u.irVersion=parseInt(r.irVersion,10):typeof r.irVersion=="number"?u.irVersion=r.irVersion:typeof r.irVersion=="object"&&(u.irVersion=new h.LongBits(r.irVersion.low>>>0,r.irVersion.high>>>0).toNumber())),r.opsetImport){if(!Array.isArray(r.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");u.opsetImport=[];for(var d=0;d<r.opsetImport.length;++d){if(typeof r.opsetImport[d]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");u.opsetImport[d]=p.onnx.OperatorSetIdProto.fromObject(r.opsetImport[d])}}if(r.producerName!=null&&(u.producerName=String(r.producerName)),r.producerVersion!=null&&(u.producerVersion=String(r.producerVersion)),r.domain!=null&&(u.domain=String(r.domain)),r.modelVersion!=null&&(h.Long?(u.modelVersion=h.Long.fromValue(r.modelVersion)).unsigned=!1:typeof r.modelVersion=="string"?u.modelVersion=parseInt(r.modelVersion,10):typeof r.modelVersion=="number"?u.modelVersion=r.modelVersion:typeof r.modelVersion=="object"&&(u.modelVersion=new h.LongBits(r.modelVersion.low>>>0,r.modelVersion.high>>>0).toNumber())),r.docString!=null&&(u.docString=String(r.docString)),r.graph!=null){if(typeof r.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");u.graph=p.onnx.GraphProto.fromObject(r.graph)}if(r.metadataProps){if(!Array.isArray(r.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(u.metadataProps=[],d=0;d<r.metadataProps.length;++d){if(typeof r.metadataProps[d]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");u.metadataProps[d]=p.onnx.StringStringEntryProto.fromObject(r.metadataProps[d])}}return u},s.toObject=function(r,u){u||(u={});var d={};if((u.arrays||u.defaults)&&(d.opsetImport=[],d.metadataProps=[]),u.defaults){if(h.Long){var m=new h.Long(0,0,!1);d.irVersion=u.longs===String?m.toString():u.longs===Number?m.toNumber():m}else d.irVersion=u.longs===String?"0":0;d.producerName="",d.producerVersion="",d.domain="",h.Long?(m=new h.Long(0,0,!1),d.modelVersion=u.longs===String?m.toString():u.longs===Number?m.toNumber():m):d.modelVersion=u.longs===String?"0":0,d.docString="",d.graph=null}if(r.irVersion!=null&&r.hasOwnProperty("irVersion")&&(typeof r.irVersion=="number"?d.irVersion=u.longs===String?String(r.irVersion):r.irVersion:d.irVersion=u.longs===String?h.Long.prototype.toString.call(r.irVersion):u.longs===Number?new h.LongBits(r.irVersion.low>>>0,r.irVersion.high>>>0).toNumber():r.irVersion),r.producerName!=null&&r.hasOwnProperty("producerName")&&(d.producerName=r.producerName),r.producerVersion!=null&&r.hasOwnProperty("producerVersion")&&(d.producerVersion=r.producerVersion),r.domain!=null&&r.hasOwnProperty("domain")&&(d.domain=r.domain),r.modelVersion!=null&&r.hasOwnProperty("modelVersion")&&(typeof r.modelVersion=="number"?d.modelVersion=u.longs===String?String(r.modelVersion):r.modelVersion:d.modelVersion=u.longs===String?h.Long.prototype.toString.call(r.modelVersion):u.longs===Number?new h.LongBits(r.modelVersion.low>>>0,r.modelVersion.high>>>0).toNumber():r.modelVersion),r.docString!=null&&r.hasOwnProperty("docString")&&(d.docString=r.docString),r.graph!=null&&r.hasOwnProperty("graph")&&(d.graph=p.onnx.GraphProto.toObject(r.graph,u)),r.opsetImport&&r.opsetImport.length){d.opsetImport=[];for(var b=0;b<r.opsetImport.length;++b)d.opsetImport[b]=p.onnx.OperatorSetIdProto.toObject(r.opsetImport[b],u)}if(r.metadataProps&&r.metadataProps.length)for(d.metadataProps=[],b=0;b<r.metadataProps.length;++b)d.metadataProps[b]=p.onnx.StringStringEntryProto.toObject(r.metadataProps[b],u);return d},s.prototype.toJSON=function(){return this.constructor.toObject(this,c.util.toJSONOptions)},s}(),l.StringStringEntryProto=function(){function s(r){if(r)for(var u=Object.keys(r),d=0;d<u.length;++d)r[u[d]]!=null&&(this[u[d]]=r[u[d]])}return s.prototype.key="",s.prototype.value="",s.create=function(r){return new s(r)},s.encode=function(r,u){return u||(u=g.create()),r.key!=null&&r.hasOwnProperty("key")&&u.uint32(10).string(r.key),r.value!=null&&r.hasOwnProperty("value")&&u.uint32(18).string(r.value),u},s.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},s.decode=function(r,u){r instanceof f||(r=f.create(r));for(var d=u===void 0?r.len:r.pos+u,m=new p.onnx.StringStringEntryProto;r.pos<d;){var b=r.uint32();switch(b>>>3){case 1:m.key=r.string();break;case 2:m.value=r.string();break;default:r.skipType(7&b)}}return m},s.decodeDelimited=function(r){return r instanceof f||(r=new f(r)),this.decode(r,r.uint32())},s.verify=function(r){return typeof r!="object"||r===null?"object expected":r.key!=null&&r.hasOwnProperty("key")&&!h.isString(r.key)?"key: string expected":r.value!=null&&r.hasOwnProperty("value")&&!h.isString(r.value)?"value: string expected":null},s.fromObject=function(r){if(r instanceof p.onnx.StringStringEntryProto)return r;var u=new p.onnx.StringStringEntryProto;return r.key!=null&&(u.key=String(r.key)),r.value!=null&&(u.value=String(r.value)),u},s.toObject=function(r,u){u||(u={});var d={};return u.defaults&&(d.key="",d.value=""),r.key!=null&&r.hasOwnProperty("key")&&(d.key=r.key),r.value!=null&&r.hasOwnProperty("value")&&(d.value=r.value),d},s.prototype.toJSON=function(){return this.constructor.toObject(this,c.util.toJSONOptions)},s}(),l.TensorAnnotation=function(){function s(r){if(this.quantParameterTensorNames=[],r)for(var u=Object.keys(r),d=0;d<u.length;++d)r[u[d]]!=null&&(this[u[d]]=r[u[d]])}return s.prototype.tensorName="",s.prototype.quantParameterTensorNames=h.emptyArray,s.create=function(r){return new s(r)},s.encode=function(r,u){if(u||(u=g.create()),r.tensorName!=null&&r.hasOwnProperty("tensorName")&&u.uint32(10).string(r.tensorName),r.quantParameterTensorNames!=null&&r.quantParameterTensorNames.length)for(var d=0;d<r.quantParameterTensorNames.length;++d)p.onnx.StringStringEntryProto.encode(r.quantParameterTensorNames[d],u.uint32(18).fork()).ldelim();return u},s.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},s.decode=function(r,u){r instanceof f||(r=f.create(r));for(var d=u===void 0?r.len:r.pos+u,m=new p.onnx.TensorAnnotation;r.pos<d;){var b=r.uint32();switch(b>>>3){case 1:m.tensorName=r.string();break;case 2:m.quantParameterTensorNames&&m.quantParameterTensorNames.length||(m.quantParameterTensorNames=[]),m.quantParameterTensorNames.push(p.onnx.StringStringEntryProto.decode(r,r.uint32()));break;default:r.skipType(7&b)}}return m},s.decodeDelimited=function(r){return r instanceof f||(r=new f(r)),this.decode(r,r.uint32())},s.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.tensorName!=null&&r.hasOwnProperty("tensorName")&&!h.isString(r.tensorName))return"tensorName: string expected";if(r.quantParameterTensorNames!=null&&r.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(r.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var u=0;u<r.quantParameterTensorNames.length;++u){var d=p.onnx.StringStringEntryProto.verify(r.quantParameterTensorNames[u]);if(d)return"quantParameterTensorNames."+d}}return null},s.fromObject=function(r){if(r instanceof p.onnx.TensorAnnotation)return r;var u=new p.onnx.TensorAnnotation;if(r.tensorName!=null&&(u.tensorName=String(r.tensorName)),r.quantParameterTensorNames){if(!Array.isArray(r.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");u.quantParameterTensorNames=[];for(var d=0;d<r.quantParameterTensorNames.length;++d){if(typeof r.quantParameterTensorNames[d]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");u.quantParameterTensorNames[d]=p.onnx.StringStringEntryProto.fromObject(r.quantParameterTensorNames[d])}}return u},s.toObject=function(r,u){u||(u={});var d={};if((u.arrays||u.defaults)&&(d.quantParameterTensorNames=[]),u.defaults&&(d.tensorName=""),r.tensorName!=null&&r.hasOwnProperty("tensorName")&&(d.tensorName=r.tensorName),r.quantParameterTensorNames&&r.quantParameterTensorNames.length){d.quantParameterTensorNames=[];for(var m=0;m<r.quantParameterTensorNames.length;++m)d.quantParameterTensorNames[m]=p.onnx.StringStringEntryProto.toObject(r.quantParameterTensorNames[m],u)}return d},s.prototype.toJSON=function(){return this.constructor.toObject(this,c.util.toJSONOptions)},s}(),l.GraphProto=function(){function s(r){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],r)for(var u=Object.keys(r),d=0;d<u.length;++d)r[u[d]]!=null&&(this[u[d]]=r[u[d]])}return s.prototype.node=h.emptyArray,s.prototype.name="",s.prototype.initializer=h.emptyArray,s.prototype.docString="",s.prototype.input=h.emptyArray,s.prototype.output=h.emptyArray,s.prototype.valueInfo=h.emptyArray,s.prototype.quantizationAnnotation=h.emptyArray,s.create=function(r){return new s(r)},s.encode=function(r,u){if(u||(u=g.create()),r.node!=null&&r.node.length)for(var d=0;d<r.node.length;++d)p.onnx.NodeProto.encode(r.node[d],u.uint32(10).fork()).ldelim();if(r.name!=null&&r.hasOwnProperty("name")&&u.uint32(18).string(r.name),r.initializer!=null&&r.initializer.length)for(d=0;d<r.initializer.length;++d)p.onnx.TensorProto.encode(r.initializer[d],u.uint32(42).fork()).ldelim();if(r.docString!=null&&r.hasOwnProperty("docString")&&u.uint32(82).string(r.docString),r.input!=null&&r.input.length)for(d=0;d<r.input.length;++d)p.onnx.ValueInfoProto.encode(r.input[d],u.uint32(90).fork()).ldelim();if(r.output!=null&&r.output.length)for(d=0;d<r.output.length;++d)p.onnx.ValueInfoProto.encode(r.output[d],u.uint32(98).fork()).ldelim();if(r.valueInfo!=null&&r.valueInfo.length)for(d=0;d<r.valueInfo.length;++d)p.onnx.ValueInfoProto.encode(r.valueInfo[d],u.uint32(106).fork()).ldelim();if(r.quantizationAnnotation!=null&&r.quantizationAnnotation.length)for(d=0;d<r.quantizationAnnotation.length;++d)p.onnx.TensorAnnotation.encode(r.quantizationAnnotation[d],u.uint32(114).fork()).ldelim();return u},s.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},s.decode=function(r,u){r instanceof f||(r=f.create(r));for(var d=u===void 0?r.len:r.pos+u,m=new p.onnx.GraphProto;r.pos<d;){var b=r.uint32();switch(b>>>3){case 1:m.node&&m.node.length||(m.node=[]),m.node.push(p.onnx.NodeProto.decode(r,r.uint32()));break;case 2:m.name=r.string();break;case 5:m.initializer&&m.initializer.length||(m.initializer=[]),m.initializer.push(p.onnx.TensorProto.decode(r,r.uint32()));break;case 10:m.docString=r.string();break;case 11:m.input&&m.input.length||(m.input=[]),m.input.push(p.onnx.ValueInfoProto.decode(r,r.uint32()));break;case 12:m.output&&m.output.length||(m.output=[]),m.output.push(p.onnx.ValueInfoProto.decode(r,r.uint32()));break;case 13:m.valueInfo&&m.valueInfo.length||(m.valueInfo=[]),m.valueInfo.push(p.onnx.ValueInfoProto.decode(r,r.uint32()));break;case 14:m.quantizationAnnotation&&m.quantizationAnnotation.length||(m.quantizationAnnotation=[]),m.quantizationAnnotation.push(p.onnx.TensorAnnotation.decode(r,r.uint32()));break;default:r.skipType(7&b)}}return m},s.decodeDelimited=function(r){return r instanceof f||(r=new f(r)),this.decode(r,r.uint32())},s.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.node!=null&&r.hasOwnProperty("node")){if(!Array.isArray(r.node))return"node: array expected";for(var u=0;u<r.node.length;++u)if(d=p.onnx.NodeProto.verify(r.node[u]))return"node."+d}if(r.name!=null&&r.hasOwnProperty("name")&&!h.isString(r.name))return"name: string expected";if(r.initializer!=null&&r.hasOwnProperty("initializer")){if(!Array.isArray(r.initializer))return"initializer: array expected";for(u=0;u<r.initializer.length;++u)if(d=p.onnx.TensorProto.verify(r.initializer[u]))return"initializer."+d}if(r.docString!=null&&r.hasOwnProperty("docString")&&!h.isString(r.docString))return"docString: string expected";if(r.input!=null&&r.hasOwnProperty("input")){if(!Array.isArray(r.input))return"input: array expected";for(u=0;u<r.input.length;++u)if(d=p.onnx.ValueInfoProto.verify(r.input[u]))return"input."+d}if(r.output!=null&&r.hasOwnProperty("output")){if(!Array.isArray(r.output))return"output: array expected";for(u=0;u<r.output.length;++u)if(d=p.onnx.ValueInfoProto.verify(r.output[u]))return"output."+d}if(r.valueInfo!=null&&r.hasOwnProperty("valueInfo")){if(!Array.isArray(r.valueInfo))return"valueInfo: array expected";for(u=0;u<r.valueInfo.length;++u)if(d=p.onnx.ValueInfoProto.verify(r.valueInfo[u]))return"valueInfo."+d}if(r.quantizationAnnotation!=null&&r.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(r.quantizationAnnotation))return"quantizationAnnotation: array expected";for(u=0;u<r.quantizationAnnotation.length;++u){var d;if(d=p.onnx.TensorAnnotation.verify(r.quantizationAnnotation[u]))return"quantizationAnnotation."+d}}return null},s.fromObject=function(r){if(r instanceof p.onnx.GraphProto)return r;var u=new p.onnx.GraphProto;if(r.node){if(!Array.isArray(r.node))throw TypeError(".onnx.GraphProto.node: array expected");u.node=[];for(var d=0;d<r.node.length;++d){if(typeof r.node[d]!="object")throw TypeError(".onnx.GraphProto.node: object expected");u.node[d]=p.onnx.NodeProto.fromObject(r.node[d])}}if(r.name!=null&&(u.name=String(r.name)),r.initializer){if(!Array.isArray(r.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(u.initializer=[],d=0;d<r.initializer.length;++d){if(typeof r.initializer[d]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");u.initializer[d]=p.onnx.TensorProto.fromObject(r.initializer[d])}}if(r.docString!=null&&(u.docString=String(r.docString)),r.input){if(!Array.isArray(r.input))throw TypeError(".onnx.GraphProto.input: array expected");for(u.input=[],d=0;d<r.input.length;++d){if(typeof r.input[d]!="object")throw TypeError(".onnx.GraphProto.input: object expected");u.input[d]=p.onnx.ValueInfoProto.fromObject(r.input[d])}}if(r.output){if(!Array.isArray(r.output))throw TypeError(".onnx.GraphProto.output: array expected");for(u.output=[],d=0;d<r.output.length;++d){if(typeof r.output[d]!="object")throw TypeError(".onnx.GraphProto.output: object expected");u.output[d]=p.onnx.ValueInfoProto.fromObject(r.output[d])}}if(r.valueInfo){if(!Array.isArray(r.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(u.valueInfo=[],d=0;d<r.valueInfo.length;++d){if(typeof r.valueInfo[d]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");u.valueInfo[d]=p.onnx.ValueInfoProto.fromObject(r.valueInfo[d])}}if(r.quantizationAnnotation){if(!Array.isArray(r.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(u.quantizationAnnotation=[],d=0;d<r.quantizationAnnotation.length;++d){if(typeof r.quantizationAnnotation[d]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");u.quantizationAnnotation[d]=p.onnx.TensorAnnotation.fromObject(r.quantizationAnnotation[d])}}return u},s.toObject=function(r,u){u||(u={});var d={};if((u.arrays||u.defaults)&&(d.node=[],d.initializer=[],d.input=[],d.output=[],d.valueInfo=[],d.quantizationAnnotation=[]),u.defaults&&(d.name="",d.docString=""),r.node&&r.node.length){d.node=[];for(var m=0;m<r.node.length;++m)d.node[m]=p.onnx.NodeProto.toObject(r.node[m],u)}if(r.name!=null&&r.hasOwnProperty("name")&&(d.name=r.name),r.initializer&&r.initializer.length)for(d.initializer=[],m=0;m<r.initializer.length;++m)d.initializer[m]=p.onnx.TensorProto.toObject(r.initializer[m],u);if(r.docString!=null&&r.hasOwnProperty("docString")&&(d.docString=r.docString),r.input&&r.input.length)for(d.input=[],m=0;m<r.input.length;++m)d.input[m]=p.onnx.ValueInfoProto.toObject(r.input[m],u);if(r.output&&r.output.length)for(d.output=[],m=0;m<r.output.length;++m)d.output[m]=p.onnx.ValueInfoProto.toObject(r.output[m],u);if(r.valueInfo&&r.valueInfo.length)for(d.valueInfo=[],m=0;m<r.valueInfo.length;++m)d.valueInfo[m]=p.onnx.ValueInfoProto.toObject(r.valueInfo[m],u);if(r.quantizationAnnotation&&r.quantizationAnnotation.length)for(d.quantizationAnnotation=[],m=0;m<r.quantizationAnnotation.length;++m)d.quantizationAnnotation[m]=p.onnx.TensorAnnotation.toObject(r.quantizationAnnotation[m],u);return d},s.prototype.toJSON=function(){return this.constructor.toObject(this,c.util.toJSONOptions)},s}(),l.TensorProto=function(){function s(r){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],r)for(var u=Object.keys(r),d=0;d<u.length;++d)r[u[d]]!=null&&(this[u[d]]=r[u[d]])}return s.prototype.dims=h.emptyArray,s.prototype.dataType=0,s.prototype.segment=null,s.prototype.floatData=h.emptyArray,s.prototype.int32Data=h.emptyArray,s.prototype.stringData=h.emptyArray,s.prototype.int64Data=h.emptyArray,s.prototype.name="",s.prototype.docString="",s.prototype.rawData=h.newBuffer([]),s.prototype.externalData=h.emptyArray,s.prototype.dataLocation=0,s.prototype.doubleData=h.emptyArray,s.prototype.uint64Data=h.emptyArray,s.create=function(r){return new s(r)},s.encode=function(r,u){if(u||(u=g.create()),r.dims!=null&&r.dims.length){u.uint32(10).fork();for(var d=0;d<r.dims.length;++d)u.int64(r.dims[d]);u.ldelim()}if(r.dataType!=null&&r.hasOwnProperty("dataType")&&u.uint32(16).int32(r.dataType),r.segment!=null&&r.hasOwnProperty("segment")&&p.onnx.TensorProto.Segment.encode(r.segment,u.uint32(26).fork()).ldelim(),r.floatData!=null&&r.floatData.length){for(u.uint32(34).fork(),d=0;d<r.floatData.length;++d)u.float(r.floatData[d]);u.ldelim()}if(r.int32Data!=null&&r.int32Data.length){for(u.uint32(42).fork(),d=0;d<r.int32Data.length;++d)u.int32(r.int32Data[d]);u.ldelim()}if(r.stringData!=null&&r.stringData.length)for(d=0;d<r.stringData.length;++d)u.uint32(50).bytes(r.stringData[d]);if(r.int64Data!=null&&r.int64Data.length){for(u.uint32(58).fork(),d=0;d<r.int64Data.length;++d)u.int64(r.int64Data[d]);u.ldelim()}if(r.name!=null&&r.hasOwnProperty("name")&&u.uint32(66).string(r.name),r.rawData!=null&&r.hasOwnProperty("rawData")&&u.uint32(74).bytes(r.rawData),r.doubleData!=null&&r.doubleData.length){for(u.uint32(82).fork(),d=0;d<r.doubleData.length;++d)u.double(r.doubleData[d]);u.ldelim()}if(r.uint64Data!=null&&r.uint64Data.length){for(u.uint32(90).fork(),d=0;d<r.uint64Data.length;++d)u.uint64(r.uint64Data[d]);u.ldelim()}if(r.docString!=null&&r.hasOwnProperty("docString")&&u.uint32(98).string(r.docString),r.externalData!=null&&r.externalData.length)for(d=0;d<r.externalData.length;++d)p.onnx.StringStringEntryProto.encode(r.externalData[d],u.uint32(106).fork()).ldelim();return r.dataLocation!=null&&r.hasOwnProperty("dataLocation")&&u.uint32(112).int32(r.dataLocation),u},s.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},s.decode=function(r,u){r instanceof f||(r=f.create(r));for(var d=u===void 0?r.len:r.pos+u,m=new p.onnx.TensorProto;r.pos<d;){var b=r.uint32();switch(b>>>3){case 1:if(m.dims&&m.dims.length||(m.dims=[]),(7&b)==2)for(var y=r.uint32()+r.pos;r.pos<y;)m.dims.push(r.int64());else m.dims.push(r.int64());break;case 2:m.dataType=r.int32();break;case 3:m.segment=p.onnx.TensorProto.Segment.decode(r,r.uint32());break;case 4:if(m.floatData&&m.floatData.length||(m.floatData=[]),(7&b)==2)for(y=r.uint32()+r.pos;r.pos<y;)m.floatData.push(r.float());else m.floatData.push(r.float());break;case 5:if(m.int32Data&&m.int32Data.length||(m.int32Data=[]),(7&b)==2)for(y=r.uint32()+r.pos;r.pos<y;)m.int32Data.push(r.int32());else m.int32Data.push(r.int32());break;case 6:m.stringData&&m.stringData.length||(m.stringData=[]),m.stringData.push(r.bytes());break;case 7:if(m.int64Data&&m.int64Data.length||(m.int64Data=[]),(7&b)==2)for(y=r.uint32()+r.pos;r.pos<y;)m.int64Data.push(r.int64());else m.int64Data.push(r.int64());break;case 8:m.name=r.string();break;case 12:m.docString=r.string();break;case 9:m.rawData=r.bytes();break;case 13:m.externalData&&m.externalData.length||(m.externalData=[]),m.externalData.push(p.onnx.StringStringEntryProto.decode(r,r.uint32()));break;case 14:m.dataLocation=r.int32();break;case 10:if(m.doubleData&&m.doubleData.length||(m.doubleData=[]),(7&b)==2)for(y=r.uint32()+r.pos;r.pos<y;)m.doubleData.push(r.double());else m.doubleData.push(r.double());break;case 11:if(m.uint64Data&&m.uint64Data.length||(m.uint64Data=[]),(7&b)==2)for(y=r.uint32()+r.pos;r.pos<y;)m.uint64Data.push(r.uint64());else m.uint64Data.push(r.uint64());break;default:r.skipType(7&b)}}return m},s.decodeDelimited=function(r){return r instanceof f||(r=new f(r)),this.decode(r,r.uint32())},s.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.dims!=null&&r.hasOwnProperty("dims")){if(!Array.isArray(r.dims))return"dims: array expected";for(var u=0;u<r.dims.length;++u)if(!(h.isInteger(r.dims[u])||r.dims[u]&&h.isInteger(r.dims[u].low)&&h.isInteger(r.dims[u].high)))return"dims: integer|Long[] expected"}if(r.dataType!=null&&r.hasOwnProperty("dataType")&&!h.isInteger(r.dataType))return"dataType: integer expected";if(r.segment!=null&&r.hasOwnProperty("segment")&&(d=p.onnx.TensorProto.Segment.verify(r.segment)))return"segment."+d;if(r.floatData!=null&&r.hasOwnProperty("floatData")){if(!Array.isArray(r.floatData))return"floatData: array expected";for(u=0;u<r.floatData.length;++u)if(typeof r.floatData[u]!="number")return"floatData: number[] expected"}if(r.int32Data!=null&&r.hasOwnProperty("int32Data")){if(!Array.isArray(r.int32Data))return"int32Data: array expected";for(u=0;u<r.int32Data.length;++u)if(!h.isInteger(r.int32Data[u]))return"int32Data: integer[] expected"}if(r.stringData!=null&&r.hasOwnProperty("stringData")){if(!Array.isArray(r.stringData))return"stringData: array expected";for(u=0;u<r.stringData.length;++u)if(!(r.stringData[u]&&typeof r.stringData[u].length=="number"||h.isString(r.stringData[u])))return"stringData: buffer[] expected"}if(r.int64Data!=null&&r.hasOwnProperty("int64Data")){if(!Array.isArray(r.int64Data))return"int64Data: array expected";for(u=0;u<r.int64Data.length;++u)if(!(h.isInteger(r.int64Data[u])||r.int64Data[u]&&h.isInteger(r.int64Data[u].low)&&h.isInteger(r.int64Data[u].high)))return"int64Data: integer|Long[] expected"}if(r.name!=null&&r.hasOwnProperty("name")&&!h.isString(r.name))return"name: string expected";if(r.docString!=null&&r.hasOwnProperty("docString")&&!h.isString(r.docString))return"docString: string expected";if(r.rawData!=null&&r.hasOwnProperty("rawData")&&!(r.rawData&&typeof r.rawData.length=="number"||h.isString(r.rawData)))return"rawData: buffer expected";if(r.externalData!=null&&r.hasOwnProperty("externalData")){if(!Array.isArray(r.externalData))return"externalData: array expected";for(u=0;u<r.externalData.length;++u){var d;if(d=p.onnx.StringStringEntryProto.verify(r.externalData[u]))return"externalData."+d}}if(r.dataLocation!=null&&r.hasOwnProperty("dataLocation"))switch(r.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(r.doubleData!=null&&r.hasOwnProperty("doubleData")){if(!Array.isArray(r.doubleData))return"doubleData: array expected";for(u=0;u<r.doubleData.length;++u)if(typeof r.doubleData[u]!="number")return"doubleData: number[] expected"}if(r.uint64Data!=null&&r.hasOwnProperty("uint64Data")){if(!Array.isArray(r.uint64Data))return"uint64Data: array expected";for(u=0;u<r.uint64Data.length;++u)if(!(h.isInteger(r.uint64Data[u])||r.uint64Data[u]&&h.isInteger(r.uint64Data[u].low)&&h.isInteger(r.uint64Data[u].high)))return"uint64Data: integer|Long[] expected"}return null},s.fromObject=function(r){if(r instanceof p.onnx.TensorProto)return r;var u=new p.onnx.TensorProto;if(r.dims){if(!Array.isArray(r.dims))throw TypeError(".onnx.TensorProto.dims: array expected");u.dims=[];for(var d=0;d<r.dims.length;++d)h.Long?(u.dims[d]=h.Long.fromValue(r.dims[d])).unsigned=!1:typeof r.dims[d]=="string"?u.dims[d]=parseInt(r.dims[d],10):typeof r.dims[d]=="number"?u.dims[d]=r.dims[d]:typeof r.dims[d]=="object"&&(u.dims[d]=new h.LongBits(r.dims[d].low>>>0,r.dims[d].high>>>0).toNumber())}if(r.dataType!=null&&(u.dataType=0|r.dataType),r.segment!=null){if(typeof r.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");u.segment=p.onnx.TensorProto.Segment.fromObject(r.segment)}if(r.floatData){if(!Array.isArray(r.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(u.floatData=[],d=0;d<r.floatData.length;++d)u.floatData[d]=Number(r.floatData[d])}if(r.int32Data){if(!Array.isArray(r.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(u.int32Data=[],d=0;d<r.int32Data.length;++d)u.int32Data[d]=0|r.int32Data[d]}if(r.stringData){if(!Array.isArray(r.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(u.stringData=[],d=0;d<r.stringData.length;++d)typeof r.stringData[d]=="string"?h.base64.decode(r.stringData[d],u.stringData[d]=h.newBuffer(h.base64.length(r.stringData[d])),0):r.stringData[d].length&&(u.stringData[d]=r.stringData[d])}if(r.int64Data){if(!Array.isArray(r.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(u.int64Data=[],d=0;d<r.int64Data.length;++d)h.Long?(u.int64Data[d]=h.Long.fromValue(r.int64Data[d])).unsigned=!1:typeof r.int64Data[d]=="string"?u.int64Data[d]=parseInt(r.int64Data[d],10):typeof r.int64Data[d]=="number"?u.int64Data[d]=r.int64Data[d]:typeof r.int64Data[d]=="object"&&(u.int64Data[d]=new h.LongBits(r.int64Data[d].low>>>0,r.int64Data[d].high>>>0).toNumber())}if(r.name!=null&&(u.name=String(r.name)),r.docString!=null&&(u.docString=String(r.docString)),r.rawData!=null&&(typeof r.rawData=="string"?h.base64.decode(r.rawData,u.rawData=h.newBuffer(h.base64.length(r.rawData)),0):r.rawData.length&&(u.rawData=r.rawData)),r.externalData){if(!Array.isArray(r.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(u.externalData=[],d=0;d<r.externalData.length;++d){if(typeof r.externalData[d]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");u.externalData[d]=p.onnx.StringStringEntryProto.fromObject(r.externalData[d])}}switch(r.dataLocation){case"DEFAULT":case 0:u.dataLocation=0;break;case"EXTERNAL":case 1:u.dataLocation=1}if(r.doubleData){if(!Array.isArray(r.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(u.doubleData=[],d=0;d<r.doubleData.length;++d)u.doubleData[d]=Number(r.doubleData[d])}if(r.uint64Data){if(!Array.isArray(r.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(u.uint64Data=[],d=0;d<r.uint64Data.length;++d)h.Long?(u.uint64Data[d]=h.Long.fromValue(r.uint64Data[d])).unsigned=!0:typeof r.uint64Data[d]=="string"?u.uint64Data[d]=parseInt(r.uint64Data[d],10):typeof r.uint64Data[d]=="number"?u.uint64Data[d]=r.uint64Data[d]:typeof r.uint64Data[d]=="object"&&(u.uint64Data[d]=new h.LongBits(r.uint64Data[d].low>>>0,r.uint64Data[d].high>>>0).toNumber(!0))}return u},s.toObject=function(r,u){u||(u={});var d={};if((u.arrays||u.defaults)&&(d.dims=[],d.floatData=[],d.int32Data=[],d.stringData=[],d.int64Data=[],d.doubleData=[],d.uint64Data=[],d.externalData=[]),u.defaults&&(d.dataType=0,d.segment=null,d.name="",u.bytes===String?d.rawData="":(d.rawData=[],u.bytes!==Array&&(d.rawData=h.newBuffer(d.rawData))),d.docString="",d.dataLocation=u.enums===String?"DEFAULT":0),r.dims&&r.dims.length){d.dims=[];for(var m=0;m<r.dims.length;++m)typeof r.dims[m]=="number"?d.dims[m]=u.longs===String?String(r.dims[m]):r.dims[m]:d.dims[m]=u.longs===String?h.Long.prototype.toString.call(r.dims[m]):u.longs===Number?new h.LongBits(r.dims[m].low>>>0,r.dims[m].high>>>0).toNumber():r.dims[m]}if(r.dataType!=null&&r.hasOwnProperty("dataType")&&(d.dataType=r.dataType),r.segment!=null&&r.hasOwnProperty("segment")&&(d.segment=p.onnx.TensorProto.Segment.toObject(r.segment,u)),r.floatData&&r.floatData.length)for(d.floatData=[],m=0;m<r.floatData.length;++m)d.floatData[m]=u.json&&!isFinite(r.floatData[m])?String(r.floatData[m]):r.floatData[m];if(r.int32Data&&r.int32Data.length)for(d.int32Data=[],m=0;m<r.int32Data.length;++m)d.int32Data[m]=r.int32Data[m];if(r.stringData&&r.stringData.length)for(d.stringData=[],m=0;m<r.stringData.length;++m)d.stringData[m]=u.bytes===String?h.base64.encode(r.stringData[m],0,r.stringData[m].length):u.bytes===Array?Array.prototype.slice.call(r.stringData[m]):r.stringData[m];if(r.int64Data&&r.int64Data.length)for(d.int64Data=[],m=0;m<r.int64Data.length;++m)typeof r.int64Data[m]=="number"?d.int64Data[m]=u.longs===String?String(r.int64Data[m]):r.int64Data[m]:d.int64Data[m]=u.longs===String?h.Long.prototype.toString.call(r.int64Data[m]):u.longs===Number?new h.LongBits(r.int64Data[m].low>>>0,r.int64Data[m].high>>>0).toNumber():r.int64Data[m];if(r.name!=null&&r.hasOwnProperty("name")&&(d.name=r.name),r.rawData!=null&&r.hasOwnProperty("rawData")&&(d.rawData=u.bytes===String?h.base64.encode(r.rawData,0,r.rawData.length):u.bytes===Array?Array.prototype.slice.call(r.rawData):r.rawData),r.doubleData&&r.doubleData.length)for(d.doubleData=[],m=0;m<r.doubleData.length;++m)d.doubleData[m]=u.json&&!isFinite(r.doubleData[m])?String(r.doubleData[m]):r.doubleData[m];if(r.uint64Data&&r.uint64Data.length)for(d.uint64Data=[],m=0;m<r.uint64Data.length;++m)typeof r.uint64Data[m]=="number"?d.uint64Data[m]=u.longs===String?String(r.uint64Data[m]):r.uint64Data[m]:d.uint64Data[m]=u.longs===String?h.Long.prototype.toString.call(r.uint64Data[m]):u.longs===Number?new h.LongBits(r.uint64Data[m].low>>>0,r.uint64Data[m].high>>>0).toNumber(!0):r.uint64Data[m];if(r.docString!=null&&r.hasOwnProperty("docString")&&(d.docString=r.docString),r.externalData&&r.externalData.length)for(d.externalData=[],m=0;m<r.externalData.length;++m)d.externalData[m]=p.onnx.StringStringEntryProto.toObject(r.externalData[m],u);return r.dataLocation!=null&&r.hasOwnProperty("dataLocation")&&(d.dataLocation=u.enums===String?p.onnx.TensorProto.DataLocation[r.dataLocation]:r.dataLocation),d},s.prototype.toJSON=function(){return this.constructor.toObject(this,c.util.toJSONOptions)},s.DataType=function(){var r={},u=Object.create(r);return u[r[0]="UNDEFINED"]=0,u[r[1]="FLOAT"]=1,u[r[2]="UINT8"]=2,u[r[3]="INT8"]=3,u[r[4]="UINT16"]=4,u[r[5]="INT16"]=5,u[r[6]="INT32"]=6,u[r[7]="INT64"]=7,u[r[8]="STRING"]=8,u[r[9]="BOOL"]=9,u[r[10]="FLOAT16"]=10,u[r[11]="DOUBLE"]=11,u[r[12]="UINT32"]=12,u[r[13]="UINT64"]=13,u[r[14]="COMPLEX64"]=14,u[r[15]="COMPLEX128"]=15,u[r[16]="BFLOAT16"]=16,u}(),s.Segment=function(){function r(u){if(u)for(var d=Object.keys(u),m=0;m<d.length;++m)u[d[m]]!=null&&(this[d[m]]=u[d[m]])}return r.prototype.begin=h.Long?h.Long.fromBits(0,0,!1):0,r.prototype.end=h.Long?h.Long.fromBits(0,0,!1):0,r.create=function(u){return new r(u)},r.encode=function(u,d){return d||(d=g.create()),u.begin!=null&&u.hasOwnProperty("begin")&&d.uint32(8).int64(u.begin),u.end!=null&&u.hasOwnProperty("end")&&d.uint32(16).int64(u.end),d},r.encodeDelimited=function(u,d){return this.encode(u,d).ldelim()},r.decode=function(u,d){u instanceof f||(u=f.create(u));for(var m=d===void 0?u.len:u.pos+d,b=new p.onnx.TensorProto.Segment;u.pos<m;){var y=u.uint32();switch(y>>>3){case 1:b.begin=u.int64();break;case 2:b.end=u.int64();break;default:u.skipType(7&y)}}return b},r.decodeDelimited=function(u){return u instanceof f||(u=new f(u)),this.decode(u,u.uint32())},r.verify=function(u){return typeof u!="object"||u===null?"object expected":u.begin!=null&&u.hasOwnProperty("begin")&&!(h.isInteger(u.begin)||u.begin&&h.isInteger(u.begin.low)&&h.isInteger(u.begin.high))?"begin: integer|Long expected":u.end!=null&&u.hasOwnProperty("end")&&!(h.isInteger(u.end)||u.end&&h.isInteger(u.end.low)&&h.isInteger(u.end.high))?"end: integer|Long expected":null},r.fromObject=function(u){if(u instanceof p.onnx.TensorProto.Segment)return u;var d=new p.onnx.TensorProto.Segment;return u.begin!=null&&(h.Long?(d.begin=h.Long.fromValue(u.begin)).unsigned=!1:typeof u.begin=="string"?d.begin=parseInt(u.begin,10):typeof u.begin=="number"?d.begin=u.begin:typeof u.begin=="object"&&(d.begin=new h.LongBits(u.begin.low>>>0,u.begin.high>>>0).toNumber())),u.end!=null&&(h.Long?(d.end=h.Long.fromValue(u.end)).unsigned=!1:typeof u.end=="string"?d.end=parseInt(u.end,10):typeof u.end=="number"?d.end=u.end:typeof u.end=="object"&&(d.end=new h.LongBits(u.end.low>>>0,u.end.high>>>0).toNumber())),d},r.toObject=function(u,d){d||(d={});var m={};if(d.defaults){if(h.Long){var b=new h.Long(0,0,!1);m.begin=d.longs===String?b.toString():d.longs===Number?b.toNumber():b}else m.begin=d.longs===String?"0":0;h.Long?(b=new h.Long(0,0,!1),m.end=d.longs===String?b.toString():d.longs===Number?b.toNumber():b):m.end=d.longs===String?"0":0}return u.begin!=null&&u.hasOwnProperty("begin")&&(typeof u.begin=="number"?m.begin=d.longs===String?String(u.begin):u.begin:m.begin=d.longs===String?h.Long.prototype.toString.call(u.begin):d.longs===Number?new h.LongBits(u.begin.low>>>0,u.begin.high>>>0).toNumber():u.begin),u.end!=null&&u.hasOwnProperty("end")&&(typeof u.end=="number"?m.end=d.longs===String?String(u.end):u.end:m.end=d.longs===String?h.Long.prototype.toString.call(u.end):d.longs===Number?new h.LongBits(u.end.low>>>0,u.end.high>>>0).toNumber():u.end),m},r.prototype.toJSON=function(){return this.constructor.toObject(this,c.util.toJSONOptions)},r}(),s.DataLocation=function(){var r={},u=Object.create(r);return u[r[0]="DEFAULT"]=0,u[r[1]="EXTERNAL"]=1,u}(),s}(),l.TensorShapeProto=function(){function s(r){if(this.dim=[],r)for(var u=Object.keys(r),d=0;d<u.length;++d)r[u[d]]!=null&&(this[u[d]]=r[u[d]])}return s.prototype.dim=h.emptyArray,s.create=function(r){return new s(r)},s.encode=function(r,u){if(u||(u=g.create()),r.dim!=null&&r.dim.length)for(var d=0;d<r.dim.length;++d)p.onnx.TensorShapeProto.Dimension.encode(r.dim[d],u.uint32(10).fork()).ldelim();return u},s.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},s.decode=function(r,u){r instanceof f||(r=f.create(r));for(var d=u===void 0?r.len:r.pos+u,m=new p.onnx.TensorShapeProto;r.pos<d;){var b=r.uint32();b>>>3==1?(m.dim&&m.dim.length||(m.dim=[]),m.dim.push(p.onnx.TensorShapeProto.Dimension.decode(r,r.uint32()))):r.skipType(7&b)}return m},s.decodeDelimited=function(r){return r instanceof f||(r=new f(r)),this.decode(r,r.uint32())},s.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.dim!=null&&r.hasOwnProperty("dim")){if(!Array.isArray(r.dim))return"dim: array expected";for(var u=0;u<r.dim.length;++u){var d=p.onnx.TensorShapeProto.Dimension.verify(r.dim[u]);if(d)return"dim."+d}}return null},s.fromObject=function(r){if(r instanceof p.onnx.TensorShapeProto)return r;var u=new p.onnx.TensorShapeProto;if(r.dim){if(!Array.isArray(r.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");u.dim=[];for(var d=0;d<r.dim.length;++d){if(typeof r.dim[d]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");u.dim[d]=p.onnx.TensorShapeProto.Dimension.fromObject(r.dim[d])}}return u},s.toObject=function(r,u){u||(u={});var d={};if((u.arrays||u.defaults)&&(d.dim=[]),r.dim&&r.dim.length){d.dim=[];for(var m=0;m<r.dim.length;++m)d.dim[m]=p.onnx.TensorShapeProto.Dimension.toObject(r.dim[m],u)}return d},s.prototype.toJSON=function(){return this.constructor.toObject(this,c.util.toJSONOptions)},s.Dimension=function(){function r(d){if(d)for(var m=Object.keys(d),b=0;b<m.length;++b)d[m[b]]!=null&&(this[m[b]]=d[m[b]])}var u;return r.prototype.dimValue=h.Long?h.Long.fromBits(0,0,!1):0,r.prototype.dimParam="",r.prototype.denotation="",Object.defineProperty(r.prototype,"value",{get:h.oneOfGetter(u=["dimValue","dimParam"]),set:h.oneOfSetter(u)}),r.create=function(d){return new r(d)},r.encode=function(d,m){return m||(m=g.create()),d.dimValue!=null&&d.hasOwnProperty("dimValue")&&m.uint32(8).int64(d.dimValue),d.dimParam!=null&&d.hasOwnProperty("dimParam")&&m.uint32(18).string(d.dimParam),d.denotation!=null&&d.hasOwnProperty("denotation")&&m.uint32(26).string(d.denotation),m},r.encodeDelimited=function(d,m){return this.encode(d,m).ldelim()},r.decode=function(d,m){d instanceof f||(d=f.create(d));for(var b=m===void 0?d.len:d.pos+m,y=new p.onnx.TensorShapeProto.Dimension;d.pos<b;){var w=d.uint32();switch(w>>>3){case 1:y.dimValue=d.int64();break;case 2:y.dimParam=d.string();break;case 3:y.denotation=d.string();break;default:d.skipType(7&w)}}return y},r.decodeDelimited=function(d){return d instanceof f||(d=new f(d)),this.decode(d,d.uint32())},r.verify=function(d){if(typeof d!="object"||d===null)return"object expected";var m={};if(d.dimValue!=null&&d.hasOwnProperty("dimValue")&&(m.value=1,!(h.isInteger(d.dimValue)||d.dimValue&&h.isInteger(d.dimValue.low)&&h.isInteger(d.dimValue.high))))return"dimValue: integer|Long expected";if(d.dimParam!=null&&d.hasOwnProperty("dimParam")){if(m.value===1)return"value: multiple values";if(m.value=1,!h.isString(d.dimParam))return"dimParam: string expected"}return d.denotation!=null&&d.hasOwnProperty("denotation")&&!h.isString(d.denotation)?"denotation: string expected":null},r.fromObject=function(d){if(d instanceof p.onnx.TensorShapeProto.Dimension)return d;var m=new p.onnx.TensorShapeProto.Dimension;return d.dimValue!=null&&(h.Long?(m.dimValue=h.Long.fromValue(d.dimValue)).unsigned=!1:typeof d.dimValue=="string"?m.dimValue=parseInt(d.dimValue,10):typeof d.dimValue=="number"?m.dimValue=d.dimValue:typeof d.dimValue=="object"&&(m.dimValue=new h.LongBits(d.dimValue.low>>>0,d.dimValue.high>>>0).toNumber())),d.dimParam!=null&&(m.dimParam=String(d.dimParam)),d.denotation!=null&&(m.denotation=String(d.denotation)),m},r.toObject=function(d,m){m||(m={});var b={};return m.defaults&&(b.denotation=""),d.dimValue!=null&&d.hasOwnProperty("dimValue")&&(typeof d.dimValue=="number"?b.dimValue=m.longs===String?String(d.dimValue):d.dimValue:b.dimValue=m.longs===String?h.Long.prototype.toString.call(d.dimValue):m.longs===Number?new h.LongBits(d.dimValue.low>>>0,d.dimValue.high>>>0).toNumber():d.dimValue,m.oneofs&&(b.value="dimValue")),d.dimParam!=null&&d.hasOwnProperty("dimParam")&&(b.dimParam=d.dimParam,m.oneofs&&(b.value="dimParam")),d.denotation!=null&&d.hasOwnProperty("denotation")&&(b.denotation=d.denotation),b},r.prototype.toJSON=function(){return this.constructor.toObject(this,c.util.toJSONOptions)},r}(),s}(),l.TypeProto=function(){function s(u){if(u)for(var d=Object.keys(u),m=0;m<d.length;++m)u[d[m]]!=null&&(this[d[m]]=u[d[m]])}var r;return s.prototype.tensorType=null,s.prototype.denotation="",Object.defineProperty(s.prototype,"value",{get:h.oneOfGetter(r=["tensorType"]),set:h.oneOfSetter(r)}),s.create=function(u){return new s(u)},s.encode=function(u,d){return d||(d=g.create()),u.tensorType!=null&&u.hasOwnProperty("tensorType")&&p.onnx.TypeProto.Tensor.encode(u.tensorType,d.uint32(10).fork()).ldelim(),u.denotation!=null&&u.hasOwnProperty("denotation")&&d.uint32(50).string(u.denotation),d},s.encodeDelimited=function(u,d){return this.encode(u,d).ldelim()},s.decode=function(u,d){u instanceof f||(u=f.create(u));for(var m=d===void 0?u.len:u.pos+d,b=new p.onnx.TypeProto;u.pos<m;){var y=u.uint32();switch(y>>>3){case 1:b.tensorType=p.onnx.TypeProto.Tensor.decode(u,u.uint32());break;case 6:b.denotation=u.string();break;default:u.skipType(7&y)}}return b},s.decodeDelimited=function(u){return u instanceof f||(u=new f(u)),this.decode(u,u.uint32())},s.verify=function(u){if(typeof u!="object"||u===null)return"object expected";if(u.tensorType!=null&&u.hasOwnProperty("tensorType")){var d=p.onnx.TypeProto.Tensor.verify(u.tensorType);if(d)return"tensorType."+d}return u.denotation!=null&&u.hasOwnProperty("denotation")&&!h.isString(u.denotation)?"denotation: string expected":null},s.fromObject=function(u){if(u instanceof p.onnx.TypeProto)return u;var d=new p.onnx.TypeProto;if(u.tensorType!=null){if(typeof u.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");d.tensorType=p.onnx.TypeProto.Tensor.fromObject(u.tensorType)}return u.denotation!=null&&(d.denotation=String(u.denotation)),d},s.toObject=function(u,d){d||(d={});var m={};return d.defaults&&(m.denotation=""),u.tensorType!=null&&u.hasOwnProperty("tensorType")&&(m.tensorType=p.onnx.TypeProto.Tensor.toObject(u.tensorType,d),d.oneofs&&(m.value="tensorType")),u.denotation!=null&&u.hasOwnProperty("denotation")&&(m.denotation=u.denotation),m},s.prototype.toJSON=function(){return this.constructor.toObject(this,c.util.toJSONOptions)},s.Tensor=function(){function u(d){if(d)for(var m=Object.keys(d),b=0;b<m.length;++b)d[m[b]]!=null&&(this[m[b]]=d[m[b]])}return u.prototype.elemType=0,u.prototype.shape=null,u.create=function(d){return new u(d)},u.encode=function(d,m){return m||(m=g.create()),d.elemType!=null&&d.hasOwnProperty("elemType")&&m.uint32(8).int32(d.elemType),d.shape!=null&&d.hasOwnProperty("shape")&&p.onnx.TensorShapeProto.encode(d.shape,m.uint32(18).fork()).ldelim(),m},u.encodeDelimited=function(d,m){return this.encode(d,m).ldelim()},u.decode=function(d,m){d instanceof f||(d=f.create(d));for(var b=m===void 0?d.len:d.pos+m,y=new p.onnx.TypeProto.Tensor;d.pos<b;){var w=d.uint32();switch(w>>>3){case 1:y.elemType=d.int32();break;case 2:y.shape=p.onnx.TensorShapeProto.decode(d,d.uint32());break;default:d.skipType(7&w)}}return y},u.decodeDelimited=function(d){return d instanceof f||(d=new f(d)),this.decode(d,d.uint32())},u.verify=function(d){if(typeof d!="object"||d===null)return"object expected";if(d.elemType!=null&&d.hasOwnProperty("elemType")&&!h.isInteger(d.elemType))return"elemType: integer expected";if(d.shape!=null&&d.hasOwnProperty("shape")){var m=p.onnx.TensorShapeProto.verify(d.shape);if(m)return"shape."+m}return null},u.fromObject=function(d){if(d instanceof p.onnx.TypeProto.Tensor)return d;var m=new p.onnx.TypeProto.Tensor;if(d.elemType!=null&&(m.elemType=0|d.elemType),d.shape!=null){if(typeof d.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");m.shape=p.onnx.TensorShapeProto.fromObject(d.shape)}return m},u.toObject=function(d,m){m||(m={});var b={};return m.defaults&&(b.elemType=0,b.shape=null),d.elemType!=null&&d.hasOwnProperty("elemType")&&(b.elemType=d.elemType),d.shape!=null&&d.hasOwnProperty("shape")&&(b.shape=p.onnx.TensorShapeProto.toObject(d.shape,m)),b},u.prototype.toJSON=function(){return this.constructor.toObject(this,c.util.toJSONOptions)},u}(),s}(),l.OperatorSetIdProto=function(){function s(r){if(r)for(var u=Object.keys(r),d=0;d<u.length;++d)r[u[d]]!=null&&(this[u[d]]=r[u[d]])}return s.prototype.domain="",s.prototype.version=h.Long?h.Long.fromBits(0,0,!1):0,s.create=function(r){return new s(r)},s.encode=function(r,u){return u||(u=g.create()),r.domain!=null&&r.hasOwnProperty("domain")&&u.uint32(10).string(r.domain),r.version!=null&&r.hasOwnProperty("version")&&u.uint32(16).int64(r.version),u},s.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},s.decode=function(r,u){r instanceof f||(r=f.create(r));for(var d=u===void 0?r.len:r.pos+u,m=new p.onnx.OperatorSetIdProto;r.pos<d;){var b=r.uint32();switch(b>>>3){case 1:m.domain=r.string();break;case 2:m.version=r.int64();break;default:r.skipType(7&b)}}return m},s.decodeDelimited=function(r){return r instanceof f||(r=new f(r)),this.decode(r,r.uint32())},s.verify=function(r){return typeof r!="object"||r===null?"object expected":r.domain!=null&&r.hasOwnProperty("domain")&&!h.isString(r.domain)?"domain: string expected":r.version!=null&&r.hasOwnProperty("version")&&!(h.isInteger(r.version)||r.version&&h.isInteger(r.version.low)&&h.isInteger(r.version.high))?"version: integer|Long expected":null},s.fromObject=function(r){if(r instanceof p.onnx.OperatorSetIdProto)return r;var u=new p.onnx.OperatorSetIdProto;return r.domain!=null&&(u.domain=String(r.domain)),r.version!=null&&(h.Long?(u.version=h.Long.fromValue(r.version)).unsigned=!1:typeof r.version=="string"?u.version=parseInt(r.version,10):typeof r.version=="number"?u.version=r.version:typeof r.version=="object"&&(u.version=new h.LongBits(r.version.low>>>0,r.version.high>>>0).toNumber())),u},s.toObject=function(r,u){u||(u={});var d={};if(u.defaults)if(d.domain="",h.Long){var m=new h.Long(0,0,!1);d.version=u.longs===String?m.toString():u.longs===Number?m.toNumber():m}else d.version=u.longs===String?"0":0;return r.domain!=null&&r.hasOwnProperty("domain")&&(d.domain=r.domain),r.version!=null&&r.hasOwnProperty("version")&&(typeof r.version=="number"?d.version=u.longs===String?String(r.version):r.version:d.version=u.longs===String?h.Long.prototype.toString.call(r.version):u.longs===Number?new h.LongBits(r.version.low>>>0,r.version.high>>>0).toNumber():r.version),d},s.prototype.toJSON=function(){return this.constructor.toObject(this,c.util.toJSONOptions)},s}(),l),o.exports=p},2100:(o,t,e)=>{o.exports=e(9482)},9482:(o,t,e)=>{var n=t;function a(){n.util._configure(),n.Writer._configure(n.BufferWriter),n.Reader._configure(n.BufferReader)}n.build="minimal",n.Writer=e(1173),n.BufferWriter=e(3155),n.Reader=e(1408),n.BufferReader=e(593),n.util=e(9693),n.rpc=e(5994),n.roots=e(5054),n.configure=a,a()},1408:(o,t,e)=>{o.exports=g;var n,a=e(9693),l=a.LongBits,c=a.utf8;function f(m,b){return RangeError("index out of range: "+m.pos+" + "+(b||1)+" > "+m.len)}function g(m){this.buf=m,this.pos=0,this.len=m.length}var h,p=typeof Uint8Array<"u"?function(m){if(m instanceof Uint8Array||Array.isArray(m))return new g(m);throw Error("illegal buffer")}:function(m){if(Array.isArray(m))return new g(m);throw Error("illegal buffer")},s=function(){return a.Buffer?function(m){return(g.create=function(b){return a.Buffer.isBuffer(b)?new n(b):p(b)})(m)}:p};function r(){var m=new l(0,0),b=0;if(!(this.len-this.pos>4)){for(;b<3;++b){if(this.pos>=this.len)throw f(this);if(m.lo=(m.lo|(127&this.buf[this.pos])<<7*b)>>>0,this.buf[this.pos++]<128)return m}return m.lo=(m.lo|(127&this.buf[this.pos++])<<7*b)>>>0,m}for(;b<4;++b)if(m.lo=(m.lo|(127&this.buf[this.pos])<<7*b)>>>0,this.buf[this.pos++]<128)return m;if(m.lo=(m.lo|(127&this.buf[this.pos])<<28)>>>0,m.hi=(m.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return m;if(b=0,this.len-this.pos>4){for(;b<5;++b)if(m.hi=(m.hi|(127&this.buf[this.pos])<<7*b+3)>>>0,this.buf[this.pos++]<128)return m}else for(;b<5;++b){if(this.pos>=this.len)throw f(this);if(m.hi=(m.hi|(127&this.buf[this.pos])<<7*b+3)>>>0,this.buf[this.pos++]<128)return m}throw Error("invalid varint encoding")}function u(m,b){return(m[b-4]|m[b-3]<<8|m[b-2]<<16|m[b-1]<<24)>>>0}function d(){if(this.pos+8>this.len)throw f(this,8);return new l(u(this.buf,this.pos+=4),u(this.buf,this.pos+=4))}g.create=s(),g.prototype._slice=a.Array.prototype.subarray||a.Array.prototype.slice,g.prototype.uint32=(h=4294967295,function(){if(h=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(h=(h|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)||(h=(h|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)||(h=(h|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)||(h=(h|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128))return h;if((this.pos+=5)>this.len)throw this.pos=this.len,f(this,10);return h}),g.prototype.int32=function(){return 0|this.uint32()},g.prototype.sint32=function(){var m=this.uint32();return m>>>1^-(1&m)|0},g.prototype.bool=function(){return this.uint32()!==0},g.prototype.fixed32=function(){if(this.pos+4>this.len)throw f(this,4);return u(this.buf,this.pos+=4)},g.prototype.sfixed32=function(){if(this.pos+4>this.len)throw f(this,4);return 0|u(this.buf,this.pos+=4)},g.prototype.float=function(){if(this.pos+4>this.len)throw f(this,4);var m=a.float.readFloatLE(this.buf,this.pos);return this.pos+=4,m},g.prototype.double=function(){if(this.pos+8>this.len)throw f(this,4);var m=a.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,m},g.prototype.bytes=function(){var m=this.uint32(),b=this.pos,y=this.pos+m;if(y>this.len)throw f(this,m);return this.pos+=m,Array.isArray(this.buf)?this.buf.slice(b,y):b===y?new this.buf.constructor(0):this._slice.call(this.buf,b,y)},g.prototype.string=function(){var m=this.bytes();return c.read(m,0,m.length)},g.prototype.skip=function(m){if(typeof m=="number"){if(this.pos+m>this.len)throw f(this,m);this.pos+=m}else do if(this.pos>=this.len)throw f(this);while(128&this.buf[this.pos++]);return this},g.prototype.skipType=function(m){switch(m){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(m=7&this.uint32())!=4;)this.skipType(m);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+m+" at offset "+this.pos)}return this},g._configure=function(m){n=m,g.create=s(),n._configure();var b=a.Long?"toLong":"toNumber";a.merge(g.prototype,{int64:function(){return r.call(this)[b](!1)},uint64:function(){return r.call(this)[b](!0)},sint64:function(){return r.call(this).zzDecode()[b](!1)},fixed64:function(){return d.call(this)[b](!0)},sfixed64:function(){return d.call(this)[b](!1)}})}},593:(o,t,e)=>{o.exports=l;var n=e(1408);(l.prototype=Object.create(n.prototype)).constructor=l;var a=e(9693);function l(c){n.call(this,c)}l._configure=function(){a.Buffer&&(l.prototype._slice=a.Buffer.prototype.slice)},l.prototype.string=function(){var c=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+c,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+c,this.len))},l._configure()},5054:o=>{o.exports={}},5994:(o,t,e)=>{t.Service=e(7948)},7948:(o,t,e)=>{o.exports=a;var n=e(9693);function a(l,c,f){if(typeof l!="function")throw TypeError("rpcImpl must be a function");n.EventEmitter.call(this),this.rpcImpl=l,this.requestDelimited=!!c,this.responseDelimited=!!f}(a.prototype=Object.create(n.EventEmitter.prototype)).constructor=a,a.prototype.rpcCall=function l(c,f,g,h,p){if(!h)throw TypeError("request must be specified");var s=this;if(!p)return n.asPromise(l,s,c,f,g,h);if(s.rpcImpl)try{return s.rpcImpl(c,f[s.requestDelimited?"encodeDelimited":"encode"](h).finish(),function(r,u){if(r)return s.emit("error",r,c),p(r);if(u!==null){if(!(u instanceof g))try{u=g[s.responseDelimited?"decodeDelimited":"decode"](u)}catch(d){return s.emit("error",d,c),p(d)}return s.emit("data",u,c),p(null,u)}s.end(!0)})}catch(r){return s.emit("error",r,c),void setTimeout(function(){p(r)},0)}else setTimeout(function(){p(Error("already ended"))},0)},a.prototype.end=function(l){return this.rpcImpl&&(l||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(o,t,e)=>{o.exports=a;var n=e(9693);function a(g,h){this.lo=g>>>0,this.hi=h>>>0}var l=a.zero=new a(0,0);l.toNumber=function(){return 0},l.zzEncode=l.zzDecode=function(){return this},l.length=function(){return 1};var c=a.zeroHash="\0\0\0\0\0\0\0\0";a.fromNumber=function(g){if(g===0)return l;var h=g<0;h&&(g=-g);var p=g>>>0,s=(g-p)/4294967296>>>0;return h&&(s=~s>>>0,p=~p>>>0,++p>4294967295&&(p=0,++s>4294967295&&(s=0))),new a(p,s)},a.from=function(g){if(typeof g=="number")return a.fromNumber(g);if(n.isString(g)){if(!n.Long)return a.fromNumber(parseInt(g,10));g=n.Long.fromString(g)}return g.low||g.high?new a(g.low>>>0,g.high>>>0):l},a.prototype.toNumber=function(g){if(!g&&this.hi>>>31){var h=1+~this.lo>>>0,p=~this.hi>>>0;return h||(p=p+1>>>0),-(h+4294967296*p)}return this.lo+4294967296*this.hi},a.prototype.toLong=function(g){return n.Long?new n.Long(0|this.lo,0|this.hi,!!g):{low:0|this.lo,high:0|this.hi,unsigned:!!g}};var f=String.prototype.charCodeAt;a.fromHash=function(g){return g===c?l:new a((f.call(g,0)|f.call(g,1)<<8|f.call(g,2)<<16|f.call(g,3)<<24)>>>0,(f.call(g,4)|f.call(g,5)<<8|f.call(g,6)<<16|f.call(g,7)<<24)>>>0)},a.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},a.prototype.zzEncode=function(){var g=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^g)>>>0,this.lo=(this.lo<<1^g)>>>0,this},a.prototype.zzDecode=function(){var g=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^g)>>>0,this.hi=(this.hi>>>1^g)>>>0,this},a.prototype.length=function(){var g=this.lo,h=(this.lo>>>28|this.hi<<4)>>>0,p=this.hi>>>24;return p===0?h===0?g<16384?g<128?1:2:g<2097152?3:4:h<16384?h<128?5:6:h<2097152?7:8:p<128?9:10}},9693:function(o,t,e){var n=t;function a(c,f,g){for(var h=Object.keys(f),p=0;p<h.length;++p)c[h[p]]!==void 0&&g||(c[h[p]]=f[h[p]]);return c}function l(c){function f(g,h){if(!(this instanceof f))return new f(g,h);Object.defineProperty(this,"message",{get:function(){return g}}),Error.captureStackTrace?Error.captureStackTrace(this,f):Object.defineProperty(this,"stack",{value:new Error().stack||""}),h&&a(this,h)}return(f.prototype=Object.create(Error.prototype)).constructor=f,Object.defineProperty(f.prototype,"name",{get:function(){return c}}),f.prototype.toString=function(){return this.name+": "+this.message},f}n.asPromise=e(4537),n.base64=e(7419),n.EventEmitter=e(9211),n.float=e(945),n.inquire=e(7199),n.utf8=e(4997),n.pool=e(6662),n.LongBits=e(1945),n.isNode=!!(e.g!==void 0&&e.g&&e.g.process&&e.g.process.versions&&e.g.process.versions.node),n.global=n.isNode&&e.g||typeof window<"u"&&window||typeof self<"u"&&self||this,n.emptyArray=Object.freeze?Object.freeze([]):[],n.emptyObject=Object.freeze?Object.freeze({}):{},n.isInteger=Number.isInteger||function(c){return typeof c=="number"&&isFinite(c)&&Math.floor(c)===c},n.isString=function(c){return typeof c=="string"||c instanceof String},n.isObject=function(c){return c&&typeof c=="object"},n.isset=n.isSet=function(c,f){var g=c[f];return!(g==null||!c.hasOwnProperty(f))&&(typeof g!="object"||(Array.isArray(g)?g.length:Object.keys(g).length)>0)},n.Buffer=function(){try{var c=n.inquire("buffer").Buffer;return c.prototype.utf8Write?c:null}catch{return null}}(),n._Buffer_from=null,n._Buffer_allocUnsafe=null,n.newBuffer=function(c){return typeof c=="number"?n.Buffer?n._Buffer_allocUnsafe(c):new n.Array(c):n.Buffer?n._Buffer_from(c):typeof Uint8Array>"u"?c:new Uint8Array(c)},n.Array=typeof Uint8Array<"u"?Uint8Array:Array,n.Long=n.global.dcodeIO&&n.global.dcodeIO.Long||n.global.Long||n.inquire("long"),n.key2Re=/^true|false|0|1$/,n.key32Re=/^-?(?:0|[1-9][0-9]*)$/,n.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,n.longToHash=function(c){return c?n.LongBits.from(c).toHash():n.LongBits.zeroHash},n.longFromHash=function(c,f){var g=n.LongBits.fromHash(c);return n.Long?n.Long.fromBits(g.lo,g.hi,f):g.toNumber(!!f)},n.merge=a,n.lcFirst=function(c){return c.charAt(0).toLowerCase()+c.substring(1)},n.newError=l,n.ProtocolError=l("ProtocolError"),n.oneOfGetter=function(c){for(var f={},g=0;g<c.length;++g)f[c[g]]=1;return function(){for(var h=Object.keys(this),p=h.length-1;p>-1;--p)if(f[h[p]]===1&&this[h[p]]!==void 0&&this[h[p]]!==null)return h[p]}},n.oneOfSetter=function(c){return function(f){for(var g=0;g<c.length;++g)c[g]!==f&&delete this[c[g]]}},n.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},n._configure=function(){var c=n.Buffer;c?(n._Buffer_from=c.from!==Uint8Array.from&&c.from||function(f,g){return new c(f,g)},n._Buffer_allocUnsafe=c.allocUnsafe||function(f){return new c(f)}):n._Buffer_from=n._Buffer_allocUnsafe=null}},1173:(o,t,e)=>{o.exports=s;var n,a=e(9693),l=a.LongBits,c=a.base64,f=a.utf8;function g(w,x,_){this.fn=w,this.len=x,this.next=void 0,this.val=_}function h(){}function p(w){this.head=w.head,this.tail=w.tail,this.len=w.len,this.next=w.states}function s(){this.len=0,this.head=new g(h,0,0),this.tail=this.head,this.states=null}var r=function(){return a.Buffer?function(){return(s.create=function(){return new n})()}:function(){return new s}};function u(w,x,_){x[_]=255&w}function d(w,x){this.len=w,this.next=void 0,this.val=x}function m(w,x,_){for(;w.hi;)x[_++]=127&w.lo|128,w.lo=(w.lo>>>7|w.hi<<25)>>>0,w.hi>>>=7;for(;w.lo>127;)x[_++]=127&w.lo|128,w.lo=w.lo>>>7;x[_++]=w.lo}function b(w,x,_){x[_]=255&w,x[_+1]=w>>>8&255,x[_+2]=w>>>16&255,x[_+3]=w>>>24}s.create=r(),s.alloc=function(w){return new a.Array(w)},a.Array!==Array&&(s.alloc=a.pool(s.alloc,a.Array.prototype.subarray)),s.prototype._push=function(w,x,_){return this.tail=this.tail.next=new g(w,x,_),this.len+=x,this},d.prototype=Object.create(g.prototype),d.prototype.fn=function(w,x,_){for(;w>127;)x[_++]=127&w|128,w>>>=7;x[_]=w},s.prototype.uint32=function(w){return this.len+=(this.tail=this.tail.next=new d((w>>>=0)<128?1:w<16384?2:w<2097152?3:w<268435456?4:5,w)).len,this},s.prototype.int32=function(w){return w<0?this._push(m,10,l.fromNumber(w)):this.uint32(w)},s.prototype.sint32=function(w){return this.uint32((w<<1^w>>31)>>>0)},s.prototype.uint64=function(w){var x=l.from(w);return this._push(m,x.length(),x)},s.prototype.int64=s.prototype.uint64,s.prototype.sint64=function(w){var x=l.from(w).zzEncode();return this._push(m,x.length(),x)},s.prototype.bool=function(w){return this._push(u,1,w?1:0)},s.prototype.fixed32=function(w){return this._push(b,4,w>>>0)},s.prototype.sfixed32=s.prototype.fixed32,s.prototype.fixed64=function(w){var x=l.from(w);return this._push(b,4,x.lo)._push(b,4,x.hi)},s.prototype.sfixed64=s.prototype.fixed64,s.prototype.float=function(w){return this._push(a.float.writeFloatLE,4,w)},s.prototype.double=function(w){return this._push(a.float.writeDoubleLE,8,w)};var y=a.Array.prototype.set?function(w,x,_){x.set(w,_)}:function(w,x,_){for(var v=0;v<w.length;++v)x[_+v]=w[v]};s.prototype.bytes=function(w){var x=w.length>>>0;if(!x)return this._push(u,1,0);if(a.isString(w)){var _=s.alloc(x=c.length(w));c.decode(w,_,0),w=_}return this.uint32(x)._push(y,x,w)},s.prototype.string=function(w){var x=f.length(w);return x?this.uint32(x)._push(f.write,x,w):this._push(u,1,0)},s.prototype.fork=function(){return this.states=new p(this),this.head=this.tail=new g(h,0,0),this.len=0,this},s.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new g(h,0,0),this.len=0),this},s.prototype.ldelim=function(){var w=this.head,x=this.tail,_=this.len;return this.reset().uint32(_),_&&(this.tail.next=w.next,this.tail=x,this.len+=_),this},s.prototype.finish=function(){for(var w=this.head.next,x=this.constructor.alloc(this.len),_=0;w;)w.fn(w.val,x,_),_+=w.len,w=w.next;return x},s._configure=function(w){n=w,s.create=r(),n._configure()}},3155:(o,t,e)=>{o.exports=l;var n=e(1173);(l.prototype=Object.create(n.prototype)).constructor=l;var a=e(9693);function l(){n.call(this)}function c(f,g,h){f.length<40?a.utf8.write(f,g,h):g.utf8Write?g.utf8Write(f,h):g.write(f,h)}l._configure=function(){l.alloc=a._Buffer_allocUnsafe,l.writeBytesBuffer=a.Buffer&&a.Buffer.prototype instanceof Uint8Array&&a.Buffer.prototype.set.name==="set"?function(f,g,h){g.set(f,h)}:function(f,g,h){if(f.copy)f.copy(g,h,0,f.length);else for(var p=0;p<f.length;)g[h++]=f[p++]}},l.prototype.bytes=function(f){a.isString(f)&&(f=a._Buffer_from(f,"base64"));var g=f.length>>>0;return this.uint32(g),g&&this._push(l.writeBytesBuffer,g,f),this},l.prototype.string=function(f){var g=a.Buffer.byteLength(f);return this.uint32(g),g&&this._push(c,g,f),this},l._configure()},4154:o=>{o.exports=`"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};
`},7067:()=>{},1296:()=>{},760:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(o,t,e)=>{e.r(t),e.d(t,{flatbuffers:()=>n});var n={};n.Offset,n.Table,n.SIZEOF_SHORT=2,n.SIZEOF_INT=4,n.FILE_IDENTIFIER_LENGTH=4,n.SIZE_PREFIX_LENGTH=4,n.Encoding={UTF8_BYTES:1,UTF16_STRING:2},n.int32=new Int32Array(2),n.float32=new Float32Array(n.int32.buffer),n.float64=new Float64Array(n.int32.buffer),n.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,n.Long=function(a,l){this.low=0|a,this.high=0|l},n.Long.create=function(a,l){return a==0&&l==0?n.Long.ZERO:new n.Long(a,l)},n.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},n.Long.prototype.equals=function(a){return this.low==a.low&&this.high==a.high},n.Long.ZERO=new n.Long(0,0),n.Builder=function(a){if(a)l=a;else var l=1024;this.bb=n.ByteBuffer.allocate(l),this.space=l,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},n.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},n.Builder.prototype.forceDefaults=function(a){this.force_defaults=a},n.Builder.prototype.dataBuffer=function(){return this.bb},n.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},n.Builder.prototype.prep=function(a,l){a>this.minalign&&(this.minalign=a);for(var c=1+~(this.bb.capacity()-this.space+l)&a-1;this.space<c+a+l;){var f=this.bb.capacity();this.bb=n.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-f}this.pad(c)},n.Builder.prototype.pad=function(a){for(var l=0;l<a;l++)this.bb.writeInt8(--this.space,0)},n.Builder.prototype.writeInt8=function(a){this.bb.writeInt8(this.space-=1,a)},n.Builder.prototype.writeInt16=function(a){this.bb.writeInt16(this.space-=2,a)},n.Builder.prototype.writeInt32=function(a){this.bb.writeInt32(this.space-=4,a)},n.Builder.prototype.writeInt64=function(a){this.bb.writeInt64(this.space-=8,a)},n.Builder.prototype.writeFloat32=function(a){this.bb.writeFloat32(this.space-=4,a)},n.Builder.prototype.writeFloat64=function(a){this.bb.writeFloat64(this.space-=8,a)},n.Builder.prototype.addInt8=function(a){this.prep(1,0),this.writeInt8(a)},n.Builder.prototype.addInt16=function(a){this.prep(2,0),this.writeInt16(a)},n.Builder.prototype.addInt32=function(a){this.prep(4,0),this.writeInt32(a)},n.Builder.prototype.addInt64=function(a){this.prep(8,0),this.writeInt64(a)},n.Builder.prototype.addFloat32=function(a){this.prep(4,0),this.writeFloat32(a)},n.Builder.prototype.addFloat64=function(a){this.prep(8,0),this.writeFloat64(a)},n.Builder.prototype.addFieldInt8=function(a,l,c){(this.force_defaults||l!=c)&&(this.addInt8(l),this.slot(a))},n.Builder.prototype.addFieldInt16=function(a,l,c){(this.force_defaults||l!=c)&&(this.addInt16(l),this.slot(a))},n.Builder.prototype.addFieldInt32=function(a,l,c){(this.force_defaults||l!=c)&&(this.addInt32(l),this.slot(a))},n.Builder.prototype.addFieldInt64=function(a,l,c){!this.force_defaults&&l.equals(c)||(this.addInt64(l),this.slot(a))},n.Builder.prototype.addFieldFloat32=function(a,l,c){(this.force_defaults||l!=c)&&(this.addFloat32(l),this.slot(a))},n.Builder.prototype.addFieldFloat64=function(a,l,c){(this.force_defaults||l!=c)&&(this.addFloat64(l),this.slot(a))},n.Builder.prototype.addFieldOffset=function(a,l,c){(this.force_defaults||l!=c)&&(this.addOffset(l),this.slot(a))},n.Builder.prototype.addFieldStruct=function(a,l,c){l!=c&&(this.nested(l),this.slot(a))},n.Builder.prototype.nested=function(a){if(a!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},n.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},n.Builder.prototype.slot=function(a){this.vtable[a]=this.offset()},n.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},n.Builder.growByteBuffer=function(a){var l=a.capacity();if(3221225472&l)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var c=l<<1,f=n.ByteBuffer.allocate(c);return f.setPosition(c-l),f.bytes().set(a.bytes(),c-l),f},n.Builder.prototype.addOffset=function(a){this.prep(n.SIZEOF_INT,0),this.writeInt32(this.offset()-a+n.SIZEOF_INT)},n.Builder.prototype.startObject=function(a){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=a;for(var l=0;l<a;l++)this.vtable[l]=0;this.isNested=!0,this.object_start=this.offset()},n.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var a=this.offset(),l=this.vtable_in_use-1;l>=0&&this.vtable[l]==0;l--);for(var c=l+1;l>=0;l--)this.addInt16(this.vtable[l]!=0?a-this.vtable[l]:0);this.addInt16(a-this.object_start);var f=(c+2)*n.SIZEOF_SHORT;this.addInt16(f);var g=0,h=this.space;t:for(l=0;l<this.vtables.length;l++){var p=this.bb.capacity()-this.vtables[l];if(f==this.bb.readInt16(p)){for(var s=n.SIZEOF_SHORT;s<f;s+=n.SIZEOF_SHORT)if(this.bb.readInt16(h+s)!=this.bb.readInt16(p+s))continue t;g=this.vtables[l];break}}return g?(this.space=this.bb.capacity()-a,this.bb.writeInt32(this.space,g-a)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-a,this.offset()-a)),this.isNested=!1,a},n.Builder.prototype.finish=function(a,l,c){var f=c?n.SIZE_PREFIX_LENGTH:0;if(l){var g=l;if(this.prep(this.minalign,n.SIZEOF_INT+n.FILE_IDENTIFIER_LENGTH+f),g.length!=n.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+n.FILE_IDENTIFIER_LENGTH);for(var h=n.FILE_IDENTIFIER_LENGTH-1;h>=0;h--)this.writeInt8(g.charCodeAt(h))}this.prep(this.minalign,n.SIZEOF_INT+f),this.addOffset(a),f&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},n.Builder.prototype.finishSizePrefixed=function(a,l){this.finish(a,l,!0)},n.Builder.prototype.requiredField=function(a,l){var c=this.bb.capacity()-a,f=c-this.bb.readInt32(c);if(this.bb.readInt16(f+l)==0)throw new Error("FlatBuffers: field "+l+" must be set")},n.Builder.prototype.startVector=function(a,l,c){this.notNested(),this.vector_num_elems=l,this.prep(n.SIZEOF_INT,a*l),this.prep(c,a*l)},n.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},n.Builder.prototype.createString=function(a){if(a instanceof Uint8Array)var l=a;else{l=[];for(var c=0;c<a.length;){var f,g=a.charCodeAt(c++);(f=g<55296||g>=56320?g:(g<<10)+a.charCodeAt(c++)+-56613888)<128?l.push(f):(f<2048?l.push(f>>6&31|192):(f<65536?l.push(f>>12&15|224):l.push(f>>18&7|240,f>>12&63|128),l.push(f>>6&63|128)),l.push(63&f|128))}}this.addInt8(0),this.startVector(1,l.length,1),this.bb.setPosition(this.space-=l.length),c=0;for(var h=this.space,p=this.bb.bytes();c<l.length;c++)p[h++]=l[c];return this.endVector()},n.Builder.prototype.createLong=function(a,l){return n.Long.create(a,l)},n.ByteBuffer=function(a){this.bytes_=a,this.position_=0},n.ByteBuffer.allocate=function(a){return new n.ByteBuffer(new Uint8Array(a))},n.ByteBuffer.prototype.clear=function(){this.position_=0},n.ByteBuffer.prototype.bytes=function(){return this.bytes_},n.ByteBuffer.prototype.position=function(){return this.position_},n.ByteBuffer.prototype.setPosition=function(a){this.position_=a},n.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},n.ByteBuffer.prototype.readInt8=function(a){return this.readUint8(a)<<24>>24},n.ByteBuffer.prototype.readUint8=function(a){return this.bytes_[a]},n.ByteBuffer.prototype.readInt16=function(a){return this.readUint16(a)<<16>>16},n.ByteBuffer.prototype.readUint16=function(a){return this.bytes_[a]|this.bytes_[a+1]<<8},n.ByteBuffer.prototype.readInt32=function(a){return this.bytes_[a]|this.bytes_[a+1]<<8|this.bytes_[a+2]<<16|this.bytes_[a+3]<<24},n.ByteBuffer.prototype.readUint32=function(a){return this.readInt32(a)>>>0},n.ByteBuffer.prototype.readInt64=function(a){return new n.Long(this.readInt32(a),this.readInt32(a+4))},n.ByteBuffer.prototype.readUint64=function(a){return new n.Long(this.readUint32(a),this.readUint32(a+4))},n.ByteBuffer.prototype.readFloat32=function(a){return n.int32[0]=this.readInt32(a),n.float32[0]},n.ByteBuffer.prototype.readFloat64=function(a){return n.int32[n.isLittleEndian?0:1]=this.readInt32(a),n.int32[n.isLittleEndian?1:0]=this.readInt32(a+4),n.float64[0]},n.ByteBuffer.prototype.writeInt8=function(a,l){this.bytes_[a]=l},n.ByteBuffer.prototype.writeUint8=function(a,l){this.bytes_[a]=l},n.ByteBuffer.prototype.writeInt16=function(a,l){this.bytes_[a]=l,this.bytes_[a+1]=l>>8},n.ByteBuffer.prototype.writeUint16=function(a,l){this.bytes_[a]=l,this.bytes_[a+1]=l>>8},n.ByteBuffer.prototype.writeInt32=function(a,l){this.bytes_[a]=l,this.bytes_[a+1]=l>>8,this.bytes_[a+2]=l>>16,this.bytes_[a+3]=l>>24},n.ByteBuffer.prototype.writeUint32=function(a,l){this.bytes_[a]=l,this.bytes_[a+1]=l>>8,this.bytes_[a+2]=l>>16,this.bytes_[a+3]=l>>24},n.ByteBuffer.prototype.writeInt64=function(a,l){this.writeInt32(a,l.low),this.writeInt32(a+4,l.high)},n.ByteBuffer.prototype.writeUint64=function(a,l){this.writeUint32(a,l.low),this.writeUint32(a+4,l.high)},n.ByteBuffer.prototype.writeFloat32=function(a,l){n.float32[0]=l,this.writeInt32(a,n.int32[0])},n.ByteBuffer.prototype.writeFloat64=function(a,l){n.float64[0]=l,this.writeInt32(a,n.int32[n.isLittleEndian?0:1]),this.writeInt32(a+4,n.int32[n.isLittleEndian?1:0])},n.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+n.SIZEOF_INT+n.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var a="",l=0;l<n.FILE_IDENTIFIER_LENGTH;l++)a+=String.fromCharCode(this.readInt8(this.position_+n.SIZEOF_INT+l));return a},n.ByteBuffer.prototype.__offset=function(a,l){var c=a-this.readInt32(a);return l<this.readInt16(c)?this.readInt16(c+l):0},n.ByteBuffer.prototype.__union=function(a,l){return a.bb_pos=l+this.readInt32(l),a.bb=this,a},n.ByteBuffer.prototype.__string=function(a,l){a+=this.readInt32(a);var c=this.readInt32(a),f="",g=0;if(a+=n.SIZEOF_INT,l===n.Encoding.UTF8_BYTES)return this.bytes_.subarray(a,a+c);for(;g<c;){var h,p=this.readUint8(a+g++);if(p<192)h=p;else{var s=this.readUint8(a+g++);if(p<224)h=(31&p)<<6|63&s;else{var r=this.readUint8(a+g++);h=p<240?(15&p)<<12|(63&s)<<6|63&r:(7&p)<<18|(63&s)<<12|(63&r)<<6|63&this.readUint8(a+g++)}}h<65536?f+=String.fromCharCode(h):(h-=65536,f+=String.fromCharCode(55296+(h>>10),56320+(1023&h)))}return f},n.ByteBuffer.prototype.__indirect=function(a){return a+this.readInt32(a)},n.ByteBuffer.prototype.__vector=function(a){return a+this.readInt32(a)+n.SIZEOF_INT},n.ByteBuffer.prototype.__vector_len=function(a){return this.readInt32(a+this.readInt32(a))},n.ByteBuffer.prototype.__has_identifier=function(a){if(a.length!=n.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+n.FILE_IDENTIFIER_LENGTH);for(var l=0;l<n.FILE_IDENTIFIER_LENGTH;l++)if(a.charCodeAt(l)!=this.readInt8(this.position_+n.SIZEOF_INT+l))return!1;return!0},n.ByteBuffer.prototype.createLong=function(a,l){return n.Long.create(a,l)}}},__webpack_module_cache__={};function __webpack_require__(o){var t=__webpack_module_cache__[o];if(t!==void 0)return t.exports;var e=__webpack_module_cache__[o]={exports:{}};return __webpack_modules__[o].call(e.exports,e,e.exports,__webpack_require__),e.exports}__webpack_require__.n=o=>{var t=o&&o.__esModule?()=>o.default:()=>o;return __webpack_require__.d(t,{a:t}),t},__webpack_require__.d=(o,t)=>{for(var e in t)__webpack_require__.o(t,e)&&!__webpack_require__.o(o,e)&&Object.defineProperty(o,e,{enumerable:!0,get:t[e]})},__webpack_require__.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),__webpack_require__.o=(o,t)=>Object.prototype.hasOwnProperty.call(o,t),__webpack_require__.r=o=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(o,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(o,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(1057);return __webpack_exports__})())})(ort_min);var ort_minExports=ort_min.exports;let model=null;const MODEL_DIR="/rembg-web/silueta.onnx";onmessage=async function(o){if(o.data==="loadModel")try{await loadModel(),postMessage("modelLoaded")}catch{postMessage("modelLoadError")}else if(o.data[0]==="rembg")try{const t=await rembg(o.data[1]);postMessage(["result",t])}catch{postMessage("rembgError")}};const loadModel=async()=>{if(model)return model;const o=MODEL_DIR;return model=await ort_minExports.InferenceSession.create(o,{executionProviders:["wasm"]}),model},rembg=async o=>{const t=await loadModel(),e=await Image$1.load(o),{width:n,height:a}=e,l=320;let c=e.resize({width:l,height:l}).data;e.alpha===1&&(c=removeAlpha(c));const f=[new Float32Array(l*l),new Float32Array(l*l),new Float32Array(l*l)],g=getMax(c),h=[.485,.456,.406],p=[.229,.224,.225];for(let w=0;w<c.length;w++){const x=w%3,_=Math.floor(w/3);f[x][_]=(c[w]/g-h[x])/p[x]}const s=concatFloat32Array([f[2],f[0],f[1]]),r=await t.run({"input.1":new ort_minExports.Tensor("float32",s,[1,3,320,320])}),u=String(Math.min(...t.outputNames.map(w=>+w))),d=r[u].data;for(let w=0;w<d.length;w++)d[w]=d[w]*255;const m=new Image$1({width:l,height:l,data:d,components:1,alpha:0}).resize({width:n,height:a}).data,b=e.clone().data;for(let w=0;w<b.length/4;w++){const x=m[w];b[w*4+3]=x}return"data:image/png;base64,"+new Image$1({width:n,height:a,data:b,kind:"RGBA",alpha:1,components:3}).toBase64()};function concatFloat32Array(o){let t=0;for(const a of o)t+=a.length;const e=new Float32Array(t);let n=0;for(const a of o)for(const l of a)e[n]=l,n++;return e}function removeAlpha(o){const t=new Array;for(let e=0;e<o.length;e++)e%4!==3&&t.push(o[e]);return Uint8Array.from(t)}function getMax(o){let t=0;for(let e=0;e<o.length;e++)o[e]>t&&(t=o[e]);return t}})();
